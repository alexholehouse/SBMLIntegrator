/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.0
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGRUBY


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Ruby 1.9.1 has a "memoisation optimisation" when compiling with GCC which
 * breaks using rb_intern as an lvalue, as SWIG does.  We work around this
 * issue for now by disabling this.
 * https://sourceforge.net/tracker/?func=detail&aid=2859614&group_id=1645&atid=101645
 */
#ifdef rb_intern
# undef rb_intern
#endif

/* Remove global macros defined in Ruby's win32.h */
#ifdef write
# undef write
#endif
#ifdef read
# undef read
#endif
#ifdef bind
# undef bind
#endif
#ifdef close
# undef close
#endif
#ifdef connect
# undef connect
#endif


/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RSTRING_END
# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif
#ifndef RFLOAT_VALUE
# define RFLOAT_VALUE(x) RFLOAT(x)->value
#endif
#ifndef DOUBLE2NUM
# define DOUBLE2NUM(x) rb_float_new(x)
#endif
#ifndef RHASH_TBL
# define RHASH_TBL(x) (RHASH(x)->tbl)
#endif
#ifndef RHASH_ITER_LEV
# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
#endif
#ifndef RHASH_IFNONE
# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
#endif
#ifndef RHASH_SIZE
# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
#endif
#ifndef RHASH_EMPTY_P
# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
#endif
#ifndef RSTRUCT_LEN
# define RSTRUCT_LEN(x) RSTRUCT(x)->len
#endif
#ifndef RSTRUCT_PTR
# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
#endif



/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

static VALUE _mSWIG = Qnil;

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}


/* This function is called when a user inputs a wrong argument to
   a method.
 */
SWIGINTERN 
const char* Ruby_Format_TypeError( const char* msg,
				   const char* type, 
				   const char* name, 
				   const int argn,
				   VALUE input )
{
  char buf[128];
  VALUE str;
  VALUE asStr;
  if ( msg && *msg )
    {
      str = rb_str_new2(msg);
    }
  else
    {
      str = rb_str_new(NULL, 0);
    }

  str = rb_str_cat2( str, "Expected argument " );
  sprintf( buf, "%d of type ", argn-1 );
  str = rb_str_cat2( str, buf );
  str = rb_str_cat2( str, type );
  str = rb_str_cat2( str, ", but got " );
  str = rb_str_cat2( str, rb_obj_classname(input) );
  str = rb_str_cat2( str, " " );
  asStr = rb_inspect(input);
  if ( RSTRING_LEN(asStr) > 30 )
    {
      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
      str = rb_str_cat2( str, "..." );
    }
  else
    {
      str = rb_str_append( str, asStr );
    }

  if ( name )
    {
      str = rb_str_cat2( str, "\n\tin SWIG method '" );
      str = rb_str_cat2( str, name );
      str = rb_str_cat2( str, "'" );
    }

  return StringValuePtr( str );
}

/* This function is called when an overloaded method fails */
SWIGINTERN 
void Ruby_Format_OverloadedError(
				 const int argc,
				 const int maxargs,
				 const char* method, 
				 const char* prototypes 
				 )
{
  const char* msg = "Wrong # of arguments";
  if ( argc <= maxargs ) msg = "Wrong arguments";
  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
	   "Possible C/C++ prototypes are:\n%s",
	   msg, method, prototypes);
}

/* -----------------------------------------------------------------------------
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* Ruby 1.8 actually assumes the first case. */
#if SIZEOF_VOIDP == SIZEOF_LONG
#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
#else
#  error sizeof(void*) is not the same as long or long long
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. 
*/
static VALUE swig_ruby_trackings = Qnil;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects. */

  /* Try to see if some other .so has already created a 
     tracking hash table, which we keep hidden in an instance var
     in the SWIG module.
     This is done to allow multiple DSOs to share the same
     tracking table.
  */
  ID trackings_id = rb_intern( "@__trackings__" );
  VALUE verbose = rb_gv_get("VERBOSE");
  rb_gv_set("VERBOSE", Qfalse);
  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
  rb_gv_set("VERBOSE", verbose);

  /* No, it hasn't.  Create one ourselves */ 
  if ( swig_ruby_trackings == Qnil )
    {
      swig_ruby_trackings = rb_hash_new();
      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
    }

  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  return SWIG2NUM(ptr);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  return SWIG2NUM(object);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* Convert the Ruby number to a Ruby object */
  return NUM2SWIG(reference);
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

/* For ruby1.8.4 and earlier. */
#ifndef RUBY_INIT_STACK
   RUBY_EXTERN void Init_stack(VALUE* addr);
#  define RUBY_INIT_STACK \
   VALUE variable_in_this_stack_frame; \
   Init_stack(&variable_in_this_stack_frame);
#endif


#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), "%s", msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  

#include "assert.h"

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


/* Global pointer used to keep some internal SWIG stuff */
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Global IDs used to keep some internal SWIG stuff */
static ID swig_arity_id = 0;
static ID swig_call_id  = 0;

/*
  If your swig extension is to be run within an embedded ruby and has
  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
  This will reset ruby's stack frame on each entry point from the main 
  program the first time a virtual director function is invoked (in a 
  non-recursive way).
  If this is not done, you run the risk of Ruby trashing the stack.
*/

#ifdef RUBY_EMBEDDED

#  define SWIG_INIT_STACK                            \
      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
      ++swig_virtual_calls;
#  define SWIG_RELEASE_STACK --swig_virtual_calls;
#  define Ruby_DirectorTypeMismatchException(x) \
          rb_raise( rb_eTypeError, "%s", x ); return c_result;

      static unsigned int swig_virtual_calls = 0;

#else  /* normal non-embedded extension */

#  define SWIG_INIT_STACK
#  define SWIG_RELEASE_STACK
#  define Ruby_DirectorTypeMismatchException(x) \
          throw Swig::DirectorTypeMismatchException( x );

#endif  /* RUBY_EMBEDDED */


SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
    swig_call_id  = rb_intern("call");
    swig_arity_id = rb_intern("arity");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  int track;
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    track = sklass->trackObjects;
    if (track) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "@__swigtype__");
        char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
			   ( own ? VOIDFUNC(sklass->destroy) : 
			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
			     ), ptr);

    /* If tracking is on for this class then track this object. */
    if (track) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "@__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    } else {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void)
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

/* This function can be used to check whether a proc or method or similarly
   callable function has been passed.  Usually used in a %typecheck, like:

   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
        $result = SWIG_Ruby_isCallable( $input );
   }
 */
SWIGINTERN
int SWIG_Ruby_isCallable( VALUE proc )
{
  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
    return 1;
  return 0;
}

/* This function can be used to check the arity (number of arguments)
   a proc or method can take.  Usually used in a %typecheck.
   Valid arities will be that equal to minimal or those < 0
   which indicate a variable number of parameters at the end.
 */
SWIGINTERN
int SWIG_Ruby_arity( VALUE proc, int minimal )
{
  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
    {
      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
      int arity = NUM2INT(num);
      if ( arity < 0 && (arity+1) < -minimal ) return 1;
      if ( arity == minimal ) return 1;
      return 1;
    }
  return 0;
}


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg);; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ASTNode swig_types[0]
#define SWIGTYPE_p_ASTNodeType_t swig_types[1]
#define SWIGTYPE_p_AlgebraicRule swig_types[2]
#define SWIGTYPE_p_AssignmentRule swig_types[3]
#define SWIGTYPE_p_BiolQualifierType_t swig_types[4]
#define SWIGTYPE_p_CVTerm swig_types[5]
#define SWIGTYPE_p_Compartment swig_types[6]
#define SWIGTYPE_p_CompartmentType swig_types[7]
#define SWIGTYPE_p_Constraint swig_types[8]
#define SWIGTYPE_p_Date swig_types[9]
#define SWIGTYPE_p_Delay swig_types[10]
#define SWIGTYPE_p_Event swig_types[11]
#define SWIGTYPE_p_EventAssignment swig_types[12]
#define SWIGTYPE_p_ExpectedAttributes swig_types[13]
#define SWIGTYPE_p_FunctionDefinition swig_types[14]
#define SWIGTYPE_p_ISBMLExtensionNamespaces swig_types[15]
#define SWIGTYPE_p_InitialAssignment swig_types[16]
#define SWIGTYPE_p_KineticLaw swig_types[17]
#define SWIGTYPE_p_List swig_types[18]
#define SWIGTYPE_p_ListOf swig_types[19]
#define SWIGTYPE_p_ListOfCompartmentTypes swig_types[20]
#define SWIGTYPE_p_ListOfCompartments swig_types[21]
#define SWIGTYPE_p_ListOfConstraints swig_types[22]
#define SWIGTYPE_p_ListOfEventAssignments swig_types[23]
#define SWIGTYPE_p_ListOfEvents swig_types[24]
#define SWIGTYPE_p_ListOfFunctionDefinitions swig_types[25]
#define SWIGTYPE_p_ListOfInitialAssignments swig_types[26]
#define SWIGTYPE_p_ListOfLocalParameters swig_types[27]
#define SWIGTYPE_p_ListOfParameters swig_types[28]
#define SWIGTYPE_p_ListOfReactions swig_types[29]
#define SWIGTYPE_p_ListOfRules swig_types[30]
#define SWIGTYPE_p_ListOfSpecies swig_types[31]
#define SWIGTYPE_p_ListOfSpeciesReferences swig_types[32]
#define SWIGTYPE_p_ListOfSpeciesTypes swig_types[33]
#define SWIGTYPE_p_ListOfUnitDefinitions swig_types[34]
#define SWIGTYPE_p_ListOfUnits swig_types[35]
#define SWIGTYPE_p_ListWrapperT_ASTNode_t swig_types[36]
#define SWIGTYPE_p_ListWrapperT_CVTerm_t swig_types[37]
#define SWIGTYPE_p_ListWrapperT_Date_t swig_types[38]
#define SWIGTYPE_p_ListWrapperT_ModelCreator_t swig_types[39]
#define SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t swig_types[40]
#define SWIGTYPE_p_LocalParameter swig_types[41]
#define SWIGTYPE_p_Model swig_types[42]
#define SWIGTYPE_p_ModelCreator swig_types[43]
#define SWIGTYPE_p_ModelHistory swig_types[44]
#define SWIGTYPE_p_ModelQualifierType_t swig_types[45]
#define SWIGTYPE_p_ModifierSpeciesReference swig_types[46]
#define SWIGTYPE_p_OperationReturnValues_t swig_types[47]
#define SWIGTYPE_p_Parameter swig_types[48]
#define SWIGTYPE_p_ParentMap__iterator swig_types[49]
#define SWIGTYPE_p_Priority swig_types[50]
#define SWIGTYPE_p_QualifierType_t swig_types[51]
#define SWIGTYPE_p_RDFAnnotationParser swig_types[52]
#define SWIGTYPE_p_RateRule swig_types[53]
#define SWIGTYPE_p_Reaction swig_types[54]
#define SWIGTYPE_p_Rule swig_types[55]
#define SWIGTYPE_p_RuleType_t swig_types[56]
#define SWIGTYPE_p_SBMLConstructorException swig_types[57]
#define SWIGTYPE_p_SBMLDocument swig_types[58]
#define SWIGTYPE_p_SBMLDocumentPlugin swig_types[59]
#define SWIGTYPE_p_SBMLError swig_types[60]
#define SWIGTYPE_p_SBMLErrorCategory_t swig_types[61]
#define SWIGTYPE_p_SBMLErrorCode_t swig_types[62]
#define SWIGTYPE_p_SBMLErrorLog swig_types[63]
#define SWIGTYPE_p_SBMLErrorSeverity_t swig_types[64]
#define SWIGTYPE_p_SBMLExtension swig_types[65]
#define SWIGTYPE_p_SBMLExtensionException swig_types[66]
#define SWIGTYPE_p_SBMLExtensionRegistry swig_types[67]
#define SWIGTYPE_p_SBMLNamespaces swig_types[68]
#define SWIGTYPE_p_SBMLReader swig_types[69]
#define SWIGTYPE_p_SBMLTransforms swig_types[70]
#define SWIGTYPE_p_SBMLTypeCode_t swig_types[71]
#define SWIGTYPE_p_SBMLWriter swig_types[72]
#define SWIGTYPE_p_SBO swig_types[73]
#define SWIGTYPE_p_SBase swig_types[74]
#define SWIGTYPE_p_SBaseExtensionPoint swig_types[75]
#define SWIGTYPE_p_SBasePlugin swig_types[76]
#define SWIGTYPE_p_SBasePluginCreatorBase swig_types[77]
#define SWIGTYPE_p_SimpleSpeciesReference swig_types[78]
#define SWIGTYPE_p_Species swig_types[79]
#define SWIGTYPE_p_SpeciesReference swig_types[80]
#define SWIGTYPE_p_SpeciesType swig_types[81]
#define SWIGTYPE_p_StoichiometryMath swig_types[82]
#define SWIGTYPE_p_SupportedPackageURIList swig_types[83]
#define SWIGTYPE_p_SupportedPackageURIListIter swig_types[84]
#define SWIGTYPE_p_SyntaxChecker swig_types[85]
#define SWIGTYPE_p_Trigger swig_types[86]
#define SWIGTYPE_p_Unit swig_types[87]
#define SWIGTYPE_p_UnitDefinition swig_types[88]
#define SWIGTYPE_p_UnitKind_t swig_types[89]
#define SWIGTYPE_p_XMLAttributes swig_types[90]
#define SWIGTYPE_p_XMLConstructorException swig_types[91]
#define SWIGTYPE_p_XMLError swig_types[92]
#define SWIGTYPE_p_XMLErrorCategory_t swig_types[93]
#define SWIGTYPE_p_XMLErrorCode_t swig_types[94]
#define SWIGTYPE_p_XMLErrorLog swig_types[95]
#define SWIGTYPE_p_XMLErrorSeverity_t swig_types[96]
#define SWIGTYPE_p_XMLInputStream swig_types[97]
#define SWIGTYPE_p_XMLNamespaces swig_types[98]
#define SWIGTYPE_p_XMLNode swig_types[99]
#define SWIGTYPE_p_XMLOutputFileStream swig_types[100]
#define SWIGTYPE_p_XMLOutputStream swig_types[101]
#define SWIGTYPE_p_XMLOutputStringStream swig_types[102]
#define SWIGTYPE_p_XMLToken swig_types[103]
#define SWIGTYPE_p_XMLTriple swig_types[104]
#define SWIGTYPE_p_allocator_type swig_types[105]
#define SWIGTYPE_p_char swig_types[106]
#define SWIGTYPE_p_char_type swig_types[107]
#define SWIGTYPE_p_const_reference swig_types[108]
#define SWIGTYPE_p_difference_type swig_types[109]
#define SWIGTYPE_p_int_type swig_types[110]
#define SWIGTYPE_p_off_type swig_types[111]
#define SWIGTYPE_p_p_void swig_types[112]
#define SWIGTYPE_p_pos_type swig_types[113]
#define SWIGTYPE_p_reference swig_types[114]
#define SWIGTYPE_p_size_type swig_types[115]
#define SWIGTYPE_p_state_type swig_types[116]
#define SWIGTYPE_p_std__basic_iosT_char_std__char_traitsT_char_t_t swig_types[117]
#define SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t swig_types[118]
#define SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[119]
#define SWIGTYPE_p_std__basic_streambufT_char_std__char_traitsT_char_t_t swig_types[120]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[121]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator swig_types[122]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator swig_types[123]
#define SWIGTYPE_p_std__invalid_argument swig_types[124]
#define SWIGTYPE_p_std__ios_base__openmode swig_types[125]
#define SWIGTYPE_p_std__multimapT_int_int_t swig_types[126]
#define SWIGTYPE_p_std__pairT_ParentMap__iterator_ParentMap__iterator_t swig_types[127]
#define SWIGTYPE_p_swig__ConstIterator swig_types[128]
#define SWIGTYPE_p_swig__GC_VALUE swig_types[129]
#define SWIGTYPE_p_swig__Iterator swig_types[130]
#define SWIGTYPE_p_value_type swig_types[131]
#define SWIGTYPE_p_void swig_types[132]
static swig_type_info *swig_types[134];
static swig_module_info swig_module = {swig_types, 133, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_libSBML
#define SWIG_name    "LibSBML"

static VALUE mLibSBML;

#define SWIG_RUBY_THREAD_BEGIN_BLOCK
#define SWIG_RUBY_THREAD_END_BLOCK


#define SWIGVERSION 0x020000 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


#include "libsbml.h"

LIBSBML_CPP_NAMESPACE_USE

#include "../swig/libsbml-packages.h"
	
#include "local.cpp"


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:/usr/local/share/swig/2.0.0/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


#include <iostream>


#include <stdexcept>


namespace swig {
  class GC_VALUE {
  protected:
    // Hash of all GC_VALUE's currently in use
    static VALUE _hash;

    VALUE  _obj;

    static ID hash_id;
    static ID   lt_id;
    static ID   gt_id;
    static ID   eq_id;
    static ID   le_id;
    static ID   ge_id;

    static ID  pos_id;
    static ID  neg_id;
    static ID  inv_id;

    static ID  add_id;
    static ID  sub_id;
    static ID  mul_id;
    static ID  div_id;
    static ID  mod_id;

    static ID  and_id;
    static ID   or_id;
    static ID  xor_id;

    static ID  lshift_id;
    static ID  rshift_id;

    struct OpArgs
    {
      VALUE src;
      ID    id;
      int   nargs;
      VALUE target;
    };


  public:
    static void initialize()
    {
      if ( _hash == Qnil ) 
	{ 
	  _hash = rb_hash_new();
	  rb_gc_register_address( &_hash );
	}
    }

    // this function is never called.  Provided for symmetry only.
    static void cleanup()
    {
      rb_gc_unregister_address( &_hash );
    }

    GC_VALUE() : _obj( Qnil )
    {
    }

    GC_VALUE(const GC_VALUE& item) : _obj(item._obj)
    {
      GC_register();
    }
    
    GC_VALUE(VALUE obj) :_obj(obj)
    {
      GC_register();
    }
    
    ~GC_VALUE() 
    {
      GC_unregister();
    }
    
    GC_VALUE & operator=(const GC_VALUE& item) 
    {
      GC_unregister();
      _obj = item._obj;
      GC_register();
      return *this;
    }

    void GC_register()
    {
      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
	return;
      VALUE val = rb_hash_aref( _hash, _obj );
      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 0;
      ++n;
      rb_hash_aset( _hash, _obj, INT2NUM(n) );
    }

    void GC_unregister()
    {
      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
	return;
      // this test should not be needed but I've noticed some very erratic
      // behavior of none being unregistered in some very rare situations.
      if ( BUILTIN_TYPE(_obj) == T_NONE ) return;

      VALUE val = rb_hash_aref( _hash, _obj );
      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 1;
      --n;
      if ( n )
	rb_hash_aset( _hash, _obj, INT2NUM(n) );
      else
	rb_hash_delete( _hash, _obj );
    }
    
    operator VALUE() const
    {
      return _obj;
    }

    VALUE inspect() const
    {
      return rb_inspect(_obj);
    }

    VALUE to_s() const
    {
      return rb_inspect(_obj);
    }

    static VALUE swig_protect_funcall( VALUE p )
    {
      OpArgs* args = (OpArgs*) p;
      return rb_funcall( args->src, args->id, args->nargs, args->target );
    }


#define GC_VALUE_CMP( op_id, op, cmp, cmpval ) \
    bool op( const GC_VALUE& other ) const \
    { \
      if ( FIXNUM_P(_obj) && FIXNUM_P(other._obj) ) \
      { \
	return _obj cmp other._obj; \
      } \
      bool  res = false; \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      if ( rb_respond_to( _obj, op_id ) == Qtrue ) \
	{ \
	  int status; \
	  OpArgs  args; \
          args.src    = _obj; \
	  args.id     = op_id; \
	  args.nargs  = 1; \
	  args.target = VALUE(other); \
	  ret = rb_protect( PROTECTFUNC(swig_protect_funcall), \
                            VALUE(&args), &status ); \
	} \
      if ( ret == Qnil ) { \
	VALUE a = rb_funcall(         _obj, hash_id, 0 ); \
	VALUE b = rb_funcall( VALUE(other), hash_id, 0 ); \
	res = a cmp b; \
      } \
      else \
	{ \
	  res = RTEST( ret ); \
	} \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return res; \
    }


    GC_VALUE_CMP( eq_id, operator==, ==, == 0 )
    GC_VALUE_CMP( lt_id, operator<,  < , <  0 )
    GC_VALUE_CMP( le_id, operator<=, <=, <= 0 )
    GC_VALUE_CMP( gt_id, operator>,  > , >  0 )
    GC_VALUE_CMP( ge_id, operator>=, >=, >= 0 )
#undef GC_VALUE_CMP

    bool operator!=( const GC_VALUE& other )
    {
      return !(this->operator==(other));
    }

#define GC_VALUE_UNARY( proc_id, op ) \
    GC_VALUE op() const \
    { \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      int status; \
      OpArgs  args; \
      args.src    = _obj; \
      args.id     = proc_id; \
      args.nargs  = 0; \
      args.target = Qnil; \
      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
			&status ); \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return ret; \
    }

    GC_VALUE_UNARY( pos_id, operator+ )
    GC_VALUE_UNARY( neg_id, operator- )
    GC_VALUE_UNARY( inv_id, operator~ )
#undef GC_VALUE_BINARY

#define GC_VALUE_BINARY( proc_id, op ) \
    GC_VALUE op( const GC_VALUE& other ) const \
    { \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      int status; \
      OpArgs  args; \
      args.src    = _obj; \
      args.id     = proc_id; \
      args.nargs  = 1; \
      args.target = VALUE(other); \
      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
			&status ); \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return GC_VALUE(ret); \
    }

    GC_VALUE_BINARY( add_id, operator+ );
    GC_VALUE_BINARY( sub_id, operator- );
    GC_VALUE_BINARY( mul_id, operator* );
    GC_VALUE_BINARY( div_id, operator/ );
    GC_VALUE_BINARY( mod_id, operator% );
    
    GC_VALUE_BINARY( and_id, operator& );
    GC_VALUE_BINARY( xor_id, operator^ );
    GC_VALUE_BINARY(  or_id, operator| );

    GC_VALUE_BINARY( lshift_id, operator<< );
    GC_VALUE_BINARY( rshift_id, operator>> );
#undef GC_VALUE_BINARY

  };

  ID  GC_VALUE::hash_id = rb_intern("hash");
  ID  GC_VALUE::lt_id = rb_intern("<");
  ID  GC_VALUE::gt_id = rb_intern(">");
  ID  GC_VALUE::eq_id = rb_intern("==");
  ID  GC_VALUE::le_id = rb_intern("<=");
  ID  GC_VALUE::ge_id = rb_intern(">=");

  ID  GC_VALUE::pos_id = rb_intern("+@");
  ID  GC_VALUE::neg_id = rb_intern("-@");
  ID  GC_VALUE::inv_id = rb_intern("~");

  ID  GC_VALUE::add_id = rb_intern("+");
  ID  GC_VALUE::sub_id = rb_intern("-");
  ID  GC_VALUE::mul_id = rb_intern("*");
  ID  GC_VALUE::div_id = rb_intern("/");
  ID  GC_VALUE::mod_id = rb_intern("%");

  ID  GC_VALUE::and_id = rb_intern("&");
  ID  GC_VALUE::or_id  = rb_intern("|");
  ID  GC_VALUE::xor_id = rb_intern("^");

  ID  GC_VALUE::lshift_id = rb_intern("<<");
  ID  GC_VALUE::rshift_id = rb_intern(">>");

  VALUE GC_VALUE::_hash = Qnil;

  typedef GC_VALUE LANGUAGE_OBJ;

} // namespace swig



#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>
#include <stdexcept>

  
namespace swig {
  struct stop_iteration {
  };

  /** 
   * Abstract base class used to represent all iterators of STL containers.
   */
  struct ConstIterator {
  public:
    typedef ConstIterator self_type;

  protected:
    GC_VALUE _seq;

  protected:
    ConstIterator(VALUE seq) : _seq(seq)
    {
    }

    // Random access iterator methods, but not required in Ruby
    virtual ptrdiff_t distance(const ConstIterator &x) const
    {
      throw std::invalid_argument("distance not supported");
    }

    virtual bool equal (const ConstIterator &x) const
    {
      throw std::invalid_argument("equal not supported");
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("advance not supported");
    }
      
  public:
    virtual ~ConstIterator() {}

    // Access iterator method, required by Ruby
    virtual VALUE value() const {
      throw std::invalid_argument("value not supported");
      return Qnil;
    };

    virtual VALUE setValue( const VALUE& v ) {
      throw std::invalid_argument("value= not supported");
      return Qnil;
    }

    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    virtual VALUE to_s() const {
      throw std::invalid_argument("to_s not supported");
      return Qnil;
    }

    virtual VALUE inspect() const {
      throw std::invalid_argument("inspect not supported");
      return Qnil;
    }
    
    virtual ConstIterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }

    //
    // C++ common/needed methods.  We emulate a bidirectional
    // operator, to be compatible with all the STL.
    // The iterator traits will then tell the STL what type of
    // iterator we really are.
    //
    ConstIterator() : _seq( Qnil )
    {
    }

    ConstIterator( const self_type& b ) : _seq( b._seq )
    {
    }

    self_type& operator=( const self_type& b )
    {
      _seq = b._seq;
      return *this;
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const ConstIterator& x) const
    {
      return ! operator==(x);
    }
      
    // Pre-decrement operator
    self_type& operator--()
    {
      return *previous();
    }

    // Pre-increment operator
    self_type& operator++()
    {
      return *next();
    }

    // Post-decrement operator
    self_type operator--(int)
    {
      self_type r = *this;
      previous();
      return r;
    }

    // Post-increment operator
    self_type operator++(int)
    {
      self_type r = *this;
      next();
      return r;
    }

    ConstIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    ConstIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }

    ConstIterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    ConstIterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const ConstIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::ConstIterator *");
	init = 1;
      }	
      return desc;
    }
  };


  /**
   * Abstract base class used to represent all non-const iterators of STL containers.
   * 
   */
  struct Iterator : public ConstIterator {
  public:
    typedef Iterator self_type;

  protected:
    Iterator(VALUE seq) : ConstIterator(seq)
    {
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("operation not supported");
    }

  public:
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::Iterator *");
	init = 1;
      }	
      return desc;
    }
    
    virtual Iterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }
      
    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const Iterator& x) const
    {
      return ! operator==(x);
    }
      
    Iterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    Iterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    Iterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    Iterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const Iterator& x) const
    {
      return x.distance(*this);
    }
  };

}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (VALUE obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}


/*@SWIG:/usr/local/share/swig/2.0.0/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (VALUE obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  (static_cast< long >(value));
}


#include <stdexcept>


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}



namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static VALUE from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static VALUE from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static VALUE from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static VALUE from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline VALUE from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline VALUE from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(VALUE obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(VALUE obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(VALUE obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(VALUE obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(VALUE obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(VALUE obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(VALUE obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	static Type *v_def = (Type*) malloc(sizeof(Type));
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(VALUE obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	return 0;
      }
    }
  };

  template <class Type>
  inline Type as(VALUE obj, bool te = false) {
    return traits_as< Type, typename traits< Type >::category >::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(VALUE obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(VALUE obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(VALUE obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


  namespace swig {
    template <>  struct traits<std::basic_string<char> > {
      typedef pointer_category category;
      static const char* type_name() { return"std::basic_string<char>"; }
    };
  }


#include <algorithm>


#include <string>


SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    #if defined(StringValuePtr)
    char *cstr = StringValuePtr(obj); 
    #else
    char *cstr = STR2CSTR(obj);
    #endif
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy((new char[size]), cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


namespace swig {
  template <> struct traits<char > {
    typedef value_category category;
    static const char* type_name() { return"char"; }
  };  
  template <>  struct traits_asval<char > {   
    typedef char value_type;
    static int asval(VALUE obj, value_type *val) { 
      return SWIG_AsVal_char (obj, val);
    }
  };
  template <>  struct traits_from<char > {
    typedef char value_type;
    static VALUE from(const value_type& val) {
      return SWIG_From_char  (val);
    }
  };
}





SWIGINTERN int
SWIG_AsPtr_std_basic_string_Sl_char_Sg_ (VALUE obj, std::string **val)
{
  static swig_type_info* string_info = 
    SWIG_TypeQuery("std::basic_string<char> *");
  std::string *vptr;    
  if (SWIG_ConvertPtr(obj, (void**)&vptr, string_info, 0) == SWIG_OK) {
    if (val) *val = vptr;
    return SWIG_OLDOBJ;
  } else {
    char* buf = 0 ; size_t size = 0; int alloc = 0;
    if (SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc) == SWIG_OK) {
      if (buf) {
	if (val) *val = new std::string(buf, size - 1);
	if (alloc == SWIG_NEWOBJ) delete[] buf;
	return SWIG_NEWOBJ;
      }
    }
    if (val) {
      rb_raise( rb_eTypeError, "a string is expected");
    }
    return 0;
  }
}  


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE VALUE
  SWIG_From_std_basic_string_Sl_char_Sg_  (const std::string& s)
  {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  }

SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg__dup(std::basic_string< char > *self){
      return new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(*self);
    }

#include <functional>


namespace swig {
  template < class T >
  struct yield : public std::unary_function< T, bool >
  {
    bool
    operator()( const T& v ) const
    { 
      return RTEST( rb_yield( swig::from< T >(v) ) );
    }
  };


  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {

  /** 
   * Templated base classes for all custom const_iterators.
   *
   */
  template<typename OutConstIterator>
  class ConstIterator_T :  public ConstIterator
  {
  public:
    typedef OutConstIterator const_iter;
    typedef typename std::iterator_traits<const_iter>::value_type value_type;    
    typedef ConstIterator_T<const_iter> self_type;

  protected:

    
    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:
    ConstIterator_T() : ConstIterator(Qnil)
    {
    }

    ConstIterator_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator(seq), current(curr)
    {
    }

    const const_iter& get_current() const
    {
      return current;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    const_iter current;
  };


  /** 
   * Templated base classes for all custom non-const iterators.
   *
   */
  template<typename InOutIterator>
  class Iterator_T :  public Iterator
  {
  public:
    typedef InOutIterator nonconst_iter;

    // Make this class iterator STL compatible, by using iterator_traits
    typedef typename std::iterator_traits<nonconst_iter >::iterator_category iterator_category;
    typedef typename std::iterator_traits<nonconst_iter >::value_type        value_type;
    typedef typename std::iterator_traits<nonconst_iter >::difference_type   difference_type;
    typedef typename std::iterator_traits<nonconst_iter >::pointer           pointer;
    typedef typename std::iterator_traits<nonconst_iter >::reference         reference;

    typedef Iterator                         base;
    typedef Iterator_T< nonconst_iter > self_type;

  protected:

    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:

    Iterator_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator(seq), current(curr)
    {
    }

    const nonconst_iter& get_current() const
    {
      return current;
    }

    self_type& operator=( const self_type& b )
    {
      base::operator=( b );
      return *this;
    }
    
    self_type& operator=( const value_type& b )
    {
      *current = b;
      return *this;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    value_type& operator*()
    {
      return *current;
    }
    
    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    nonconst_iter current;
  };


  /**
   * Auxiliary functor to store the value of a ruby object inside
   * a reference of a compatible C++ type.  ie: Ruby -> C++
   * 
   */
  template <class ValueType>
  struct asval_oper 
  {
    typedef ValueType    value_type;
    typedef bool        result_type;
    bool operator()(VALUE obj, value_type& v) const
    {
      return ( swig::asval< value_type >(obj, &v) == SWIG_OK );
    }
  };

  /**
   * Auxiliary functor to return a ruby object from a C++ type. 
   * ie: C++ -> Ruby
   * 
   */
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef VALUE result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };


  /** 
   * ConstIterator class for a const_iterator with no end() boundaries.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorOpen_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;
    typedef ConstIteratorOpen_T<OutConstIterator, ValueType, FromOper> self_type;
    
    ConstIteratorOpen_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * Iterator class for an iterator with no end() boundaries.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorOpen_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper  from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;

  public:
    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }

    virtual VALUE setValue( const VALUE& v )
    {
      value_type& dst = *base::current;
      if ( asval(v, dst) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * ConstIterator class for a const_iterator where begin() and end() boundaries are known.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorClosed_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;    
    typedef ConstIteratorClosed_T<OutConstIterator, ValueType, FromOper> self_type;
    
  protected:
    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    ConstIteratorClosed_T(const_iter curr, const_iter first, 
			  const_iter last, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }


  private:
    const_iter begin;
    const_iter end;
  };

  /** 
   * Iterator class for a iterator where begin() and end() boundaries are known.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorClosed_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    // Iterator setter method, required by Ruby
    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      value_type& dst = *base::current;
      if ( asval( v, dst ) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorOpen_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, bool, FromOper, AsvalOper> self_type;

    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }

    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    virtual VALUE setValue( const VALUE& v )
    {
      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }    
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
    
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorClosed_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, bool, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }

    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }

    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };


  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, const InOutIter& begin,
			 const InOutIter& end, VALUE seq = Qnil)
  {
    return new IteratorClosed_T<InOutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, VALUE seq = Qnil)
  {
    return new IteratorOpen_T<InOutIter>(current, seq);
  }

  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, const OutIter& begin,
                       const OutIter& end, VALUE seq = Qnil)
  {
    return new ConstIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, VALUE seq = Qnil)
  {
    return new ConstIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{

  /**
   * This class is a proxy class for references, used to return and set values
   * of an element of a Ruby Array of stuff.
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   * 
   */
  template <class T>
  struct RubySequence_Ref
  {
    RubySequence_Ref(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      VALUE item = rb_ary_entry(_seq, _index );
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	VALUE lastErr = rb_gv_get("$!");
	if ( lastErr == Qnil ) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	VALUE str = rb_str_new2(msg);
	str = rb_str_cat2( str, e.what() );
	SWIG_Ruby_ExceptionType( NULL, str );
	throw;
      }
    }

    RubySequence_Ref& operator=(const T& v)
    {
      rb_ary_set(_seq, _index, swig::from< T >(v));
      return *this;
    }

  private:
    VALUE  _seq;
    int _index;
  };


  /**
   * This class is a proxy to return a pointer to a class, usually
   * RubySequence_Ref. 
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   * 
   */
  template <class T>
  struct RubySequence_ArrowProxy
  {
    RubySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };


  /**
   * Input Iterator.  This adapator class is a random access iterator that 
   * allows you to use STL algorithms with a Ruby class (a Ruby Array by default).
   * 
   */
  template <class T, class Reference = RubySequence_Ref< T > >
  struct RubySequence_InputIterator
  {
    typedef RubySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef ptrdiff_t difference_type;

    RubySequence_InputIterator()
    {
    }

    RubySequence_InputIterator(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    RubySequence_ArrowProxy<T>
    operator->() const {
      return RubySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    VALUE  _seq;
    difference_type _index;
  };


  /**
   * This adaptor class allows you to use a Ruby Array as if it was an STL
   * container, giving it begin(), end(), and iterators.
   * 
   */
  template <class T>
  struct RubySequence_Cont
  {
    typedef RubySequence_Ref<T> reference;
    typedef const RubySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef RubySequence_InputIterator<T, reference> iterator;
    typedef RubySequence_InputIterator<T, const_reference> const_iterator;

    RubySequence_Cont(VALUE  seq) : _seq(0)
    {
      if (!rb_obj_is_kind_of(seq, rb_cArray)) {
	throw std::invalid_argument("an Array is expected");
      }
      _seq = seq;
    }

    ~RubySequence_Cont()
    {
    }

    size_type size() const
    {
      return RARRAY_LEN(_seq);
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = false) const
    {
      int s = (int) size();
      for (int i = 0; i < s; ++i) {
	VALUE item = rb_ary_entry(_seq, i );
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    VALUE  _seq;
  };

}

SWIGINTERN VALUE std_basic_string_Sl_char_Sg__inspect(std::basic_string< char > *self){
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator i = self->begin();
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::basic_string<char,std::char_traits< char >,std::allocator< char > > >();
      VALUE str = rb_str_new2(type_name);
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg__to_a(std::basic_string< char > *self){
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator i = self->begin();
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg__to_s(std::basic_string< char > *self){
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::iterator i = self->begin();
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg__slice(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::basic_string<char,std::char_traits< char >,std::allocator< char > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg__each(std::basic_string< char > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator i = self->begin();
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg__select(std::basic_string< char > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::basic_string<char,std::char_traits< char >,std::allocator< char > >* r = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >;
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator i = self->begin();
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg__reject_bang(std::basic_string< char > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::iterator i = self->begin();
      std::basic_string<char,std::char_traits< char >,std::allocator< char > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg__delete_at(std::basic_string< char > *self,std::basic_string< char >::difference_type i){
      VALUE r = Qnil;
      try {
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg____delete2__(std::basic_string< char > *self,std::basic_string< char >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN std::basic_string< char >::value_type const std_basic_string_Sl_char_Sg__push(std::basic_string< char > *self,std::basic_string< char >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg__reject(std::basic_string< char > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::basic_string<char,std::char_traits< char >,std::allocator< char > >* r = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg__at(std::basic_string< char > const *self,std::basic_string< char >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg____getitem____SWIG_0(std::basic_string< char > const *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::basic_string<char,std::char_traits< char >,std::allocator< char > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg____getitem____SWIG_1(std::basic_string< char > const *self,std::basic_string< char >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg____getitem____SWIG_2(std::basic_string< char > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg____setitem____SWIG_0(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::basic_string<char,std::char_traits< char >,std::allocator< char > >::value_type >( x );
      }
SWIGINTERN VALUE std_basic_string_Sl_char_Sg____setitem____SWIG_1(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::basic_string<char,std::char_traits< char >,std::allocator< char > >* >( &v );
      return r;
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____add__(std::basic_string< char > *self,std::basic_string< char > const &v){
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >* res = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(*self);
	*res += v;      
	return res;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____radd__(std::basic_string< char > *self,std::basic_string< char > const &v){
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >* res = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(v);
	*res += *self;      
	return res;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > std_basic_string_Sl_char_Sg____str__(std::basic_string< char > *self){
	return *self;
      }
SWIGINTERN std::basic_ostream< char,std::char_traits< char > > &std_basic_string_Sl_char_Sg____rlshift__(std::basic_string< char > *self,std::basic_ostream< char,std::char_traits< char > > &out){
	out << *self;
	return out;
      }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Se__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self == v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sg_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self > v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sl_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self < v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sg__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self >= v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sl__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self <= v;
  }

  int ASTNode_true(const ASTNode *node)
  {
    return 1;
  }


SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}

SWIGINTERN char *SBase___str__(SBase *self){
     return self->toSBML();
   }
SWIGINTERN int ListOf___len__(ListOf *self){
    return self->size();
  }
SWIGINTERN SBase *ListOf___getitem__(ListOf *self,int i){
     return self->get(fixNegativeIndex(i,self));
  }
SWIGINTERN void ListOf_each(ListOf *self){
     unsigned int i;
     for(i=0;i<self->size();i++){    
       rb_yield(SWIG_NewPointerObj(self->get(i),
       GetDowncastSwigType(self->get(i)), 0));
     }
  }

/*@SWIG:/usr/local/share/swig/2.0.0/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = NUM2DBL(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


  #define SWIG_From_double   rb_float_new 

SWIGINTERN ListWrapper< ASTNode > *ASTNode_getListOfNodes(ASTNode *self){
    List *list = self->getListOfNodes(ASTNode_true);
    return new ListWrapper<ASTNode>(list);
  }
SWIGINTERN void XMLOutputStream_writeAttributeBool__SWIG_0(XMLOutputStream *self,std::string const &name,bool const &value){
    self->writeAttribute(name, value);
  }
SWIGINTERN void XMLOutputStream_writeAttributeBool__SWIG_1(XMLOutputStream *self,XMLTriple const &name,bool const &value){
    self->writeAttribute(name, value);
  }
SWIGINTERN void RDFAnnotationParser_parseRDFAnnotation__SWIG_1(XMLNode const *annotation,ListWrapper< CVTerm > *CVTerms){
    if (!CVTerms) return;

    List *list = CVTerms->getList();
    RDFAnnotationParser::parseRDFAnnotation(annotation,list);
  }
swig_class SwigClassModelCreatorList;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ModelCreatorList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ModelCreatorList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListWrapperT_ModelCreator_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ModelCreatorList(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ModelCreator > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ListWrapper< ModelCreator > *)new ListWrapper< ModelCreator >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListWrapper_Sl_ModelCreator_Sg_(ListWrapper< ModelCreator > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ModelCreatorList_add(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ModelCreator > *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ModelCreator *","add", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  (arg1)->add(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreatorList_get(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModelCreator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ModelCreator > const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)((ListWrapper< ModelCreator > const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreatorList_prepend(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ModelCreator > *","prepend", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ModelCreator *","prepend", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  (arg1)->prepend(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreatorList_remove(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModelCreator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ModelCreator > *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreatorList_getSize(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ModelCreator > const *","getSize", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  result = (unsigned int)((ListWrapper< ModelCreator > const *)arg1)->getSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassDateList;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DateList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DateList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListWrapperT_Date_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DateList(int argc, VALUE *argv, VALUE self) {
  ListWrapper< Date > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ListWrapper< Date > *)new ListWrapper< Date >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListWrapper_Sl_Date_Sg_(ListWrapper< Date > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_DateList_add(int argc, VALUE *argv, VALUE self) {
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< Date > *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Date *","add", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  (arg1)->add(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateList_get(int argc, VALUE *argv, VALUE self) {
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Date *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< Date > const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)((ListWrapper< Date > const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateList_prepend(int argc, VALUE *argv, VALUE self) {
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< Date > *","prepend", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Date *","prepend", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  (arg1)->prepend(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateList_remove(int argc, VALUE *argv, VALUE self) {
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Date *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< Date > *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DateList_getSize(int argc, VALUE *argv, VALUE self) {
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< Date > const *","getSize", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  result = (unsigned int)((ListWrapper< Date > const *)arg1)->getSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassCVTermList;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CVTermList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CVTermList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListWrapperT_CVTerm_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CVTermList(int argc, VALUE *argv, VALUE self) {
  ListWrapper< CVTerm > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ListWrapper< CVTerm > *)new ListWrapper< CVTerm >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListWrapper_Sl_CVTerm_Sg_(ListWrapper< CVTerm > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_CVTermList_add(int argc, VALUE *argv, VALUE self) {
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< CVTerm > *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "CVTerm *","add", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  (arg1)->add(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTermList_get(int argc, VALUE *argv, VALUE self) {
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CVTerm *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< CVTerm > const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)((ListWrapper< CVTerm > const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTermList_prepend(int argc, VALUE *argv, VALUE self) {
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< CVTerm > *","prepend", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "CVTerm *","prepend", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  (arg1)->prepend(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTermList_remove(int argc, VALUE *argv, VALUE self) {
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CVTerm *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< CVTerm > *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTermList_getSize(int argc, VALUE *argv, VALUE self) {
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< CVTerm > const *","getSize", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  result = (unsigned int)((ListWrapper< CVTerm > const *)arg1)->getSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassASTNodeList;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ASTNodeList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ASTNodeList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListWrapperT_ASTNode_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ASTNodeList(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ASTNode > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ListWrapper< ASTNode > *)new ListWrapper< ASTNode >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListWrapper_Sl_ASTNode_Sg_(ListWrapper< ASTNode > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ASTNodeList_add(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ASTNode > *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode *","add", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  (arg1)->add(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNodeList_get(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ASTNode > const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((ListWrapper< ASTNode > const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNodeList_prepend(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ASTNode > *","prepend", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode *","prepend", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  (arg1)->prepend(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNodeList_remove(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ASTNode > *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNodeList_getSize(int argc, VALUE *argv, VALUE self) {
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< ASTNode > const *","getSize", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  result = (unsigned int)((ListWrapper< ASTNode > const *)arg1)->getSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLNamespacesList;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLNamespacesList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLNamespacesList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLNamespacesList(int argc, VALUE *argv, VALUE self) {
  ListWrapper< SBMLNamespaces > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ListWrapper< SBMLNamespaces > *)new ListWrapper< SBMLNamespaces >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListWrapper_Sl_SBMLNamespaces_Sg_(ListWrapper< SBMLNamespaces > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SBMLNamespacesList_add(int argc, VALUE *argv, VALUE self) {
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< SBMLNamespaces > *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLNamespaces *","add", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  (arg1)->add(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespacesList_get(int argc, VALUE *argv, VALUE self) {
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< SBMLNamespaces > const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)((ListWrapper< SBMLNamespaces > const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespacesList_prepend(int argc, VALUE *argv, VALUE self) {
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< SBMLNamespaces > *","prepend", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLNamespaces *","prepend", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  (arg1)->prepend(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespacesList_remove(int argc, VALUE *argv, VALUE self) {
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< SBMLNamespaces > *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespacesList_getSize(int argc, VALUE *argv, VALUE self) {
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListWrapper< SBMLNamespaces > const *","getSize", 1, self )); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  result = (unsigned int)((ListWrapper< SBMLNamespaces > const *)arg1)->getSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassGC_VALUE;


/*
  Document-method: LibSBML::GC_VALUE.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_GC_VALUE_inspect(int argc, VALUE *argv, VALUE self) {
  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::GC_VALUE const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::GC_VALUE * >(argp1);
  result = (VALUE)((swig::GC_VALUE const *)arg1)->inspect();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::GC_VALUE.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_GC_VALUE_to_s(int argc, VALUE *argv, VALUE self) {
  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::GC_VALUE const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::GC_VALUE * >(argp1);
  result = (VALUE)((swig::GC_VALUE const *)arg1)->to_s();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassConstIterator;

SWIGINTERN void
free_swig_ConstIterator(swig::ConstIterator *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ConstIterator_value(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","value", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  try {
    result = (VALUE)((swig::ConstIterator const *)arg1)->value();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ConstIterator.dup

  call-seq:
    dup -> ConstIterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->dup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ConstIterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (VALUE)((swig::ConstIterator const *)arg1)->inspect();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ConstIterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (VALUE)((swig::ConstIterator const *)arg1)->to_s();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::ConstIterator *)(arg1)->next(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  try {
    result = (swig::ConstIterator *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ConstIterator_next__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator_next__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.next", 
    "    swig::ConstIterator * ConstIterator.next(size_t n)\n"
    "    swig::ConstIterator * ConstIterator.next()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::ConstIterator *)(arg1)->previous(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  try {
    result = (swig::ConstIterator *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator_previous(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ConstIterator_previous__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator_previous__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.previous", 
    "    swig::ConstIterator * ConstIterator.previous(size_t n)\n"
    "    swig::ConstIterator * ConstIterator.previous()\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ConstIterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  swig::ConstIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  result = (bool)((swig::ConstIterator const *)arg1)->operator ==((swig::ConstIterator const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ConstIterator.+

  call-seq:
    +(n) -> ConstIterator

Add operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator +", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ConstIterator.-

  call-seq:
    -(n) -> ConstIterator
    -(x) -> ptrdiff_t

Substraction operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  swig::ConstIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  ptrdiff_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator -", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator -", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  result = ((swig::ConstIterator const *)arg1)->operator -((swig::ConstIterator const &)*arg2);
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ConstIterator___sub____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "__sub__.new", 
    "    __sub__.new(ptrdiff_t n)\n"
    "    __sub__.new(swig::ConstIterator const &x)\n");
  
  return Qnil;
}


swig_class SwigClassIterator;

SWIGINTERN VALUE
_wrap_Iterator_valuee___(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  VALUE *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE temp2 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  temp2 = static_cast< VALUE >(argv[0]);
  arg2 = &temp2;
  result = (VALUE)(arg1)->setValue((VALUE const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::Iterator.dup

  call-seq:
    dup -> Iterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_Iterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  result = (swig::Iterator *)((swig::Iterator const *)arg1)->dup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::Iterator *)(arg1)->next(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  try {
    result = (swig::Iterator *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Iterator_next__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator_next__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.next", 
    "    swig::Iterator * Iterator.next(size_t n)\n"
    "    swig::Iterator * Iterator.next()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::Iterator *)(arg1)->previous(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  try {
    result = (swig::Iterator *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator_previous(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Iterator_previous__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator_previous__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.previous", 
    "    swig::Iterator * Iterator.previous(size_t n)\n"
    "    swig::Iterator * Iterator.previous()\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Iterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_Iterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  result = (VALUE)((swig::Iterator const *)arg1)->inspect();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::Iterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_Iterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  result = (VALUE)((swig::Iterator const *)arg1)->to_s();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::Iterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  result = (bool)((swig::Iterator const *)arg1)->operator ==((swig::Iterator const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::Iterator.+

  call-seq:
    +(n) -> Iterator

Add operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator +", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::Iterator.-

  call-seq:
    -(n) -> Iterator
    -(x) -> ptrdiff_t

Substraction operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  ptrdiff_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator -", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator -", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  result = ((swig::Iterator const *)arg1)->operator -((swig::Iterator const &)*arg2);
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__Iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Iterator___sub____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "__sub__.new", 
    "    __sub__.new(ptrdiff_t n)\n"
    "    __sub__.new(swig::Iterator const &x)\n");
  
  return Qnil;
}


SWIGINTERN void
free_swig_Iterator(swig::Iterator *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassString;

SWIGINTERN VALUE
_wrap_string_npos_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_size_t(static_cast< size_t >(std::basic_string< char >::npos));
  return _val;
}


SWIGINTERN VALUE
_wrap_new_string__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","std::basic_string<(char)>", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","std::basic_string<(char)>", 2, argv[1] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = (std::basic_string< char > *)new std::basic_string< char >((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}



/*
  Document-method: LibSBML::string.length

  call-seq:
    length -> size_type

Size or Length of the string.
*/
SWIGINTERN VALUE
_wrap_string_length(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","length", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->length();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.max_size

  call-seq:
    max_size -> size_type

Maximum size of elements allowed in the string.
*/
SWIGINTERN VALUE
_wrap_string_max_size(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","max_size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->max_size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.assign

  call-seq:
    assign(str) -> string
    assign(str, pos, n) -> string
    assign(s, n) -> string
    assign(n, x)

Assign a new string or portion of it.
*/
SWIGINTERN VALUE
_wrap_string_assign__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","assign", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","assign", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->assign((std::basic_string< char > const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_assign__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","assign", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","assign", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","assign", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","assign", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = (std::basic_string< char > *) &(arg1)->assign((std::basic_string< char > const &)*arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_assign__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","assign", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","assign", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = (std::basic_string< char > *) &(arg1)->assign((char const *)arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}



/*
  Document-method: LibSBML::string.insert

  call-seq:
    insert(pos1, str) -> string
    insert(pos1, str, pos2, n) -> string
    insert(pos, s, n) -> string
    insert(pos, n, c) -> string
    insert(pos, x) -> iterator
    insert(pos, n, x)
    insert(p, n, c)

Insert one or more new elements in the string.
*/
SWIGINTERN VALUE
_wrap_string_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::basic_string< char > const &","insert", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","insert", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(std::basic_string< char > const &)*arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char > *arg3 = 0 ;
  std::basic_string< char >::size_type arg4 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::basic_string< char > const &","insert", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","insert", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_size_t(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 5, argv[3] ));
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(std::basic_string< char > const &)*arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  char *arg3 = (char *) 0 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","insert", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(char const *)arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_insert__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "char","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< char >(val4);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.erase

  call-seq:
    erase(pos=0, n=std::basic_string< char >::npos) -> string
    erase(pos=0) -> string
    erase -> string
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the string.
*/
SWIGINTERN VALUE
_wrap_string_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","erase", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","erase", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = (std::basic_string< char > *) &(arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","erase", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = (std::basic_string< char > *) &(arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char > *) &(arg1)->erase();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.replace

  call-seq:
    replace(pos, n, str) -> string
    replace(pos1, n1, str, pos2, n2) -> string
    replace(pos, n1, s, n2) -> string
    replace(pos, n1, n2, c) -> string
    replace(i1, i2, str) -> string
    replace(i1, i2, s, n) -> string
    replace(i1, i2, n, c) -> string
    replace(i1, i2, k1, k2) -> string
    replace(i1, i2, k1, k2) -> string

Replace all or a portion of the string.
*/
SWIGINTERN VALUE
_wrap_string_replace__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::basic_string< char > const &","replace", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","replace", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  std::basic_string< char >::size_type arg5 ;
  std::basic_string< char >::size_type arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  size_t val5 ;
  int ecode5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::basic_string< char > const &","replace", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","replace", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_size_t(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 5, argv[3] ));
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  ecode6 = SWIG_AsVal_size_t(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 6, argv[4] ));
  } 
  arg6 = static_cast< std::basic_string< char >::size_type >(val6);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4,arg5,arg6);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char *arg4 = (char *) 0 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","replace", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_size_t(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 5, argv[3] ));
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return vresult;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_char(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","replace", 5, argv[3] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_copy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","copy", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","copy", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","copy", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","copy", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->copy(arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_copy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","copy", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","copy", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","copy", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->copy(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_copy(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_copy__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_copy__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.copy", 
    "    std::basic_string< char >::size_type string.copy(char *__s, std::basic_string< char >::size_type __n, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.copy(char *__s, std::basic_string< char >::size_type __n)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.c_str

  call-seq:
    c_str -> char

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_string_c_str(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","c_str", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (char *)((std::basic_string< char > const *)arg1)->c_str();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.find

  call-seq:
    find(s, pos, n) -> size_type
    find(str, pos=0) -> size_type
    find(str) -> size_type
    find(c, pos=0) -> size_type
    find(c) -> size_type

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_string_find__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","find", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find((std::basic_string< char > const &)*arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find((std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find(arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_find(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.find", 
    "    std::basic_string< char >::size_type string.find(char const *__s, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::size_type string.find(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find(std::basic_string< char > const &__str)\n"
    "    std::basic_string< char >::size_type string.find(char __c, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find(char __c)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.rfind

  call-seq:
    rfind(str, pos=std::basic_string< char >::npos) -> size_type
    rfind(str) -> size_type
    rfind(s, pos, n) -> size_type
    rfind(c, pos=std::basic_string< char >::npos) -> size_type
    rfind(c) -> size_type

Find an element in reverse usually starting from the end of the string.
*/
SWIGINTERN VALUE
_wrap_string_rfind__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","rfind", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","rfind", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","rfind", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","rfind", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->rfind((std::basic_string< char > const &)*arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_rfind__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","rfind", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","rfind", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","rfind", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->rfind((std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_rfind__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","rfind", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","rfind", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","rfind", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","rfind", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->rfind((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_rfind__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","rfind", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","rfind", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","rfind", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->rfind(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_rfind__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","rfind", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","rfind", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->rfind(arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_rfind(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_rfind__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_rfind__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_rfind__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_rfind__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_rfind__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.rfind", 
    "    std::basic_string< char >::size_type string.rfind(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.rfind(std::basic_string< char > const &__str)\n"
    "    std::basic_string< char >::size_type string.rfind(char const *__s, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::size_type string.rfind(char __c, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.rfind(char __c)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_of__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_first_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_first_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_of((std::basic_string< char > const &)*arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_of__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_first_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_first_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_first_of((std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_of__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","find_first_of", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_of", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_first_of((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_of__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_first_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_of(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_of__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_first_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_first_of(arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_find_first_of(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_first_of__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_first_of__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_of__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_of__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_first_of__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.find_first_of", 
    "    std::basic_string< char >::size_type string.find_first_of(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_first_of(std::basic_string< char > const &__str)\n"
    "    std::basic_string< char >::size_type string.find_first_of(char const *__s, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::size_type string.find_first_of(char __c, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_first_of(char __c)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_of__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_last_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_last_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_of((std::basic_string< char > const &)*arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_of__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_last_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_last_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_last_of((std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_of__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","find_last_of", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_of", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_last_of((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_of__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_last_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_of(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_of__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_last_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_last_of(arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_find_last_of(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_last_of__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_last_of__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_of__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_of__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_last_of__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.find_last_of", 
    "    std::basic_string< char >::size_type string.find_last_of(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_last_of(std::basic_string< char > const &__str)\n"
    "    std::basic_string< char >::size_type string.find_last_of(char const *__s, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::size_type string.find_last_of(char __c, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_last_of(char __c)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_not_of__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_first_not_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_first_not_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_not_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((std::basic_string< char > const &)*arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_not_of__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_first_not_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_first_not_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_not_of__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","find_first_not_of", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_not_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_not_of", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_not_of__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_first_not_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_first_not_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_first_not_of__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_first_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_first_not_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of(arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_find_first_not_of(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_first_not_of__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_first_not_of__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_not_of__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_not_of__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_first_not_of__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.find_first_not_of", 
    "    std::basic_string< char >::size_type string.find_first_not_of(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_first_not_of(std::basic_string< char > const &__str)\n"
    "    std::basic_string< char >::size_type string.find_first_not_of(char const *__s, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::size_type string.find_first_not_of(char __c, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_first_not_of(char __c)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_not_of__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_last_not_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_last_not_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_not_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((std::basic_string< char > const &)*arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_not_of__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","find_last_not_of", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","find_last_not_of", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_not_of__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","find_last_not_of", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_not_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_not_of", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_not_of__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_last_not_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","find_last_not_of", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of(arg2,arg3);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_find_last_not_of__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","find_last_not_of", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","find_last_not_of", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of(arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_find_last_not_of(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_last_not_of__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_last_not_of__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_not_of__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_not_of__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_last_not_of__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.find_last_not_of", 
    "    std::basic_string< char >::size_type string.find_last_not_of(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_last_not_of(std::basic_string< char > const &__str)\n"
    "    std::basic_string< char >::size_type string.find_last_not_of(char const *__s, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::size_type string.find_last_not_of(char __c, std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::size_type string.find_last_not_of(char __c)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.substr

  call-seq:
    substr(pos=0, n=std::basic_string< char >::npos) -> string
    substr(pos=0) -> string
    substr -> string

Return a portion of the String.
*/
SWIGINTERN VALUE
_wrap_string_substr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::basic_string< char > result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","substr", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","substr", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","substr", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->substr(arg2,arg3);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_substr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  std::basic_string< char > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","substr", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","substr", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = ((std::basic_string< char > const *)arg1)->substr(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_substr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","substr", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->substr();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_substr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_string_substr__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_substr__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_substr__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "string.substr", 
    "    std::basic_string< char > string.substr(std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char > string.substr(std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char > string.substr()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_string__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::basic_string< char > *)new std::basic_string< char >();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_string__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  std::basic_string< char > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const &","std::basic_string<(char)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","std::basic_string<(char)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::basic_string< char > *)new std::basic_string< char >((std::basic_string< char > const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}



/*
  Document-method: LibSBML::string.empty

  call-seq:
    empty -> bool

Check if the string is empty or not.
*/
SWIGINTERN VALUE
_wrap_string_empty(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)((std::basic_string< char > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.size

  call-seq:
    size -> size_type

Size or Length of the string.
*/
SWIGINTERN VALUE
_wrap_string_size(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_swap(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::basic_string< char > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the string.
*/
SWIGINTERN VALUE
_wrap_string_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  (arg1)->resize(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.erase

  call-seq:
    erase(pos=0, n=std::basic_string< char >::npos) -> string
    erase(pos=0) -> string
    erase -> string
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the string.
*/
SWIGINTERN VALUE
_wrap_string_erase__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::basic_string< char >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::basic_string< char >::iterator * >(argp2));
    }
  }
  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_erase__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  std::basic_string< char >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::basic_string< char >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::basic_string< char >::iterator * >(argp3));
    }
  }
  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_string_erase__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_erase__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string_erase__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_erase__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "string.erase", 
    "    std::basic_string< char >::iterator string.erase(std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char >::iterator string.erase(std::basic_string< char >::size_type __pos)\n"
    "    std::basic_string< char >::iterator string.erase()\n"
    "    std::basic_string< char >::iterator string.erase(std::basic_string< char >::iterator pos)\n"
    "    std::basic_string< char >::iterator string.erase(std::basic_string< char >::iterator first, std::basic_string< char >::iterator last)\n");
  
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_string_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_string_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_string__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char >::size_type arg1 ;
  std::basic_string< char >::value_type arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","std::basic_string<(char)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::basic_string< char >::size_type >(val1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","std::basic_string<(char)>", 2, argv[1] ));
  } 
  arg2 = static_cast< std::basic_string< char >::value_type >(val2);
  result = (std::basic_string< char > *)new std::basic_string< char >(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_string(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_string__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_string__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_string__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_string__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "string.new", 
    "    string.new(char const *__s, std::basic_string< char >::size_type __n)\n"
    "    string.new()\n"
    "    string.new(std::basic_string< char > const &)\n"
    "    string.new(std::basic_string< char >::size_type size, std::basic_string< char >::value_type value)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.assign

  call-seq:
    assign(str) -> string
    assign(str, pos, n) -> string
    assign(s, n) -> string
    assign(n, x)

Assign a new string or portion of it.
*/
SWIGINTERN VALUE
_wrap_string_assign__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","assign", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","assign", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  (arg1)->assign(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_assign(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_assign__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_assign__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_assign__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_assign__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "string.assign", 
    "    void string.assign(std::basic_string< char > const &__str)\n"
    "    void string.assign(std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n)\n"
    "    void string.assign(char const *__s, std::basic_string< char >::size_type __n)\n"
    "    void string.assign(std::basic_string< char >::size_type n, std::basic_string< char >::value_type x)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the string.
*/
SWIGINTERN VALUE
_wrap_string_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","resize", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  (arg1)->resize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_resize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_resize__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_resize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "string.resize", 
    "    void string.resize(std::basic_string< char >::size_type new_size)\n"
    "    void string.resize(std::basic_string< char >::size_type new_size, std::basic_string< char >::value_type x)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.insert

  call-seq:
    insert(pos1, str) -> string
    insert(pos1, str, pos2, n) -> string
    insert(pos, s, n) -> string
    insert(pos, n, c) -> string
    insert(pos, x) -> iterator
    insert(pos, n, x)
    insert(p, n, c)

Insert one or more new elements in the string.
*/
SWIGINTERN VALUE
_wrap_string_insert__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  std::basic_string< char >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","insert", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char >::iterator","insert", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::basic_string< char >::iterator * >(argp2));
    }
  }
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  result = (arg1)->insert(arg2,arg3);
  vresult = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_insert__SWIG_5(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::value_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","insert", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char >::iterator","insert", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::basic_string< char >::iterator * >(argp2));
    }
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::value_type >(val4);
  (arg1)->insert(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.dup

  call-seq:
    dup -> string

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_string_dup(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_string_inspect(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (VALUE)std_basic_string_Sl_char_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.to_a

  call-seq:
    to_a -> VALUE

Convert string to an Array.
*/
SWIGINTERN VALUE
_wrap_string_to_a(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (VALUE)std_basic_string_Sl_char_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_string_to_s(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (VALUE)std_basic_string_Sl_char_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the string.
*/
SWIGINTERN VALUE
_wrap_string_slice(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","slice", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","slice", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","slice", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  result = (VALUE)std_basic_string_Sl_char_Sg__slice(arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.each

  call-seq:
    each -> string

Iterate thru each element in the string.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_string_each(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.select

  call-seq:
    select -> string

Iterate thru each element in the string and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_string_select(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.reject_bang

  call-seq:
    reject_bang -> string

Iterate thru each element in the string and reject those that fail a condition.  A block must be provided.  string is modified in place.
*/
SWIGINTERN VALUE
_wrap_string_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","reject_bang", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE
_wrap_string_delete_at(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","delete_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","delete_at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  result = (VALUE)std_basic_string_Sl_char_Sg__delete_at(arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___delete2__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char >::value_type temp2 ;
  char val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__delete2__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","__delete2__", 2, argv[0] ));
  } 
  temp2 = static_cast< std::basic_string< char >::value_type >(val2);
  arg2 = &temp2;
  result = (VALUE)std_basic_string_Sl_char_Sg____delete2__(arg1,(char const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the string.
*/
SWIGINTERN VALUE
_wrap_string_push(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char >::value_type temp2 ;
  char val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::value_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","push", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","push", 2, argv[0] ));
  } 
  temp2 = static_cast< std::basic_string< char >::value_type >(val2);
  arg2 = &temp2;
  result = (std::basic_string< char >::value_type)std_basic_string_Sl_char_Sg__push(arg1,(char const &)*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.reject

  call-seq:
    reject -> string

Iterate thru each element in the string and reject those that fail a condition returning a new string.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_string_reject(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","reject", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE
_wrap_string_at(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  result = (VALUE)std_basic_string_Sl_char_Sg__at((std::basic_string< char > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_string___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","__getitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  result = (VALUE)std_basic_string_Sl_char_Sg____getitem____SWIG_0((std::basic_string< char > const *)arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  result = (VALUE)std_basic_string_Sl_char_Sg____getitem____SWIG_1((std::basic_string< char > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  VALUE arg2 = (VALUE) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  arg2 = argv[0];
  result = (VALUE)std_basic_string_Sl_char_Sg____getitem____SWIG_2((std::basic_string< char > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string___getitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string___getitem____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_string___getitem____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string___getitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
    "    VALUE __getitem__(std::basic_string< char >::difference_type i, std::basic_string< char >::difference_type j)\n"
    "    VALUE __getitem__(std::basic_string< char >::difference_type i)\n"
    "    VALUE __getitem__(VALUE i)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_string___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  std::basic_string< char >::value_type temp3 ;
  char val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::value_type","__setitem__", 3, argv[1] ));
  } 
  temp3 = static_cast< std::basic_string< char >::value_type >(val3);
  arg3 = &temp3;
  result = (VALUE)std_basic_string_Sl_char_Sg____setitem____SWIG_0(arg1,arg2,(char const &)*arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::difference_type","__setitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &","__setitem__", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &","__setitem__", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  try {
    result = (VALUE)std_basic_string_Sl_char_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg4);
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_string___setitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string___setitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string___setitem____SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
    "    VALUE __setitem__(std::basic_string< char >::difference_type i, std::basic_string< char >::value_type const &x)\n"
    "    VALUE __setitem__(std::basic_string< char >::difference_type i, std::basic_string< char >::difference_type j, std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &v)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.insert

  call-seq:
    insert(pos1, str) -> string
    insert(pos1, str, pos2, n) -> string
    insert(pos, s, n) -> string
    insert(pos, n, c) -> string
    insert(pos, x) -> iterator
    insert(pos, n, x)
    insert(p, n, c)

Insert one or more new elements in the string.
*/
SWIGINTERN VALUE
_wrap_string_insert__SWIG_6(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","insert", 2, argv[0] ));
    }
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "char","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< char >(val4);
  (arg1)->insert(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_insert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_insert__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string_insert__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_6(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_3(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_insert__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "string.insert", 
    "    void string.insert(std::basic_string< char >::size_type __pos1, std::basic_string< char > const &__str)\n"
    "    void string.insert(std::basic_string< char >::size_type __pos1, std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos2, std::basic_string< char >::size_type __n)\n"
    "    void string.insert(std::basic_string< char >::size_type __pos, char const *__s, std::basic_string< char >::size_type __n)\n"
    "    void string.insert(std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n, char __c)\n"
    "    void string.insert(std::basic_string< char >::iterator pos, std::basic_string< char >::value_type x)\n"
    "    void string.insert(std::basic_string< char >::iterator pos, std::basic_string< char >::size_type n, std::basic_string< char >::value_type x)\n"
    "    void string.insert(std::basic_string< char >::iterator __p, std::basic_string< char >::size_type __n, char __c)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::string.replace

  call-seq:
    replace(pos, n, str) -> string
    replace(pos1, n1, str, pos2, n2) -> string
    replace(pos, n1, s, n2) -> string
    replace(pos, n1, n2, c) -> string
    replace(i1, i2, str) -> string
    replace(i1, i2, s, n) -> string
    replace(i1, i2, n, c) -> string
    replace(i1, i2, k1, k2) -> string
    replace(i1, i2, k1, k2) -> string

Replace all or a portion of the string.
*/
SWIGINTERN VALUE
_wrap_string_replace__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  int res4 = SWIG_OLDOBJ ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
    }
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::basic_string< char > const &","replace", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","replace", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_5(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  char *arg4 = (char *) 0 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
    }
  }
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","replace", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_size_t(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 5, argv[3] ));
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return vresult;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_6(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char >::size_type arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  size_t val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
    }
  }
  ecode4 = SWIG_AsVal_size_t(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::basic_string< char >::size_type","replace", 4, argv[2] ));
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_char(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","replace", 5, argv[3] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_7(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
    }
  }
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","replace", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_AsCharPtrAndSize(argv[3], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "char const *","replace", 5, argv[3] ));
  }
  arg5 = reinterpret_cast< char * >(buf5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,(char const *)arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return vresult;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string_replace__SWIG_8(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char >::const_iterator arg4 ;
  std::basic_string< char >::const_iterator arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  swig::ConstIterator *iter4 = 0 ;
  int res4 ;
  swig::ConstIterator *iter5 = 0 ;
  int res5 ;
  std::basic_string< char > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","replace", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::iterator","replace", 3, argv[1] ));
    }
  }
  res4 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter4),
    swig::ConstIterator::descriptor(), 0);
  if (!SWIG_IsOK(res4) || !iter4) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::const_iterator","replace", 4, argv[2] ));
  } else {
    swig::ConstIterator_T<std::basic_string< char >::const_iterator > *iter_t = dynamic_cast<swig::ConstIterator_T<std::basic_string< char >::const_iterator > *>(iter4);
    if (iter_t) {
      arg4 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::const_iterator","replace", 4, argv[2] ));
    }
  }
  res5 = SWIG_ConvertPtr(argv[3], SWIG_as_voidptrptr(&iter5),
    swig::ConstIterator::descriptor(), 0);
  if (!SWIG_IsOK(res5) || !iter5) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::const_iterator","replace", 5, argv[3] ));
  } else {
    swig::ConstIterator_T<std::basic_string< char >::const_iterator > *iter_t = dynamic_cast<swig::ConstIterator_T<std::basic_string< char >::const_iterator > *>(iter5);
    if (iter_t) {
      arg5 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::basic_string< char >::const_iterator","replace", 5, argv[3] ));
    }
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_string_replace(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string_replace__SWIG_4(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string_replace__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          swig::ConstIterator *iter = 0;
          int res = SWIG_ConvertPtr(argv[3], SWIG_as_voidptrptr(&iter), 
            swig::ConstIterator::descriptor(), 0);
          _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::ConstIterator_T<std::basic_string< char >::const_iterator > *>(iter) != 0));
          if (_v) {
            swig::ConstIterator *iter = 0;
            int res = SWIG_ConvertPtr(argv[4], SWIG_as_voidptrptr(&iter), 
              swig::ConstIterator::descriptor(), 0);
            _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::ConstIterator_T<std::basic_string< char >::const_iterator > *>(iter) != 0));
            if (_v) {
              return _wrap_string_replace__SWIG_8(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_6(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_5(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsCharPtrAndSize(argv[4], 0, NULL, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_string_replace__SWIG_7(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_2(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_size_t(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_string_replace__SWIG_1(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "string.replace", 
    "    std::basic_string< char > & string.replace(std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n, std::basic_string< char > const &__str)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::size_type __pos1, std::basic_string< char >::size_type __n1, std::basic_string< char > const &__str, std::basic_string< char >::size_type __pos2, std::basic_string< char >::size_type __n2)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n1, char const *__s, std::basic_string< char >::size_type __n2)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::size_type __pos, std::basic_string< char >::size_type __n1, std::basic_string< char >::size_type __n2, char __c)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::iterator __i1, std::basic_string< char >::iterator __i2, std::basic_string< char > const &__str)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::iterator __i1, std::basic_string< char >::iterator __i2, char const *__s, std::basic_string< char >::size_type __n)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::iterator __i1, std::basic_string< char >::iterator __i2, std::basic_string< char >::size_type __n, char __c)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::iterator __i1, std::basic_string< char >::iterator __i2, char const *__k1, char const *__k2)\n"
    "    std::basic_string< char > & string.replace(std::basic_string< char >::iterator __i1, std::basic_string< char >::iterator __i2, std::basic_string< char >::const_iterator __k1, std::basic_string< char >::const_iterator __k2)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___add__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__add__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","__add__", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","__add__", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____add__(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___radd__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__radd__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","__radd__", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","__radd__", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____radd__(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___str__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = std_basic_string_Sl_char_Sg____str__(arg1);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_string___rlshift__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_ostream< char,std::char_traits< char > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","__rlshift__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_ostream< char,std::char_traits< char > > &","__rlshift__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_ostream< char,std::char_traits< char > > &","__rlshift__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp2);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std_basic_string_Sl_char_Sg____rlshift__(arg1,*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::string.==

  call-seq:
    ==(v) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_string___eq__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","operator ==", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","operator ==", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Se__Se_(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}



/*
  Document-method: LibSBML::string.>

  call-seq:
    >(v) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_string___gt__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","operator >", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","operator >", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sg_(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}



/*
  Document-method: LibSBML::string.<

  call-seq:
    <(v) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_string___lt__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","operator <", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","operator <", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sl_(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}



/*
  Document-method: LibSBML::string.>=

  call-seq:
    >=(v) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_string___ge__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","operator >=", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","operator >=", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sg__Se_(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}



/*
  Document-method: LibSBML::string.<=

  call-seq:
    <=(v) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_string___le__(int argc, VALUE *argv, VALUE self) {
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_string< char > *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char > const &","operator <=", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char > const &","operator <=", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sl__Se_(arg1,(std::basic_string< char > const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_std_basic_string_Sl_char_Sg_(std::basic_string< char > *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassOstream;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Ostream_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Ostream_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Ostream(int argc, VALUE *argv, VALUE self) {
  std::basic_streambuf< char,std::char_traits< char > > *arg1 = (std::basic_streambuf< char,std::char_traits< char > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_ostream< char > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__basic_streambufT_char_std__char_traitsT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_streambuf< char,std::char_traits< char > > *","std::basic_ostream<(char)>", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< std::basic_streambuf< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char > *)new std::basic_ostream< char >(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_basic_ostream_Sl_char_Sg_(std::basic_ostream< char > *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassOstringstream;

SWIGINTERN VALUE
_wrap_new_Ostringstream__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::ios_base::openmode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  std::basic_ostringstream< char > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ios_base__openmode,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ios_base::openmode","std::basic_ostringstream<(char)>", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ios_base::openmode","std::basic_ostringstream<(char)>", 1, argv[0]));
    } else {
      arg1 = *(reinterpret_cast< std::ios_base::openmode * >(argp1));
    }
  }
  result = (std::basic_ostringstream< char > *)new std::basic_ostringstream< char >(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Ostringstream_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Ostringstream_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Ostringstream__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_ostringstream< char > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::basic_ostringstream< char > *)new std::basic_ostringstream< char >();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Ostringstream(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Ostringstream__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ios_base__openmode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Ostringstream__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "Ostringstream.new", 
    "    Ostringstream.new(std::ios_base::openmode __mode)\n"
    "    Ostringstream.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_std_basic_ostringstream_Sl_char_Sg_(std::basic_ostringstream< char > *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_Ostringstream_str__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_ostringstream< char > const *","str", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  result = ((std::basic_ostringstream< char > const *)arg1)->str();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Ostringstream_str__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_ostringstream< char > *","str", 1, self )); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &","str", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &","str", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->str((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Ostringstream_str(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Ostringstream_str__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Ostringstream_str__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Ostringstream.str", 
    "    void Ostringstream.str()\n"
    "    void Ostringstream.str(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &__s)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_endl(int argc, VALUE *argv, VALUE self) {
  std::basic_ostream< char,std::char_traits< char > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_ostream< char,std::char_traits< char > > &","std::endl<(char,std::char_traits<(char)>)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_ostream< char,std::char_traits< char > > &","std::endl<(char,std::char_traits<(char)>)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std::SWIGTEMPLATEDISAMBIGUATOR endl< char,std::char_traits< char > >(*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_flush(int argc, VALUE *argv, VALUE self) {
  std::basic_ostream< char,std::char_traits< char > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::basic_ostream< char,std::char_traits< char > > &","std::flush<(char,std::char_traits<(char)>)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::basic_ostream< char,std::char_traits< char > > &","std::flush<(char,std::char_traits<(char)>)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std::SWIGTEMPLATEDISAMBIGUATOR flush< char,std::char_traits< char > >(*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cout_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&std::cout), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_cerr_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&std::cerr), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_clog_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&std::clog), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_ASTNode_true(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","ASTNode_true", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)ASTNode_true((ASTNode const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getLibSBMLVersion(int argc, VALUE *argv, VALUE self) {
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (int)getLibSBMLVersion();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getLibSBMLDottedVersion(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)getLibSBMLDottedVersion();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_getLibSBMLVersionString(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)getLibSBMLVersionString();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLReader;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLReader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLReader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLReader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLReader(int argc, VALUE *argv, VALUE self) {
  SBMLReader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLReader *)new SBMLReader();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBMLReader(SBMLReader *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SBMLReader_readSBML(int argc, VALUE *argv, VALUE self) {
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLReader *","readSBML", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","readSBML", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","readSBML", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBML((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLReader_readSBMLFromFile(int argc, VALUE *argv, VALUE self) {
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLReader *","readSBMLFromFile", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","readSBMLFromFile", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","readSBMLFromFile", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBMLFromFile((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLReader_readSBMLFromString(int argc, VALUE *argv, VALUE self) {
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLReader *","readSBMLFromString", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","readSBMLFromString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","readSBMLFromString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBMLFromString((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLReader_hasZlib(int argc, VALUE *argv, VALUE self) {
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (bool)SBMLReader::hasZlib();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLReader_hasBzip2(int argc, VALUE *argv, VALUE self) {
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (bool)SBMLReader::hasBzip2();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_readSBML(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  SBMLDocument_t *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","readSBML", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBML((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_readSBMLFromFile(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  SBMLDocument_t *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","readSBMLFromFile", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBMLFromFile((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_readSBMLFromString(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  SBMLDocument_t *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","readSBMLFromString", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBMLFromString((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


swig_class SwigClassSBMLWriter;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLWriter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLWriter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLWriter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLWriter(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLWriter *)new SBMLWriter();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBMLWriter(SBMLWriter *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SBMLWriter_setProgramName(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","setProgramName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setProgramName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setProgramName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setProgramName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_setProgramVersion(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","setProgramVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setProgramVersion", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setProgramVersion", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setProgramVersion((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_writeSBML__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","writeSBML", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLDocument const *","writeSBML", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeSBML", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeSBML", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->writeSBML((SBMLDocument const *)arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_writeSBML__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::ostream *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","writeSBML", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLDocument const *","writeSBML", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::ostream &","writeSBML", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","writeSBML", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (bool)(arg1)->writeSBML((SBMLDocument const *)arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLWriter_writeSBML(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLWriter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLDocument, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBMLWriter_writeSBML__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLWriter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLDocument, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBMLWriter_writeSBML__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SBMLWriter.writeSBML", 
    "    bool SBMLWriter.writeSBML(SBMLDocument const *d, std::string const &filename)\n"
    "    bool SBMLWriter.writeSBML(SBMLDocument const *d, std::ostream &stream)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_writeToString(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","writeToString", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLDocument const *","writeToString", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  result = (char *)(arg1)->writeToString((SBMLDocument const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  free(result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_writeSBMLToFile(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","writeSBMLToFile", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLDocument const *","writeSBMLToFile", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeSBMLToFile", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeSBMLToFile", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->writeSBMLToFile((SBMLDocument const *)arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_writeSBMLToString(int argc, VALUE *argv, VALUE self) {
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLWriter *","writeSBMLToString", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLDocument const *","writeSBMLToString", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  result = (char *)(arg1)->writeSBMLToString((SBMLDocument const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  free(result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_hasZlib(int argc, VALUE *argv, VALUE self) {
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (bool)SBMLWriter::hasZlib();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLWriter_hasBzip2(int argc, VALUE *argv, VALUE self) {
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (bool)SBMLWriter::hasBzip2();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_writeSBML(int argc, VALUE *argv, VALUE self) {
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument_t const *","writeSBML", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","writeSBML", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)writeSBML((SBMLDocument const *)arg1,(char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_writeSBMLToString(int argc, VALUE *argv, VALUE self) {
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument_t const *","writeSBMLToString", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  result = (char *)writeSBMLToString((SBMLDocument const *)arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  free(result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_writeSBMLToFile(int argc, VALUE *argv, VALUE self) {
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument_t const *","writeSBMLToFile", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","writeSBMLToFile", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)writeSBMLToFile((SBMLDocument const *)arg1,(char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLTypeCode_toString(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","SBMLTypeCode_toString", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SBMLTypeCode_toString", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)SBMLTypeCode_toString(arg1,(char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


swig_class SwigClassSBMLConstructorException;

SWIGINTERN VALUE
_wrap_new_SBMLConstructorException__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  SBMLConstructorException *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SBMLConstructorException", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (SBMLConstructorException *)new SBMLConstructorException(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLConstructorException_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLConstructorException_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLConstructorException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLConstructorException__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLConstructorException *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLConstructorException *)new SBMLConstructorException();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SBMLConstructorException(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SBMLConstructorException__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLConstructorException__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SBMLConstructorException.new", 
    "    SBMLConstructorException.new(std::string errmsg)\n"
    "    SBMLConstructorException.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_SBMLConstructorException(SBMLConstructorException *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SBMLConstructorException_getSBMLErrMsg(int argc, VALUE *argv, VALUE self) {
  SBMLConstructorException *arg1 = (SBMLConstructorException *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLConstructorException, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLConstructorException const *","getSBMLErrMsg", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLConstructorException * >(argp1);
  result = (std::string *) &((SBMLConstructorException const *)arg1)->getSBMLErrMsg();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBase;

SWIGINTERN void
free_SBase(SBase *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/*
  Document-method: LibSBML::SBase.clone

  call-seq:
    clone -> SBase

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBase_clone(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBase *)((SBase const *)arg1)->clone();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getMetaId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getMetaId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getMetaId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getName(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getNotes(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)(arg1)->getNotes();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getNotesString(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getNotesString", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (arg1)->getNotesString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getAnnotation(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)(arg1)->getAnnotation();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getAnnotationString(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getAnnotationString", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (arg1)->getAnnotationString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getNamespaces(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNamespaces *)((SBase const *)arg1)->getNamespaces();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getSBMLDocument__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getSBMLDocument", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLDocument *)((SBase const *)arg1)->getSBMLDocument();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getSBMLDocument__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getSBMLDocument", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLDocument *)(arg1)->getSBMLDocument();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_getSBMLDocument(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getSBMLDocument__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getSBMLDocument__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBase.getSBMLDocument", 
    "    SBMLDocument * SBase.getSBMLDocument()\n"
    "    SBMLDocument * SBase.getSBMLDocument()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getParentSBMLObject(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getParentSBMLObject", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBase *)(arg1)->getParentSBMLObject();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getAncestorOfType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  int arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getAncestorOfType", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAncestorOfType", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getAncestorOfType", 3, argv[1] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (SBase *)(arg1)->getAncestorOfType(arg2,arg3);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getAncestorOfType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getAncestorOfType", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAncestorOfType", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (SBase *)(arg1)->getAncestorOfType(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_getAncestorOfType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SBase_getAncestorOfType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBase_getAncestorOfType__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SBase.getAncestorOfType", 
    "    SBase * SBase.getAncestorOfType(int type, std::string const pkgName)\n"
    "    SBase * SBase.getAncestorOfType(int type)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getSBOTerm(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getSBOTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)((SBase const *)arg1)->getSBOTerm();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getSBOTermID(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getSBOTermID", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = ((SBase const *)arg1)->getSBOTermID();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getLine(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getLine", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getLine();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getColumn(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getColumn", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getColumn();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getModelHistory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelHistory *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getModelHistory", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (ModelHistory *)((SBase const *)arg1)->getModelHistory();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getModelHistory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelHistory *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getModelHistory", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (ModelHistory *)(arg1)->getModelHistory();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_getModelHistory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getModelHistory__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getModelHistory__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBase.getModelHistory", 
    "    ModelHistory * SBase.getModelHistory()\n"
    "    ModelHistory * SBase.getModelHistory()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetMetaId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isSetMetaId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetMetaId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetName(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetNotes(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isSetNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetNotes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetAnnotation(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isSetAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetAnnotation();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetSBOTerm(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isSetSBOTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetSBOTerm();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setMetaId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setMetaId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setMetaId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setMetaId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setMetaId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isSetModelHistory(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","isSetModelHistory", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)(arg1)->isSetModelHistory();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setName(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","setAnnotation", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setAnnotation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setAnnotation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_setAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setAnnotation__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBase.setAnnotation", 
    "    int SBase.setAnnotation(XMLNode const *annotation)\n"
    "    int SBase.setAnnotation(std::string const &annotation)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_appendAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","appendAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","appendAnnotation", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_appendAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","appendAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","appendAnnotation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","appendAnnotation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_appendAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendAnnotation__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBase.appendAnnotation", 
    "    int SBase.appendAnnotation(XMLNode const *annotation)\n"
    "    int SBase.appendAnnotation(std::string const &annotation)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setNotes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","setNotes", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setNotes((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setNotes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setNotes", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setNotes", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setNotes((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_setNotes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setNotes__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setNotes__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBase.setNotes", 
    "    int SBase.setNotes(XMLNode const *notes)\n"
    "    int SBase.setNotes(std::string const &notes)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_appendNotes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","appendNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","appendNotes", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendNotes((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_appendNotes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","appendNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","appendNotes", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","appendNotes", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendNotes((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_appendNotes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendNotes__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendNotes__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBase.appendNotes", 
    "    int SBase.appendNotes(XMLNode const *notes)\n"
    "    int SBase.appendNotes(std::string const &notes)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setModelHistory(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  ModelHistory *arg2 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setModelHistory", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ModelHistory *","setModelHistory", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ModelHistory * >(argp2);
  result = (int)(arg1)->setModelHistory(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_connectToParent(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","connectToParent", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBase *","connectToParent", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  (arg1)->connectToParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_connectToChild(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setSBOTerm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setSBOTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setSBOTerm", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setSBOTerm(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setSBOTerm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setSBOTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSBOTerm", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSBOTerm", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSBOTerm((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_setSBOTerm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SBase_setSBOTerm__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setSBOTerm__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBase.setSBOTerm", 
    "    int SBase.setSBOTerm(int value)\n"
    "    int SBase.setSBOTerm(std::string const &sboid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setNamespaces(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNamespaces *","setNamespaces", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->setNamespaces(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetMetaId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetMetaId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetMetaId();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetId(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetId", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetId();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetName(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetNotes(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetNotes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetNotes();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetAnnotation(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetAnnotation();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetSBOTerm(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetSBOTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetSBOTerm();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_addCVTerm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","addCVTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "CVTerm *","addCVTerm", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","addCVTerm", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (int)(arg1)->addCVTerm(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_addCVTerm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","addCVTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "CVTerm *","addCVTerm", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  result = (int)(arg1)->addCVTerm(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_addCVTerm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CVTerm, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_addCVTerm__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CVTerm, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBase_addCVTerm__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SBase.addCVTerm", 
    "    int SBase.addCVTerm(CVTerm *term, bool newBag)\n"
    "    int SBase.addCVTerm(CVTerm *term)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getCVTerms__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  List *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getCVTerms", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (List *)(arg1)->getCVTerms();
  {
    ListWrapper<CVTerm> *listw = (result != 0)? new ListWrapper<CVTerm>(result) : 0;
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_CVTerm_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getCVTerms__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  List *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getCVTerms", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (List *)((SBase const *)arg1)->getCVTerms();
  {
    ListWrapper<CVTerm> *listw = (result != 0)? new ListWrapper<CVTerm>(result) : 0;
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_CVTerm_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_getCVTerms(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getCVTerms__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getCVTerms__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBase.getCVTerms", 
    "    List * SBase.getCVTerms()\n"
    "    List * SBase.getCVTerms()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getNumCVTerms(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getNumCVTerms", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)(arg1)->getNumCVTerms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getCVTerm(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CVTerm *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getCVTerm", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getCVTerm", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)(arg1)->getCVTerm(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetCVTerms(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetCVTerms", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetCVTerms();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_unsetModelHistory(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","unsetModelHistory", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetModelHistory();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getResourceBiologicalQualifier(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BiolQualifierType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getResourceBiologicalQualifier", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","getResourceBiologicalQualifier", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (BiolQualifierType_t)(arg1)->getResourceBiologicalQualifier(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getResourceModelQualifier(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelQualifierType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getResourceModelQualifier", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","getResourceModelQualifier", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (ModelQualifierType_t)(arg1)->getResourceModelQualifier(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getModel(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Model *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getModel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (Model *)((SBase const *)arg1)->getModel();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getLevel(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getLevel();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getVersion(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getPackageVersion(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getPackageVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getPackageVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getPackageName(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getPackageName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getPackageName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getTypeCode(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)((SBase const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_hasValidLevelVersionNamespaceCombination(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","hasValidLevelVersionNamespaceCombination", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)(arg1)->hasValidLevelVersionNamespaceCombination();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getElementName(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_toSBML(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","toSBML", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (char *)(arg1)->toSBML();
  vresult = SWIG_FromCharPtr((const char *)result);
  free(result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getPlugin__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBasePlugin *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","getPlugin", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getPlugin", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getPlugin", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBasePlugin *)(arg1)->getPlugin((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getPlugin__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBasePlugin *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getPlugin", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getPlugin", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getPlugin", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBasePlugin *)((SBase const *)arg1)->getPlugin((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBase_getPlugin(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_getPlugin__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_getPlugin__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBase.getPlugin", 
    "    SBasePlugin const * SBase.getPlugin(std::string const &package)\n"
    "    SBasePlugin const * SBase.getPlugin(std::string const &package)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getNumPlugins(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getNumPlugins", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)((SBase const *)arg1)->getNumPlugins();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_enablePackage(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","enablePackage", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackage", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackage", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackage", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackage", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackage", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (int)(arg1)->enablePackage((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isPkgURIEnabled(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isPkgURIEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isPkgURIEnabled", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isPkgURIEnabled", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((SBase const *)arg1)->isPkgURIEnabled((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_isPkgEnabled(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","isPkgEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isPkgEnabled", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isPkgEnabled", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((SBase const *)arg1)->isPkgEnabled((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_writeExtensionElements(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLOutputStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","writeExtensionElements", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLOutputStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLOutputStream &","writeExtensionElements", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLOutputStream &","writeExtensionElements", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLOutputStream * >(argp2);
  ((SBase const *)arg1)->writeExtensionElements(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_setSBMLNamespacesAndOwn(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","setSBMLNamespacesAndOwn", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLNamespaces *","setSBMLNamespacesAndOwn", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  (arg1)->setSBMLNamespacesAndOwn(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_getSBMLNamespaces(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","getSBMLNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLNamespaces *)((SBase const *)arg1)->getSBMLNamespaces();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase_checkMathMLNamespace(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  XMLToken arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","checkMathMLNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLToken,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLToken const","checkMathMLNamespace", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLToken const","checkMathMLNamespace", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< XMLToken * >(argp2));
    }
  }
  result = (arg1)->checkMathMLNamespace(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBase___str__(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase *","__str__", 1, self )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (char *)SBase___str__(arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOf;

SWIGINTERN VALUE
_wrap_new_ListOf__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOf *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOf", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOf", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOf *)new ListOf(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ListOf__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  ListOf *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOf", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (ListOf *)new ListOf(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ListOf__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOf *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ListOf *)new ListOf();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ListOf__SWIG_3(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOf *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOf", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOf *)new ListOf(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListOf(ListOf *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOf_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOf_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOf);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOf__SWIG_4(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  ListOf *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ListOf,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const &","ListOf", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ListOf const &","ListOf", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (ListOf *)new ListOf((ListOf const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOf(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ListOf__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOf__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOf__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_ListOf__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOf__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOf.new", 
    "    ListOf.new(unsigned int level, unsigned int version)\n"
    "    ListOf.new(unsigned int level)\n"
    "    ListOf.new()\n"
    "    ListOf.new(SBMLNamespaces *sbmlns)\n"
    "    ListOf.new(ListOf const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOf.clone

  call-seq:
    clone -> SBase

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOf_clone(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBase *)((ListOf const *)arg1)->clone();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_append(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBase const *","append", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  result = (int)(arg1)->append((SBase const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_appendAndOwn(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","appendAndOwn", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_SBase, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBase *","appendAndOwn", 2, argv[0] ));
  }
  result = (int)(arg1)->appendAndOwn(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)((ListOf const *)arg1)->get(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)(arg1)->get(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOf_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_get__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOf.get", 
    "    SBase * ListOf.get(unsigned int n)\n"
    "    SBase * ListOf.get(unsigned int n)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOf.clear

  call-seq:
    clear(doDelete=true)
    clear

Clear ListOf contents.
*/
SWIGINTERN VALUE
_wrap_ListOf_clear__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","clear", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->clear(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_clear__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOf_clear(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListOf_clear__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_clear__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOf.clear", 
    "    void ListOf.clear(bool doDelete)\n"
    "    void ListOf.clear()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_remove(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)(arg1)->remove(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ListOf.size

  call-seq:
    size -> unsigned int

Size or Length of the ListOf.
*/
SWIGINTERN VALUE
_wrap_ListOf_size(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (unsigned int)((ListOf const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_connectToChild(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (int)((ListOf const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (int)((ListOf const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (std::string *) &((ListOf const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOf___len__(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","__len__", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (int)ListOf___len__(arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ListOf.[]

  call-seq:
    [](i) -> SBase

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_ListOf___getitem__(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (SBase *)ListOf___getitem__(arg1,arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::ListOf.each

  call-seq:
    each(?)

Iterate thru each element in the ListOf.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_ListOf_each(int argc, VALUE *argv, VALUE self) {
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOf *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ListOf_each(arg1);
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassModel;

SWIGINTERN VALUE
_wrap_new_Model__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Model *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Model", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Model", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Model *)new Model(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Model__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Model *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Model", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Model *)new Model(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Model(Model *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Model_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Model_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Model);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Model__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Model *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Model,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const &","Model", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Model const &","Model", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    try {
      result = (Model *)new Model((Model const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Model(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Model__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Model__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Model__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.new", 
    "    Model.new(unsigned int level, unsigned int version)\n"
    "    Model.new(SBMLNamespaces *sbmlns)\n"
    "    Model.new(Model const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Model.clone

  call-seq:
    clone -> Model

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Model_clone(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Model *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Model *)((Model const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getId(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getName(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getSubstanceUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getTimeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getTimeUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getVolumeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getVolumeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getVolumeUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getAreaUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getAreaUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getAreaUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getLengthUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getLengthUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getLengthUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getExtentUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getExtentUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getExtentUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getConversionFactor(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getConversionFactor();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetId(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetName(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetSubstanceUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetTimeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetTimeUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetVolumeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetVolumeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetVolumeUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetAreaUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetAreaUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetAreaUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetLengthUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetLengthUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetLengthUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetExtentUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetExtentUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetExtentUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isSetConversionFactor(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","isSetConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetConversionFactor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setId(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setName(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSubstanceUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSubstanceUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setTimeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setTimeUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setTimeUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setVolumeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setVolumeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setVolumeUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setVolumeUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVolumeUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setAreaUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setAreaUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setAreaUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setAreaUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAreaUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setLengthUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setLengthUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setLengthUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setLengthUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setLengthUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setExtentUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setExtentUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setExtentUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setExtentUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setExtentUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setConversionFactor(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setConversionFactor", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setConversionFactor", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setConversionFactor((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetId(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetId();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetName(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetTimeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetVolumeUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetVolumeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetVolumeUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetAreaUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetAreaUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetAreaUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetLengthUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetLengthUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetLengthUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetExtentUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetExtentUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetExtentUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_unsetConversionFactor(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","unsetConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetConversionFactor();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addFunctionDefinition(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  FunctionDefinition *arg2 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "FunctionDefinition const *","addFunctionDefinition", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< FunctionDefinition * >(argp2);
  result = (int)(arg1)->addFunctionDefinition((FunctionDefinition const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addUnitDefinition(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UnitDefinition const *","addUnitDefinition", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (int)(arg1)->addUnitDefinition((UnitDefinition const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addCompartmentType(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  CompartmentType *arg2 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "CompartmentType const *","addCompartmentType", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< CompartmentType * >(argp2);
  result = (int)(arg1)->addCompartmentType((CompartmentType const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addSpeciesType(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  SpeciesType *arg2 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SpeciesType const *","addSpeciesType", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SpeciesType * >(argp2);
  result = (int)(arg1)->addSpeciesType((SpeciesType const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addCompartment(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Compartment *arg2 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Compartment const *","addCompartment", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Compartment * >(argp2);
  result = (int)(arg1)->addCompartment((Compartment const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addSpecies(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Species *arg2 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Species const *","addSpecies", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Species * >(argp2);
  result = (int)(arg1)->addSpecies((Species const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addParameter(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Parameter *arg2 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Parameter const *","addParameter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Parameter * >(argp2);
  result = (int)(arg1)->addParameter((Parameter const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addInitialAssignment(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  InitialAssignment *arg2 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "InitialAssignment const *","addInitialAssignment", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< InitialAssignment * >(argp2);
  result = (int)(arg1)->addInitialAssignment((InitialAssignment const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addRule(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Rule *arg2 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Rule const *","addRule", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Rule * >(argp2);
  result = (int)(arg1)->addRule((Rule const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addConstraint(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Constraint *arg2 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addConstraint", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Constraint const *","addConstraint", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Constraint * >(argp2);
  result = (int)(arg1)->addConstraint((Constraint const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addReaction(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Reaction *arg2 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Reaction const *","addReaction", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Reaction * >(argp2);
  result = (int)(arg1)->addReaction((Reaction const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addEvent(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  Event *arg2 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Event const *","addEvent", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Event * >(argp2);
  result = (int)(arg1)->addEvent((Event const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createFunctionDefinition(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (FunctionDefinition *)(arg1)->createFunctionDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createUnitDefinition(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (UnitDefinition *)(arg1)->createUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createUnit(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createUnit", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Unit *)(arg1)->createUnit();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createCompartmentType(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (CompartmentType *)(arg1)->createCompartmentType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createSpeciesType(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesType *)(arg1)->createSpeciesType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createCompartment(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Compartment *)(arg1)->createCompartment();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createSpecies(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Species *)(arg1)->createSpecies();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createParameter(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Parameter *)(arg1)->createParameter();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createInitialAssignment(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (InitialAssignment *)(arg1)->createInitialAssignment();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createAlgebraicRule(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AlgebraicRule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createAlgebraicRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (AlgebraicRule *)(arg1)->createAlgebraicRule();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createAssignmentRule(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AssignmentRule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createAssignmentRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (AssignmentRule *)(arg1)->createAssignmentRule();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createRateRule(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RateRule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createRateRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (RateRule *)(arg1)->createRateRule();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createConstraint(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createConstraint", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Constraint *)(arg1)->createConstraint();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createReaction(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Reaction *)(arg1)->createReaction();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createReactant(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesReference *)(arg1)->createReactant();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createProduct(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesReference *)(arg1)->createProduct();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createModifier(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ModifierSpeciesReference *)(arg1)->createModifier();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createKineticLaw(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (KineticLaw *)(arg1)->createKineticLaw();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createKineticLawParameter(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createKineticLawParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Parameter *)(arg1)->createKineticLawParameter();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createKineticLawLocalParameter(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createKineticLawLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (LocalParameter *)(arg1)->createKineticLawLocalParameter();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createEvent(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Event *)(arg1)->createEvent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createEventAssignment(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (EventAssignment *)(arg1)->createEventAssignment();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createTrigger(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createTrigger", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Trigger *)(arg1)->createTrigger();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_createDelay(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","createDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Delay *)(arg1)->createDelay();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","setAnnotation", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setAnnotation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setAnnotation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_setAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_setAnnotation__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_setAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.setAnnotation", 
    "    int Model.setAnnotation(XMLNode const *annotation)\n"
    "    int Model.setAnnotation(std::string const &annotation)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_appendAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","appendAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","appendAnnotation", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_appendAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","appendAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","appendAnnotation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","appendAnnotation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_appendAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_appendAnnotation__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_appendAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.appendAnnotation", 
    "    int Model.appendAnnotation(XMLNode const *annotation)\n"
    "    int Model.appendAnnotation(std::string const &annotation)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfFunctionDefinitions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfFunctionDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfFunctionDefinitions *)((Model const *)arg1)->getListOfFunctionDefinitions();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfFunctionDefinitions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfFunctionDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfFunctionDefinitions *)(arg1)->getListOfFunctionDefinitions();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfFunctionDefinitions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfFunctionDefinitions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfFunctionDefinitions__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfFunctionDefinitions", 
    "    ListOfFunctionDefinitions * Model.getListOfFunctionDefinitions()\n"
    "    ListOfFunctionDefinitions * Model.getListOfFunctionDefinitions()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfUnitDefinitions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfUnitDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfUnitDefinitions *)((Model const *)arg1)->getListOfUnitDefinitions();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfUnitDefinitions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfUnitDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfUnitDefinitions *)(arg1)->getListOfUnitDefinitions();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfUnitDefinitions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfUnitDefinitions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfUnitDefinitions__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfUnitDefinitions", 
    "    ListOfUnitDefinitions * Model.getListOfUnitDefinitions()\n"
    "    ListOfUnitDefinitions * Model.getListOfUnitDefinitions()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfCompartmentTypes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfCompartmentTypes", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartmentTypes *)((Model const *)arg1)->getListOfCompartmentTypes();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfCompartmentTypes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfCompartmentTypes", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartmentTypes *)(arg1)->getListOfCompartmentTypes();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfCompartmentTypes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartmentTypes__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartmentTypes__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfCompartmentTypes", 
    "    ListOfCompartmentTypes * Model.getListOfCompartmentTypes()\n"
    "    ListOfCompartmentTypes * Model.getListOfCompartmentTypes()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfSpeciesTypes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfSpeciesTypes", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpeciesTypes *)((Model const *)arg1)->getListOfSpeciesTypes();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfSpeciesTypes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfSpeciesTypes", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpeciesTypes *)(arg1)->getListOfSpeciesTypes();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfSpeciesTypes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpeciesTypes__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpeciesTypes__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfSpeciesTypes", 
    "    ListOfSpeciesTypes * Model.getListOfSpeciesTypes()\n"
    "    ListOfSpeciesTypes * Model.getListOfSpeciesTypes()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfCompartments__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfCompartments", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartments *)((Model const *)arg1)->getListOfCompartments();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfCompartments__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfCompartments", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartments *)(arg1)->getListOfCompartments();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfCompartments(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartments__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartments__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfCompartments", 
    "    ListOfCompartments * Model.getListOfCompartments()\n"
    "    ListOfCompartments * Model.getListOfCompartments()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfSpecies__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpecies *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpecies *)((Model const *)arg1)->getListOfSpecies();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfSpecies__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpecies *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpecies *)(arg1)->getListOfSpecies();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfSpecies(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpecies__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpecies__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfSpecies", 
    "    ListOfSpecies * Model.getListOfSpecies()\n"
    "    ListOfSpecies * Model.getListOfSpecies()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfParameters__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfParameters *)((Model const *)arg1)->getListOfParameters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfParameters__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfParameters *)(arg1)->getListOfParameters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfParameters(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfParameters__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfParameters__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfParameters", 
    "    ListOfParameters * Model.getListOfParameters()\n"
    "    ListOfParameters * Model.getListOfParameters()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfInitialAssignments__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfInitialAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfInitialAssignments *)((Model const *)arg1)->getListOfInitialAssignments();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfInitialAssignments__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfInitialAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfInitialAssignments *)(arg1)->getListOfInitialAssignments();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfInitialAssignments(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfInitialAssignments__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfInitialAssignments__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfInitialAssignments", 
    "    ListOfInitialAssignments * Model.getListOfInitialAssignments()\n"
    "    ListOfInitialAssignments * Model.getListOfInitialAssignments()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfRules__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfRules *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfRules", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfRules *)((Model const *)arg1)->getListOfRules();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfRules__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfRules *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfRules", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfRules *)(arg1)->getListOfRules();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfRules(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfRules__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfRules__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfRules", 
    "    ListOfRules * Model.getListOfRules()\n"
    "    ListOfRules * Model.getListOfRules()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfConstraints__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfConstraints *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfConstraints", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfConstraints *)((Model const *)arg1)->getListOfConstraints();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfConstraints__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfConstraints *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfConstraints", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfConstraints *)(arg1)->getListOfConstraints();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfConstraints(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfConstraints__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfConstraints__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfConstraints", 
    "    ListOfConstraints * Model.getListOfConstraints()\n"
    "    ListOfConstraints * Model.getListOfConstraints()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfReactions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfReactions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfReactions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfReactions *)((Model const *)arg1)->getListOfReactions();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfReactions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfReactions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfReactions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfReactions *)(arg1)->getListOfReactions();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfReactions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfReactions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfReactions__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfReactions", 
    "    ListOfReactions * Model.getListOfReactions()\n"
    "    ListOfReactions * Model.getListOfReactions()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfEvents__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEvents *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getListOfEvents", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfEvents *)((Model const *)arg1)->getListOfEvents();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getListOfEvents__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEvents *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getListOfEvents", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfEvents *)(arg1)->getListOfEvents();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getListOfEvents(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfEvents__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfEvents__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Model.getListOfEvents", 
    "    ListOfEvents * Model.getListOfEvents()\n"
    "    ListOfEvents * Model.getListOfEvents()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getFunctionDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getFunctionDefinition", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)((Model const *)arg1)->getFunctionDefinition(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getFunctionDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getFunctionDefinition", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->getFunctionDefinition(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getFunctionDefinition__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getFunctionDefinition", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getFunctionDefinition", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)((Model const *)arg1)->getFunctionDefinition((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getFunctionDefinition__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getFunctionDefinition", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getFunctionDefinition", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->getFunctionDefinition((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getFunctionDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getFunctionDefinition", 
    "    FunctionDefinition * Model.getFunctionDefinition(unsigned int n)\n"
    "    FunctionDefinition * Model.getFunctionDefinition(unsigned int n)\n"
    "    FunctionDefinition * Model.getFunctionDefinition(std::string const &sid)\n"
    "    FunctionDefinition * Model.getFunctionDefinition(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getUnitDefinition", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)((Model const *)arg1)->getUnitDefinition(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getUnitDefinition", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->getUnitDefinition(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getUnitDefinition__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getUnitDefinition", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getUnitDefinition", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)((Model const *)arg1)->getUnitDefinition((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getUnitDefinition__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getUnitDefinition", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getUnitDefinition", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->getUnitDefinition((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getUnitDefinition", 
    "    UnitDefinition * Model.getUnitDefinition(unsigned int n)\n"
    "    UnitDefinition * Model.getUnitDefinition(unsigned int n)\n"
    "    UnitDefinition * Model.getUnitDefinition(std::string const &sid)\n"
    "    UnitDefinition * Model.getUnitDefinition(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartmentType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getCompartmentType", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)((Model const *)arg1)->getCompartmentType(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartmentType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getCompartmentType", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->getCompartmentType(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartmentType__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getCompartmentType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getCompartmentType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)((Model const *)arg1)->getCompartmentType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartmentType__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getCompartmentType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getCompartmentType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->getCompartmentType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getCompartmentType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getCompartmentType", 
    "    CompartmentType * Model.getCompartmentType(unsigned int n)\n"
    "    CompartmentType * Model.getCompartmentType(unsigned int n)\n"
    "    CompartmentType * Model.getCompartmentType(std::string const &sid)\n"
    "    CompartmentType * Model.getCompartmentType(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpeciesType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getSpeciesType", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)((Model const *)arg1)->getSpeciesType(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpeciesType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getSpeciesType", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->getSpeciesType(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpeciesType__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSpeciesType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSpeciesType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)((Model const *)arg1)->getSpeciesType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpeciesType__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSpeciesType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSpeciesType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->getSpeciesType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getSpeciesType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getSpeciesType", 
    "    SpeciesType * Model.getSpeciesType(unsigned int n)\n"
    "    SpeciesType * Model.getSpeciesType(unsigned int n)\n"
    "    SpeciesType * Model.getSpeciesType(std::string const &sid)\n"
    "    SpeciesType * Model.getSpeciesType(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getCompartment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)((Model const *)arg1)->getCompartment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getCompartment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->getCompartment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartment__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getCompartment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getCompartment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)((Model const *)arg1)->getCompartment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getCompartment__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getCompartment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getCompartment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->getCompartment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getCompartment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getCompartment", 
    "    Compartment * Model.getCompartment(unsigned int n)\n"
    "    Compartment * Model.getCompartment(unsigned int n)\n"
    "    Compartment * Model.getCompartment(std::string const &sid)\n"
    "    Compartment * Model.getCompartment(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpecies__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getSpecies", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)((Model const *)arg1)->getSpecies(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpecies__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getSpecies", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->getSpecies(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpecies__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSpecies", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSpecies", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Species *)((Model const *)arg1)->getSpecies((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpecies__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSpecies", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSpecies", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->getSpecies((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getSpecies(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getSpecies", 
    "    Species * Model.getSpecies(unsigned int n)\n"
    "    Species * Model.getSpecies(unsigned int n)\n"
    "    Species * Model.getSpecies(std::string const &sid)\n"
    "    Species * Model.getSpecies(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((Model const *)arg1)->getParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->getParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getParameter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((Model const *)arg1)->getParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getParameter__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->getParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getParameter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getParameter__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getParameter__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getParameter", 
    "    Parameter * Model.getParameter(unsigned int n)\n"
    "    Parameter * Model.getParameter(unsigned int n)\n"
    "    Parameter * Model.getParameter(std::string const &sid)\n"
    "    Parameter * Model.getParameter(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getInitialAssignment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getInitialAssignment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)((Model const *)arg1)->getInitialAssignment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getInitialAssignment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getInitialAssignment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->getInitialAssignment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getInitialAssignment__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getInitialAssignment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getInitialAssignment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)((Model const *)arg1)->getInitialAssignment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getInitialAssignment__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getInitialAssignment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getInitialAssignment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->getInitialAssignment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getInitialAssignment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getInitialAssignment", 
    "    InitialAssignment * Model.getInitialAssignment(unsigned int n)\n"
    "    InitialAssignment * Model.getInitialAssignment(unsigned int n)\n"
    "    InitialAssignment * Model.getInitialAssignment(std::string const &symbol)\n"
    "    InitialAssignment * Model.getInitialAssignment(std::string const &symbol)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getRule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getRule", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)((Model const *)arg1)->getRule(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getRule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getRule", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->getRule(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getRule__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getRule", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getRule", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Rule *)((Model const *)arg1)->getRule((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getRule__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getRule", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getRule", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->getRule((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getRule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getRule__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getRule__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getRule__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getRule__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getRule", 
    "    Rule * Model.getRule(unsigned int n)\n"
    "    Rule * Model.getRule(unsigned int n)\n"
    "    Rule * Model.getRule(std::string const &variable)\n"
    "    Rule * Model.getRule(std::string const &variable)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getConstraint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getConstraint", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getConstraint", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)((Model const *)arg1)->getConstraint(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getConstraint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getConstraint", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getConstraint", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->getConstraint(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getConstraint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getConstraint__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getConstraint__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getConstraint", 
    "    Constraint * Model.getConstraint(unsigned int n)\n"
    "    Constraint * Model.getConstraint(unsigned int n)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getReaction__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getReaction", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)((Model const *)arg1)->getReaction(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getReaction__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getReaction", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->getReaction(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getReaction__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getReaction", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getReaction", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)((Model const *)arg1)->getReaction((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getReaction__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getReaction", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getReaction", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->getReaction((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getReaction(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getReaction__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getReaction__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getReaction__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getReaction__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getReaction", 
    "    Reaction * Model.getReaction(unsigned int n)\n"
    "    Reaction * Model.getReaction(unsigned int n)\n"
    "    Reaction * Model.getReaction(std::string const &sid)\n"
    "    Reaction * Model.getReaction(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpeciesReference__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getSpeciesReference", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSpeciesReference", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSpeciesReference", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getSpeciesReference((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getSpeciesReference__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getSpeciesReference", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSpeciesReference", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSpeciesReference", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Model const *)arg1)->getSpeciesReference((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getSpeciesReference(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesReference__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesReference__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getSpeciesReference", 
    "    SpeciesReference const * Model.getSpeciesReference(std::string const &sid)\n"
    "    SpeciesReference const * Model.getSpeciesReference(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getEvent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getEvent", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)((Model const *)arg1)->getEvent(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getEvent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getEvent", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->getEvent(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getEvent__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Event *)((Model const *)arg1)->getEvent((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getEvent__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","getEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->getEvent((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_getEvent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getEvent__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getEvent__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getEvent__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getEvent__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.getEvent", 
    "    Event * Model.getEvent(unsigned int n)\n"
    "    Event * Model.getEvent(unsigned int n)\n"
    "    Event * Model.getEvent(std::string const &sid)\n"
    "    Event * Model.getEvent(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumFunctionDefinitions(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumFunctionDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumFunctionDefinitions();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumUnitDefinitions(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumUnitDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumUnitDefinitions();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumCompartmentTypes(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumCompartmentTypes", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumCompartmentTypes();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumSpeciesTypes(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumSpeciesTypes", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpeciesTypes();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumCompartments(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumCompartments", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumCompartments();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumSpecies(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpecies();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumSpeciesWithBoundaryCondition(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumSpeciesWithBoundaryCondition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpeciesWithBoundaryCondition();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumParameters(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumParameters();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumInitialAssignments(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumInitialAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumInitialAssignments();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumRules(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumRules", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumRules();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumConstraints(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumConstraints", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumConstraints();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumReactions(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumReactions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumReactions();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getNumEvents(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getNumEvents", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumEvents();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL1ToL2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL1ToL2", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL1ToL2();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL1ToL3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL1ToL3", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL1ToL3();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL2ToL3(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL2ToL3", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL2ToL3();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL2ToL1__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL2ToL1", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","convertL2ToL1", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->convertL2ToL1(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL2ToL1__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL2ToL1", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL2ToL1();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_convertL2ToL1(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_convertL2ToL1__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_convertL2ToL1__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.convertL2ToL1", 
    "    void Model.convertL2ToL1(bool strict)\n"
    "    void Model.convertL2ToL1()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL3ToL1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL3ToL1", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL3ToL1();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertL3ToL2(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertL3ToL2", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL3ToL2();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addModifiers(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addModifiers", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addModifiers();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addConstantAttribute(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addConstantAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addConstantAttribute();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setSpatialDimensions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setSpatialDimensions", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->setSpatialDimensions(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setSpatialDimensions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->setSpatialDimensions();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_setSpatialDimensions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_setSpatialDimensions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_setSpatialDimensions__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Model.setSpatialDimensions", 
    "    void Model.setSpatialDimensions(double dims)\n"
    "    void Model.setSpatialDimensions()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_addDefinitionsForDefaultUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","addDefinitionsForDefaultUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addDefinitionsForDefaultUnits();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertParametersToLocals(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertParametersToLocals", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","convertParametersToLocals", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","convertParametersToLocals", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->convertParametersToLocals(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_setSpeciesReferenceConstantValueAndStoichiometry(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","setSpeciesReferenceConstantValueAndStoichiometry", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->setSpeciesReferenceConstantValueAndStoichiometry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeParameterRuleUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeParameterRuleUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->removeParameterRuleUnits();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_convertStoichiometryMath(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","convertStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertStoichiometryMath();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_assignRequiredValues(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","assignRequiredValues", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->assignRequiredValues();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_dealWithModelUnits(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","dealWithModelUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->dealWithModelUnits();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_dealWithStoichiometry(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","dealWithStoichiometry", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->dealWithStoichiometry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_connectToChild(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)((Model const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_getElementName(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_populateListFormulaUnitsData(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","populateListFormulaUnitsData", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->populateListFormulaUnitsData();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_isPopulatedListFormulaUnitsData(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","isPopulatedListFormulaUnitsData", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)(arg1)->isPopulatedListFormulaUnitsData();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeFunctionDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeFunctionDefinition", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->removeFunctionDefinition(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeFunctionDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeFunctionDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeFunctionDefinition", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeFunctionDefinition", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->removeFunctionDefinition((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeFunctionDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeFunctionDefinition__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeFunctionDefinition__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeFunctionDefinition.new", 
    "    removeFunctionDefinition.new(unsigned int n)\n"
    "    removeFunctionDefinition.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeUnitDefinition", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->removeUnitDefinition(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeUnitDefinition", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeUnitDefinition", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->removeUnitDefinition((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeUnitDefinition__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeUnitDefinition__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeUnitDefinition.new", 
    "    removeUnitDefinition.new(unsigned int n)\n"
    "    removeUnitDefinition.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeCompartmentType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeCompartmentType", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->removeCompartmentType(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeCompartmentType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeCompartmentType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeCompartmentType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->removeCompartmentType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeCompartmentType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeCompartmentType__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeCompartmentType__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeCompartmentType.new", 
    "    removeCompartmentType.new(unsigned int n)\n"
    "    removeCompartmentType.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeSpeciesType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeSpeciesType", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->removeSpeciesType(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeSpeciesType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeSpeciesType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeSpeciesType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->removeSpeciesType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeSpeciesType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeSpeciesType__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeSpeciesType__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeSpeciesType.new", 
    "    removeSpeciesType.new(unsigned int n)\n"
    "    removeSpeciesType.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeCompartment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeCompartment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->removeCompartment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeCompartment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeCompartment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeCompartment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->removeCompartment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeCompartment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeCompartment__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeCompartment__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeCompartment.new", 
    "    removeCompartment.new(unsigned int n)\n"
    "    removeCompartment.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeSpecies__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeSpecies", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->removeSpecies(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeSpecies__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeSpecies", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeSpecies", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->removeSpecies((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeSpecies(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeSpecies__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeSpecies__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeSpecies.new", 
    "    removeSpecies.new(unsigned int n)\n"
    "    removeSpecies.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->removeParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->removeParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeParameter__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeParameter.new", 
    "    removeParameter.new(unsigned int n)\n"
    "    removeParameter.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeInitialAssignment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeInitialAssignment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->removeInitialAssignment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeInitialAssignment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeInitialAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeInitialAssignment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeInitialAssignment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->removeInitialAssignment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeInitialAssignment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeInitialAssignment__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeInitialAssignment__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeInitialAssignment.new", 
    "    removeInitialAssignment.new(unsigned int n)\n"
    "    removeInitialAssignment.new(std::string const &symbol)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeRule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeRule", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->removeRule(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeRule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeRule", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeRule", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeRule", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->removeRule((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeRule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeRule__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeRule__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeRule.new", 
    "    removeRule.new(unsigned int n)\n"
    "    removeRule.new(std::string const &variable)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeConstraint(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeConstraint", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeConstraint", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->removeConstraint(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeReaction__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeReaction", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->removeReaction(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeReaction__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeReaction", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeReaction", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeReaction", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->removeReaction((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeReaction(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeReaction__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeReaction__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeReaction.new", 
    "    removeReaction.new(unsigned int n)\n"
    "    removeReaction.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeEvent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeEvent", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->removeEvent(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_removeEvent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","removeEvent", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeEvent", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeEvent", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->removeEvent((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Model_removeEvent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeEvent__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeEvent__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeEvent.new", 
    "    removeEvent.new(unsigned int n)\n"
    "    removeEvent.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Model_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Model *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


swig_class SwigClassSBMLDocument;

SWIGINTERN VALUE
_wrap_SBMLDocument_getDefaultLevel(int argc, VALUE *argv, VALUE self) {
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (unsigned int)SBMLDocument::getDefaultLevel();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getDefaultVersion(int argc, VALUE *argv, VALUE self) {
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (unsigned int)SBMLDocument::getDefaultVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLDocument__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLDocument *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLDocument", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLDocument", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLDocument__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLDocument", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLDocument__SWIG_2(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    try {
      result = (SBMLDocument *)new SBMLDocument();
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLDocument__SWIG_3(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","SBMLDocument", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBMLDocument(SBMLDocument *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLDocument_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLDocument_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLDocument);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLDocument__SWIG_4(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SBMLDocument,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const &","SBMLDocument", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SBMLDocument const &","SBMLDocument", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument((SBMLDocument const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SBMLDocument(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SBMLDocument__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLDocument__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBMLDocument.new", 
    "    SBMLDocument.new(unsigned int level, unsigned int version)\n"
    "    SBMLDocument.new(unsigned int level)\n"
    "    SBMLDocument.new()\n"
    "    SBMLDocument.new(SBMLNamespaces *sbmlns)\n"
    "    SBMLDocument.new(SBMLDocument const &rhs)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::SBMLDocument.clone

  call-seq:
    clone -> SBMLDocument

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBMLDocument_clone(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLDocument *)((SBMLDocument const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getModel__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Model *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","getModel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)((SBMLDocument const *)arg1)->getModel();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getModel__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Model *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","getModel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)(arg1)->getModel();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLDocument_getModel(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_getModel__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_getModel__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBMLDocument.getModel", 
    "    Model * SBMLDocument.getModel()\n"
    "    Model * SBMLDocument.getModel()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_expandFunctionDefinitions(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","expandFunctionDefinitions", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (bool)(arg1)->expandFunctionDefinitions();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_expandInitialAssignments(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","expandInitialAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (bool)(arg1)->expandInitialAssignments();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_setLevelAndVersion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","setLevelAndVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setLevelAndVersion", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","setLevelAndVersion", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","setLevelAndVersion", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->setLevelAndVersion(arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_setLevelAndVersion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","setLevelAndVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setLevelAndVersion", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","setLevelAndVersion", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->setLevelAndVersion(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLDocument_setLevelAndVersion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBMLDocument_setLevelAndVersion__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SBMLDocument_setLevelAndVersion__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SBMLDocument.setLevelAndVersion", 
    "    bool SBMLDocument.setLevelAndVersion(unsigned int level, unsigned int version, bool strict)\n"
    "    bool SBMLDocument.setLevelAndVersion(unsigned int level, unsigned int version)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_setModel(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  Model *arg2 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","setModel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Model const *","setModel", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Model * >(argp2);
  result = (int)(arg1)->setModel((Model const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_createModel__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Model *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","createModel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","createModel", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","createModel", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Model *)(arg1)->createModel((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_createModel__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Model *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","createModel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)(arg1)->createModel();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLDocument_createModel(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_createModel__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBMLDocument_createModel__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBMLDocument.createModel", 
    "    Model * SBMLDocument.createModel(std::string const &sid)\n"
    "    Model * SBMLDocument.createModel()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_setConsistencyChecks(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  SBMLErrorCategory_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","setConsistencyChecks", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "SBMLErrorCategory_t","setConsistencyChecks", 2, argv[0] ));
  } 
  arg2 = static_cast< SBMLErrorCategory_t >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setConsistencyChecks", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setConsistencyChecks(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_setConsistencyChecksForConversion(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  SBMLErrorCategory_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","setConsistencyChecksForConversion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "SBMLErrorCategory_t","setConsistencyChecksForConversion", 2, argv[0] ));
  } 
  arg2 = static_cast< SBMLErrorCategory_t >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setConsistencyChecksForConversion", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setConsistencyChecksForConversion(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkConsistency(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkConsistency", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkConsistency();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkInternalConsistency(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkInternalConsistency", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkInternalConsistency();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkL1Compatibility(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkL1Compatibility", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL1Compatibility();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkL2v1Compatibility(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkL2v1Compatibility", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v1Compatibility();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkL2v2Compatibility(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkL2v2Compatibility", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v2Compatibility();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkL2v3Compatibility(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkL2v3Compatibility", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v3Compatibility();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkL2v4Compatibility(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkL2v4Compatibility", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v4Compatibility();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_checkL3v1Compatibility(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","checkL3v1Compatibility", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL3v1Compatibility();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getError(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLError *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","getError", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getError", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)((SBMLDocument const *)arg1)->getError(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getNumErrors(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","getNumErrors", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)((SBMLDocument const *)arg1)->getNumErrors();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_printErrors__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","printErrors", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream &","printErrors", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","printErrors", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  ((SBMLDocument const *)arg1)->printErrors(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_printErrors__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","printErrors", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ((SBMLDocument const *)arg1)->printErrors();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLDocument_printErrors(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_printErrors__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBMLDocument_printErrors__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBMLDocument.printErrors", 
    "    void SBMLDocument.printErrors(std::ostream &stream)\n"
    "    void SBMLDocument.printErrors()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_connectToChild(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getTypeCode(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (int)((SBMLDocument const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getElementName(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (std::string *) &((SBMLDocument const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getErrorLog(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLErrorLog *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","getErrorLog", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLErrorLog *)(arg1)->getErrorLog();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getNamespaces(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument const *","getNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (XMLNamespaces *)((SBMLDocument const *)arg1)->getNamespaces();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_enableDefaultNS(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","enableDefaultNS", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enableDefaultNS", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enableDefaultNS", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","enableDefaultNS", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (int)(arg1)->enableDefaultNS((std::string const &)*arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_isEnabledDefaultNS(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","isEnabledDefaultNS", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isEnabledDefaultNS", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isEnabledDefaultNS", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->isEnabledDefaultNS((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_setPkgRequired(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","setPkgRequired", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setPkgRequired", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setPkgRequired", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setPkgRequired", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (int)(arg1)->setPkgRequired((std::string const &)*arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_getPkgRequired(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","getPkgRequired", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getPkgRequired", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getPkgRequired", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->getPkgRequired((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_isSetPkgRequired(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","isSetPkgRequired", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isSetPkgRequired", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isSetPkgRequired", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->isSetPkgRequired((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocument_isIgnoredPkg(int argc, VALUE *argv, VALUE self) {
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocument *","isIgnoredPkg", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isIgnoredPkg", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isIgnoredPkg", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->isIgnoredPkg((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


swig_class SwigClassFunctionDefinition;

SWIGINTERN VALUE
_wrap_new_FunctionDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","FunctionDefinition", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","FunctionDefinition", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FunctionDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","FunctionDefinition", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_FunctionDefinition(FunctionDefinition *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FunctionDefinition_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FunctionDefinition_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_FunctionDefinition);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FunctionDefinition__SWIG_2(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_FunctionDefinition,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const &","FunctionDefinition", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "FunctionDefinition const &","FunctionDefinition", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition((FunctionDefinition const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FunctionDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionDefinition__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionDefinition__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_FunctionDefinition__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FunctionDefinition.new", 
    "    FunctionDefinition.new(unsigned int level, unsigned int version)\n"
    "    FunctionDefinition.new(SBMLNamespaces *sbmlns)\n"
    "    FunctionDefinition.new(FunctionDefinition const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::FunctionDefinition.clone

  call-seq:
    clone -> FunctionDefinition

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_FunctionDefinition_clone(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (FunctionDefinition *)((FunctionDefinition const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getId(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getName(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getMath(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_isSetId(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_isSetName(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_isSetMath(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_setId(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_setName(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_setMath(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_unsetName(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getArgument__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getArgument", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getArgument", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getArgument(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getArgument__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getArgument", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getArgument", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getArgument", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getArgument((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FunctionDefinition_getArgument(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FunctionDefinition_getArgument__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FunctionDefinition_getArgument__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "FunctionDefinition.getArgument", 
    "    ASTNode const * FunctionDefinition.getArgument(unsigned int n)\n"
    "    ASTNode const * FunctionDefinition.getArgument(std::string const &name)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getBody__SWIG_0(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getBody", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getBody();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getBody__SWIG_1(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition *","getBody", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)(arg1)->getBody();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FunctionDefinition_getBody(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FunctionDefinition_getBody__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FunctionDefinition_getBody__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FunctionDefinition.getBody", 
    "    ASTNode * FunctionDefinition.getBody()\n"
    "    ASTNode * FunctionDefinition.getBody()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getNumArguments(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getNumArguments", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (unsigned int)((FunctionDefinition const *)arg1)->getNumArguments();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getTypeCode(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (int)((FunctionDefinition const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_getElementName(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FunctionDefinition_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "FunctionDefinition const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfFunctionDefinitions;

SWIGINTERN VALUE
_wrap_new_ListOfFunctionDefinitions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfFunctionDefinitions", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfFunctionDefinitions", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfFunctionDefinitions *)new ListOfFunctionDefinitions(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfFunctionDefinitions_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfFunctionDefinitions);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfFunctionDefinitions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfFunctionDefinitions", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfFunctionDefinitions *)new ListOfFunctionDefinitions(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfFunctionDefinitions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfFunctionDefinitions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfFunctionDefinitions__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfFunctionDefinitions.new", 
    "    ListOfFunctionDefinitions.new(unsigned int level, unsigned int version)\n"
    "    ListOfFunctionDefinitions.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfFunctionDefinitions.clone

  call-seq:
    clone -> ListOfFunctionDefinitions

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_clone(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (ListOfFunctionDefinitions *)((ListOfFunctionDefinitions const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (int)((ListOfFunctionDefinitions const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (int)((ListOfFunctionDefinitions const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (std::string *) &((ListOfFunctionDefinitions const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)((ListOfFunctionDefinitions const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)((ListOfFunctionDefinitions const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfFunctionDefinitions_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfFunctionDefinitions.get", 
    "    FunctionDefinition const * ListOfFunctionDefinitions.get(unsigned int n)\n"
    "    FunctionDefinition const * ListOfFunctionDefinitions.get(unsigned int n)\n"
    "    FunctionDefinition const * ListOfFunctionDefinitions.get(std::string const &sid)\n"
    "    FunctionDefinition const * ListOfFunctionDefinitions.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfFunctionDefinitions_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  FunctionDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfFunctionDefinitions *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfFunctionDefinitions_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfFunctionDefinitions(ListOfFunctionDefinitions *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_UnitKind_equals(int argc, VALUE *argv, VALUE self) {
  UnitKind_t arg1 ;
  UnitKind_t arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "UnitKind_t","UnitKind_equals", 1, argv[0] ));
  } 
  arg1 = static_cast< UnitKind_t >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "UnitKind_t","UnitKind_equals", 2, argv[1] ));
  } 
  arg2 = static_cast< UnitKind_t >(val2);
  result = (int)UnitKind_equals(arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitKind_forName(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  UnitKind_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","UnitKind_forName", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (UnitKind_t)UnitKind_forName((char const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitKind_toString(int argc, VALUE *argv, VALUE self) {
  UnitKind_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "UnitKind_t","UnitKind_toString", 1, argv[0] ));
  } 
  arg1 = static_cast< UnitKind_t >(val1);
  result = (char *)UnitKind_toString(arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitKind_isValidUnitKindString(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","UnitKind_isValidUnitKindString", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","UnitKind_isValidUnitKindString", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","UnitKind_isValidUnitKindString", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (int)UnitKind_isValidUnitKindString((char const *)arg1,arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


swig_class SwigClassUnit;

SWIGINTERN VALUE
_wrap_new_Unit__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Unit", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Unit", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Unit *)new Unit(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Unit__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Unit *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Unit", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Unit *)new Unit(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Unit(Unit *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Unit_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Unit_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Unit);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Unit__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Unit *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Unit,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const &","Unit", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Unit const &","Unit", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  {
    try {
      result = (Unit *)new Unit((Unit const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Unit(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Unit__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Unit__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Unit__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Unit.new", 
    "    Unit.new(unsigned int level, unsigned int version)\n"
    "    Unit.new(SBMLNamespaces *sbmlns)\n"
    "    Unit.new(Unit const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Unit.clone

  call-seq:
    clone -> Unit

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Unit_clone(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (Unit *)((Unit const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_initDefaults(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","initDefaults", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  (arg1)->initDefaults();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getKind(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitKind_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getKind", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (UnitKind_t)((Unit const *)arg1)->getKind();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getExponent(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getExponent", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getExponent();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getExponentAsDouble(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getExponentAsDouble", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getExponentAsDouble();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getScale(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getScale", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getScale();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getMultiplier(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getMultiplier", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getMultiplier();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getOffset(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getOffset();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isAmpere(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isAmpere", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isAmpere();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isAvogadro(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isAvogadro", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isAvogadro();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isBecquerel(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isBecquerel", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isBecquerel();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isCandela(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isCandela", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCandela();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isCelsius(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isCelsius", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCelsius();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isCoulomb(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isCoulomb", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCoulomb();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isDimensionless(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isDimensionless", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isDimensionless();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isFarad(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isFarad", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isFarad();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isGram(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isGram", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isGram();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isGray(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isGray", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isGray();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isHenry(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isHenry", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isHenry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isHertz(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isHertz", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isHertz();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isItem(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isItem", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isItem();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isJoule(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isJoule", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isJoule();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isKatal(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isKatal", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKatal();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isKelvin(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isKelvin", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKelvin();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isKilogram(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isKilogram", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKilogram();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isLitre(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isLitre", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLitre();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isLumen(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isLumen", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLumen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isLux(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isLux", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLux();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isMetre(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isMetre", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isMetre();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isMole(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isMole", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isMole();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isNewton(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isNewton", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isNewton();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isOhm(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isOhm", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isOhm();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isPascal(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isPascal", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isPascal();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isRadian(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isRadian", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isRadian();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSecond(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSecond", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSecond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSiemens(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSiemens", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSiemens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSievert(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSievert", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSievert();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSteradian(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSteradian", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSteradian();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isTesla(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isTesla", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isTesla();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isVolt(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isVolt", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isVolt();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isWatt(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isWatt", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isWatt();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isWeber(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isWeber", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isWeber();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSetKind(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSetKind", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetKind();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSetExponent(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSetExponent", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetExponent();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSetScale(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSetScale", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetScale();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isSetMultiplier(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","isSetMultiplier", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetMultiplier();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_setKind(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  UnitKind_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","setKind", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "UnitKind_t","setKind", 2, argv[0] ));
  } 
  arg2 = static_cast< UnitKind_t >(val2);
  result = (int)(arg1)->setKind(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_setExponent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","setExponent", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setExponent", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setExponent(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_setExponent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","setExponent", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setExponent", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setExponent(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Unit_setExponent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Unit_setExponent__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Unit_setExponent__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Unit.setExponent", 
    "    int Unit.setExponent(int value)\n"
    "    int Unit.setExponent(double value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_setScale(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","setScale", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setScale", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setScale(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_setMultiplier(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","setMultiplier", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setMultiplier", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setMultiplier(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_setOffset(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","setOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setOffset(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_getElementName(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (std::string *) &((Unit const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isBuiltIn(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Unit::isBuiltIn", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Unit::isBuiltIn", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Unit::isBuiltIn", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)Unit::isBuiltIn((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_isUnitKind(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Unit::isUnitKind", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Unit::isUnitKind", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Unit::isUnitKind", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Unit::isUnitKind", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)Unit::isUnitKind((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_areIdentical(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","Unit::areIdentical", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Unit *","Unit::areIdentical", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (bool)Unit::areIdentical(arg1,arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_areEquivalent(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","Unit::areEquivalent", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Unit *","Unit::areEquivalent", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (bool)Unit::areEquivalent(arg1,arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_removeScale(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","Unit::removeScale", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)Unit::removeScale(arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_merge(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit *","Unit::merge", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Unit *","Unit::merge", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  Unit::merge(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_convertToSI(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","Unit::convertToSI", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (UnitDefinition *)Unit::convertToSI((Unit const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Unit_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Unit const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfUnits;

SWIGINTERN VALUE
_wrap_new_ListOfUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfUnits *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfUnits", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfUnits", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfUnits *)new ListOfUnits(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfUnits_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfUnits_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfUnits);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnits *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfUnits", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfUnits *)new ListOfUnits(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfUnits__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfUnits__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfUnits.new", 
    "    ListOfUnits.new(unsigned int level, unsigned int version)\n"
    "    ListOfUnits.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfUnits.clone

  call-seq:
    clone -> ListOfUnits

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfUnits_clone(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnits *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (ListOfUnits *)((ListOfUnits const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnits_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (int)((ListOfUnits const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnits_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (int)((ListOfUnits const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnits_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (std::string *) &((ListOfUnits const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnits_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnits_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)((ListOfUnits const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfUnits_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnits, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnits_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnits, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnits_get__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfUnits.get", 
    "    Unit const * ListOfUnits.get(unsigned int n)\n"
    "    Unit const * ListOfUnits.get(unsigned int n)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnits_remove(int argc, VALUE *argv, VALUE self) {
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnits *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListOfUnits(ListOfUnits *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassUnitDefinition;

SWIGINTERN VALUE
_wrap_new_UnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","UnitDefinition", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","UnitDefinition", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_UnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","UnitDefinition", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_UnitDefinition(UnitDefinition *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UnitDefinition_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UnitDefinition_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_UnitDefinition);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UnitDefinition__SWIG_2(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_UnitDefinition,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const &","UnitDefinition", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "UnitDefinition const &","UnitDefinition", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition((UnitDefinition const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_UnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnitDefinition__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UnitDefinition__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "UnitDefinition.new", 
    "    UnitDefinition.new(unsigned int level, unsigned int version)\n"
    "    UnitDefinition.new(SBMLNamespaces *sbmlns)\n"
    "    UnitDefinition.new(UnitDefinition const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::UnitDefinition.clone

  call-seq:
    clone -> UnitDefinition

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_UnitDefinition_clone(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (UnitDefinition *)((UnitDefinition const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getId(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getName(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isSetId(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isSetName(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_setId(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_setName(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_unsetName(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfArea(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfArea", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfArea();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfLength(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfLength", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfLength();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfSubstance(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfSubstance", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfSubstance();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfTime(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfTime", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfTime();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfVolume(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfVolume", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfDimensionless(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfDimensionless", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfDimensionless();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfMass(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfMass", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfMass();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_isVariantOfSubstancePerTime(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","isVariantOfSubstancePerTime", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfSubstancePerTime();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_addUnit(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","addUnit", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Unit const *","addUnit", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (int)(arg1)->addUnit((Unit const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_createUnit(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","createUnit", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (Unit *)(arg1)->createUnit();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getListOfUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnits *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getListOfUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (ListOfUnits *)((UnitDefinition const *)arg1)->getListOfUnits();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getListOfUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnits *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","getListOfUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (ListOfUnits *)(arg1)->getListOfUnits();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_UnitDefinition_getListOfUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_getListOfUnits__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_getListOfUnits__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "UnitDefinition.getListOfUnits", 
    "    ListOfUnits * UnitDefinition.getListOfUnits()\n"
    "    ListOfUnits * UnitDefinition.getListOfUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getUnit__SWIG_0(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","getUnit", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getUnit", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->getUnit(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getUnit__SWIG_1(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getUnit", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getUnit", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)((UnitDefinition const *)arg1)->getUnit(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_UnitDefinition_getUnit(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_getUnit__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_getUnit__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "UnitDefinition.getUnit", 
    "    Unit const * UnitDefinition.getUnit(unsigned int n)\n"
    "    Unit const * UnitDefinition.getUnit(unsigned int n)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getNumUnits(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getNumUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (unsigned int)((UnitDefinition const *)arg1)->getNumUnits();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_removeUnit(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Unit *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","removeUnit", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeUnit", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->removeUnit(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_connectToChild(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getTypeCode(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (int)((UnitDefinition const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_getElementName(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_simplify(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","UnitDefinition::simplify", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  UnitDefinition::simplify(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_reorder(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","UnitDefinition::reorder", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  UnitDefinition::reorder(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_convertToSI(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::convertToSI", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (UnitDefinition *)UnitDefinition::convertToSI((UnitDefinition const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_areIdentical(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::areIdentical", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::areIdentical", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (bool)UnitDefinition::areIdentical((UnitDefinition const *)arg1,(UnitDefinition const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_areEquivalent(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::areEquivalent", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::areEquivalent", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (bool)UnitDefinition::areEquivalent((UnitDefinition const *)arg1,(UnitDefinition const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_combine(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition *","UnitDefinition::combine", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "UnitDefinition *","UnitDefinition::combine", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (UnitDefinition *)UnitDefinition::combine(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_printUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::printUnits", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","UnitDefinition::printUnits", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = UnitDefinition::printUnits((UnitDefinition const *)arg1,arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_printUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","UnitDefinition::printUnits", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = UnitDefinition::printUnits((UnitDefinition const *)arg1);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_UnitDefinition_printUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_printUnits__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_printUnits__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "UnitDefinition.printUnits", 
    "    std::string UnitDefinition.printUnits(UnitDefinition const *ud, bool compact)\n"
    "    std::string UnitDefinition.printUnits(UnitDefinition const *ud)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UnitDefinition_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "UnitDefinition const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfUnitDefinitions;

SWIGINTERN VALUE
_wrap_new_ListOfUnitDefinitions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfUnitDefinitions", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfUnitDefinitions", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfUnitDefinitions *)new ListOfUnitDefinitions(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfUnitDefinitions_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfUnitDefinitions);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfUnitDefinitions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfUnitDefinitions", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfUnitDefinitions *)new ListOfUnitDefinitions(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfUnitDefinitions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfUnitDefinitions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfUnitDefinitions__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfUnitDefinitions.new", 
    "    ListOfUnitDefinitions.new(unsigned int level, unsigned int version)\n"
    "    ListOfUnitDefinitions.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfUnitDefinitions.clone

  call-seq:
    clone -> ListOfUnitDefinitions

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_clone(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (ListOfUnitDefinitions *)((ListOfUnitDefinitions const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (int)((ListOfUnitDefinitions const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (int)((ListOfUnitDefinitions const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (std::string *) &((ListOfUnitDefinitions const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)((ListOfUnitDefinitions const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)((ListOfUnitDefinitions const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfUnitDefinitions_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfUnitDefinitions.get", 
    "    UnitDefinition const * ListOfUnitDefinitions.get(unsigned int n)\n"
    "    UnitDefinition const * ListOfUnitDefinitions.get(unsigned int n)\n"
    "    UnitDefinition const * ListOfUnitDefinitions.get(std::string const &sid)\n"
    "    UnitDefinition const * ListOfUnitDefinitions.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfUnitDefinitions_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfUnitDefinitions *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfUnitDefinitions_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfUnitDefinitions(ListOfUnitDefinitions *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassCompartmentType;

SWIGINTERN VALUE
_wrap_new_CompartmentType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","CompartmentType", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","CompartmentType", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (CompartmentType *)new CompartmentType(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_CompartmentType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CompartmentType *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","CompartmentType", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (CompartmentType *)new CompartmentType(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_CompartmentType(CompartmentType *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CompartmentType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CompartmentType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_CompartmentType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CompartmentType__SWIG_2(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  CompartmentType *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_CompartmentType,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const &","CompartmentType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "CompartmentType const &","CompartmentType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    try {
      result = (CompartmentType *)new CompartmentType((CompartmentType const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CompartmentType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CompartmentType__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CompartmentType, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CompartmentType__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CompartmentType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "CompartmentType.new", 
    "    CompartmentType.new(unsigned int level, unsigned int version)\n"
    "    CompartmentType.new(SBMLNamespaces *sbmlns)\n"
    "    CompartmentType.new(CompartmentType const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::CompartmentType.clone

  call-seq:
    clone -> CompartmentType

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_CompartmentType_clone(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (CompartmentType *)((CompartmentType const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_getId(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_getName(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_isSetId(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_isSetName(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_setId(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_setName(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_unsetName(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_getTypeCode(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (int)((CompartmentType const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_getElementName(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CompartmentType_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CompartmentType const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfCompartmentTypes;

SWIGINTERN VALUE
_wrap_new_ListOfCompartmentTypes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfCompartmentTypes", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfCompartmentTypes", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfCompartmentTypes *)new ListOfCompartmentTypes(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfCompartmentTypes_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfCompartmentTypes);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfCompartmentTypes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfCompartmentTypes", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfCompartmentTypes *)new ListOfCompartmentTypes(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfCompartmentTypes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfCompartmentTypes__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfCompartmentTypes__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfCompartmentTypes.new", 
    "    ListOfCompartmentTypes.new(unsigned int level, unsigned int version)\n"
    "    ListOfCompartmentTypes.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfCompartmentTypes.clone

  call-seq:
    clone -> ListOfCompartmentTypes

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_clone(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (ListOfCompartmentTypes *)((ListOfCompartmentTypes const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (int)((ListOfCompartmentTypes const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (int)((ListOfCompartmentTypes const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (std::string *) &((ListOfCompartmentTypes const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)((ListOfCompartmentTypes const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)((ListOfCompartmentTypes const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfCompartmentTypes_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfCompartmentTypes.get", 
    "    CompartmentType const * ListOfCompartmentTypes.get(unsigned int n)\n"
    "    CompartmentType const * ListOfCompartmentTypes.get(unsigned int n)\n"
    "    CompartmentType const * ListOfCompartmentTypes.get(std::string const &sid)\n"
    "    CompartmentType const * ListOfCompartmentTypes.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartmentTypes_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  CompartmentType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartmentTypes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfCompartmentTypes_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfCompartmentTypes(ListOfCompartmentTypes *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSpeciesType;

SWIGINTERN VALUE
_wrap_new_SpeciesType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SpeciesType", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SpeciesType", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SpeciesType *)new SpeciesType(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SpeciesType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesType *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","SpeciesType", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SpeciesType *)new SpeciesType(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SpeciesType(SpeciesType *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SpeciesType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SpeciesType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SpeciesType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SpeciesType__SWIG_2(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SpeciesType *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SpeciesType,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const &","SpeciesType", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SpeciesType const &","SpeciesType", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    try {
      result = (SpeciesType *)new SpeciesType((SpeciesType const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SpeciesType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesType__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesType, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesType__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SpeciesType__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SpeciesType.new", 
    "    SpeciesType.new(unsigned int level, unsigned int version)\n"
    "    SpeciesType.new(SBMLNamespaces *sbmlns)\n"
    "    SpeciesType.new(SpeciesType const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::SpeciesType.clone

  call-seq:
    clone -> SpeciesType

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SpeciesType_clone(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (SpeciesType *)((SpeciesType const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_getId(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_getName(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_isSetId(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_isSetName(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_setId(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_setName(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_unsetName(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_getTypeCode(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (int)((SpeciesType const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_getElementName(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesType_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesType const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfSpeciesTypes;

SWIGINTERN VALUE
_wrap_new_ListOfSpeciesTypes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfSpeciesTypes", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfSpeciesTypes", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfSpeciesTypes *)new ListOfSpeciesTypes(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfSpeciesTypes_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfSpeciesTypes);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfSpeciesTypes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfSpeciesTypes", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfSpeciesTypes *)new ListOfSpeciesTypes(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfSpeciesTypes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfSpeciesTypes__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfSpeciesTypes__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfSpeciesTypes.new", 
    "    ListOfSpeciesTypes.new(unsigned int level, unsigned int version)\n"
    "    ListOfSpeciesTypes.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfSpeciesTypes.clone

  call-seq:
    clone -> ListOfSpeciesTypes

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_clone(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (ListOfSpeciesTypes *)((ListOfSpeciesTypes const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (int)((ListOfSpeciesTypes const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (int)((ListOfSpeciesTypes const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (std::string *) &((ListOfSpeciesTypes const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)((ListOfSpeciesTypes const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)((ListOfSpeciesTypes const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfSpeciesTypes_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfSpeciesTypes.get", 
    "    SpeciesType const * ListOfSpeciesTypes.get(unsigned int n)\n"
    "    SpeciesType const * ListOfSpeciesTypes.get(unsigned int n)\n"
    "    SpeciesType const * ListOfSpeciesTypes.get(std::string const &sid)\n"
    "    SpeciesType const * ListOfSpeciesTypes.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesTypes_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesType *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesTypes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfSpeciesTypes_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfSpeciesTypes(ListOfSpeciesTypes *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassCompartment;

SWIGINTERN VALUE
_wrap_new_Compartment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Compartment", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Compartment", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Compartment *)new Compartment(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Compartment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Compartment *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Compartment", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Compartment *)new Compartment(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Compartment(Compartment *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Compartment_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Compartment_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Compartment);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Compartment__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Compartment *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Compartment,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const &","Compartment", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Compartment const &","Compartment", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    try {
      result = (Compartment *)new Compartment((Compartment const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Compartment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Compartment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Compartment__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Compartment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Compartment.new", 
    "    Compartment.new(unsigned int level, unsigned int version)\n"
    "    Compartment.new(SBMLNamespaces *sbmlns)\n"
    "    Compartment.new(Compartment const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Compartment.clone

  call-seq:
    clone -> Compartment

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Compartment_clone(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (Compartment *)((Compartment const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_initDefaults(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","initDefaults", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  (arg1)->initDefaults();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getId(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getName(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getCompartmentType(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getCompartmentType();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getSpatialDimensions(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (unsigned int)((Compartment const *)arg1)->getSpatialDimensions();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getSpatialDimensionsAsDouble(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getSpatialDimensionsAsDouble", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getSpatialDimensionsAsDouble();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getSize(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getSize", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getSize();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getVolume(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getVolume", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getVolume();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getUnits(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getOutside(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getOutside", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getOutside();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getConstant(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->getConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetId(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetName(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetCompartmentType(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetCompartmentType();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetSize(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetSize", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetSize();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetVolume(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetVolume", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetUnits(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetOutside(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetOutside", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetOutside();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetSpatialDimensions(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetSpatialDimensions();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_isSetConstant(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","isSetConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setId(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setName(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setCompartmentType(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setCompartmentType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setCompartmentType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartmentType((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setSpatialDimensions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setSpatialDimensions", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSpatialDimensions(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setSpatialDimensions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setSpatialDimensions", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setSpatialDimensions(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Compartment_setSpatialDimensions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Compartment_setSpatialDimensions__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Compartment_setSpatialDimensions__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Compartment.setSpatialDimensions", 
    "    int Compartment.setSpatialDimensions(unsigned int value)\n"
    "    int Compartment.setSpatialDimensions(double value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setSize(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setSize", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setSize", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setSize(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setVolume(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setVolume", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setVolume", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setVolume(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setUnits(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setOutside(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setOutside", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setOutside", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setOutside", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOutside((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_setConstant(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","setConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setConstant", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetName(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetCompartmentType(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetCompartmentType", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetCompartmentType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetSize(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetSize", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetSize();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetVolume(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetVolume", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetVolume();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetUnits(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetOutside(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetOutside", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetOutside();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_unsetSpatialDimensions(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","unsetSpatialDimensions", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetSpatialDimensions();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (UnitDefinition *)((Compartment const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Compartment_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Compartment_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Compartment_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Compartment.getDerivedUnitDefinition", 
    "    UnitDefinition const * Compartment.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * Compartment.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)((Compartment const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_getElementName(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Compartment_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Compartment const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfCompartments;

SWIGINTERN VALUE
_wrap_new_ListOfCompartments__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfCompartments", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfCompartments", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfCompartments *)new ListOfCompartments(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfCompartments_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfCompartments_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfCompartments);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfCompartments__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfCompartments", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfCompartments *)new ListOfCompartments(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfCompartments(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfCompartments__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfCompartments__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfCompartments.new", 
    "    ListOfCompartments.new(unsigned int level, unsigned int version)\n"
    "    ListOfCompartments.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfCompartments.clone

  call-seq:
    clone -> ListOfCompartments

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfCompartments_clone(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfCompartments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (ListOfCompartments *)((ListOfCompartments const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (int)((ListOfCompartments const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (int)((ListOfCompartments const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (std::string *) &((ListOfCompartments const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)((ListOfCompartments const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)((ListOfCompartments const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfCompartments_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfCompartments.get", 
    "    Compartment const * ListOfCompartments.get(unsigned int n)\n"
    "    Compartment const * ListOfCompartments.get(unsigned int n)\n"
    "    Compartment const * ListOfCompartments.get(std::string const &sid)\n"
    "    Compartment const * ListOfCompartments.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfCompartments_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Compartment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfCompartments *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfCompartments_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfCompartments(ListOfCompartments *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSpecies;

SWIGINTERN VALUE
_wrap_new_Species__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Species", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Species", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Species *)new Species(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Species__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Species *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Species", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Species *)new Species(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Species(Species *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Species_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Species_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Species);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Species__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Species *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Species,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const &","Species", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Species const &","Species", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    try {
      result = (Species *)new Species((Species const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Species(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Species__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Species__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Species__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Species.new", 
    "    Species.new(unsigned int level, unsigned int version)\n"
    "    Species.new(SBMLNamespaces *sbmlns)\n"
    "    Species.new(Species const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Species.clone

  call-seq:
    clone -> Species

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Species_clone(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (Species *)((Species const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_initDefaults(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","initDefaults", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  (arg1)->initDefaults();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getId(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getName(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getSpeciesType(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSpeciesType();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getCompartment(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getCompartment();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getInitialAmount(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getInitialAmount", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (double)((Species const *)arg1)->getInitialAmount();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getInitialConcentration(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getInitialConcentration", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (double)((Species const *)arg1)->getInitialConcentration();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSubstanceUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getSpatialSizeUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getSpatialSizeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSpatialSizeUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getHasOnlySubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getHasOnlySubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getHasOnlySubstanceUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getBoundaryCondition(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getBoundaryCondition", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getBoundaryCondition();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getCharge(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getCharge", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)((Species const *)arg1)->getCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getConstant(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getConversionFactor(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getConversionFactor();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetId(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetName(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetSpeciesType(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSpeciesType();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetCompartment(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetCompartment();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetInitialAmount(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetInitialAmount", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetInitialAmount();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetInitialConcentration(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetInitialConcentration", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetInitialConcentration();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSubstanceUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetSpatialSizeUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetSpatialSizeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSpatialSizeUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetCharge(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetCharge", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetConversionFactor(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetConversionFactor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetBoundaryCondition(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetBoundaryCondition", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetBoundaryCondition();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetHasOnlySubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetHasOnlySubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetHasOnlySubstanceUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_isSetConstant(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","isSetConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setId(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setName(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setSpeciesType(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSpeciesType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSpeciesType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpeciesType((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setCompartment(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setCompartment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setCompartment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartment((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setInitialAmount(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setInitialAmount", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setInitialAmount", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setInitialAmount(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setInitialConcentration(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setInitialConcentration", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setInitialConcentration", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setInitialConcentration(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSubstanceUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSubstanceUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setSpatialSizeUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setSpatialSizeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSpatialSizeUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSpatialSizeUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpatialSizeUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setHasOnlySubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setHasOnlySubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setHasOnlySubstanceUnits", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setHasOnlySubstanceUnits(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setBoundaryCondition(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setBoundaryCondition", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setBoundaryCondition", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setBoundaryCondition(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setCharge(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setCharge", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setCharge", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setCharge(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setConstant(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setConstant", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_setConversionFactor(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","setConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setConversionFactor", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setConversionFactor", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setConversionFactor((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetName(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetSpeciesType(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetSpeciesType", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSpeciesType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetInitialAmount(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetInitialAmount", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetInitialAmount();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetInitialConcentration(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetInitialConcentration", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetInitialConcentration();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetSpatialSizeUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetSpatialSizeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSpatialSizeUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetUnits(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetCharge(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetCharge", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_unsetConversionFactor(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","unsetConversionFactor", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetConversionFactor();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (UnitDefinition *)((Species const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Species_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Species_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Species_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Species.getDerivedUnitDefinition", 
    "    UnitDefinition const * Species.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * Species.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)((Species const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_getElementName(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Species_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Species const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfSpecies;

SWIGINTERN VALUE
_wrap_new_ListOfSpecies__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfSpecies", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfSpecies", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfSpecies *)new ListOfSpecies(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfSpecies_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfSpecies_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfSpecies);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfSpecies__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfSpecies", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfSpecies *)new ListOfSpecies(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfSpecies(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfSpecies__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfSpecies__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfSpecies.new", 
    "    ListOfSpecies.new(unsigned int level, unsigned int version)\n"
    "    ListOfSpecies.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfSpecies.clone

  call-seq:
    clone -> ListOfSpecies

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfSpecies_clone(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpecies *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (ListOfSpecies *)((ListOfSpecies const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (int)((ListOfSpecies const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (int)((ListOfSpecies const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (std::string *) &((ListOfSpecies const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)((ListOfSpecies const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Species *)((ListOfSpecies const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfSpecies_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfSpecies.get", 
    "    Species const * ListOfSpecies.get(unsigned int n)\n"
    "    Species const * ListOfSpecies.get(unsigned int n)\n"
    "    Species const * ListOfSpecies.get(std::string const &sid)\n"
    "    Species const * ListOfSpecies.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpecies_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Species *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpecies *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfSpecies_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfSpecies(ListOfSpecies *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassParameter;

SWIGINTERN VALUE
_wrap_new_Parameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Parameter", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Parameter", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Parameter *)new Parameter(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Parameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Parameter *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Parameter", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Parameter *)new Parameter(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Parameter(Parameter *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Parameter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Parameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Parameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Parameter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Parameter *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Parameter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const &","Parameter", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Parameter const &","Parameter", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    try {
      result = (Parameter *)new Parameter((Parameter const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Parameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Parameter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Parameter__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Parameter__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Parameter.new", 
    "    Parameter.new(unsigned int level, unsigned int version)\n"
    "    Parameter.new(SBMLNamespaces *sbmlns)\n"
    "    Parameter.new(Parameter const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Parameter.clone

  call-seq:
    clone -> Parameter

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Parameter_clone(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (Parameter *)((Parameter const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_initDefaults(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","initDefaults", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  (arg1)->initDefaults();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getId(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getName(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getValue(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (double)((Parameter const *)arg1)->getValue();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getUnits(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getConstant(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->getConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_isSetId(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_isSetName(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_isSetValue(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","isSetValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetValue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_isSetUnits(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","isSetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_isSetConstant(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","isSetConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_setId(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_setName(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_setValue(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setValue(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_setUnits(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","setUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_setConstant(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","setConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setConstant", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_unsetName(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_unsetValue(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","unsetValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetValue();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_unsetUnits(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","unsetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (UnitDefinition *)((Parameter const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Parameter_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Parameter_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Parameter_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Parameter.getDerivedUnitDefinition", 
    "    UnitDefinition const * Parameter.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * Parameter.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)((Parameter const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_getElementName(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Parameter_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfParameters;

SWIGINTERN VALUE
_wrap_new_ListOfParameters__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfParameters *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfParameters", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfParameters", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfParameters *)new ListOfParameters(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfParameters_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfParameters_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfParameters);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfParameters__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfParameters *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfParameters", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfParameters *)new ListOfParameters(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfParameters(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfParameters__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfParameters__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfParameters.new", 
    "    ListOfParameters.new(unsigned int level, unsigned int version)\n"
    "    ListOfParameters.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfParameters.clone

  call-seq:
    clone -> ListOfParameters

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfParameters_clone(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (ListOfParameters *)((ListOfParameters const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (int)((ListOfParameters const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (int)((ListOfParameters const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (std::string *) &((ListOfParameters const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((ListOfParameters const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((ListOfParameters const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfParameters_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfParameters.get", 
    "    Parameter const * ListOfParameters.get(unsigned int n)\n"
    "    Parameter const * ListOfParameters.get(unsigned int n)\n"
    "    Parameter const * ListOfParameters.get(std::string const &sid)\n"
    "    Parameter const * ListOfParameters.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfParameters_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfParameters *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfParameters_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfParameters(ListOfParameters *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassLocalParameter;

SWIGINTERN VALUE
_wrap_new_LocalParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","LocalParameter", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","LocalParameter", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (LocalParameter *)new LocalParameter(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_LocalParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LocalParameter *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","LocalParameter", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_LocalParameter(LocalParameter *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_new_LocalParameter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  LocalParameter *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_LocalParameter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter const &","LocalParameter", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "LocalParameter const &","LocalParameter", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter((LocalParameter const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_LocalParameter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_LocalParameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_LocalParameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_LocalParameter__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Parameter *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  LocalParameter *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Parameter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Parameter const &","LocalParameter", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Parameter const &","LocalParameter", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter((Parameter const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LocalParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "LocalParameter.new", 
    "    LocalParameter.new(unsigned int level, unsigned int version)\n"
    "    LocalParameter.new(SBMLNamespaces *sbmlns)\n"
    "    LocalParameter.new(LocalParameter const &orig)\n"
    "    LocalParameter.new(Parameter const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::LocalParameter.clone

  call-seq:
    clone -> LocalParameter

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_LocalParameter_clone(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (LocalParameter *)((LocalParameter const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalParameter_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalParameter_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (UnitDefinition *)((LocalParameter const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_LocalParameter_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LocalParameter_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LocalParameter_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "LocalParameter.getDerivedUnitDefinition", 
    "    UnitDefinition const * LocalParameter.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * LocalParameter.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalParameter_getTypeCode(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (int)((LocalParameter const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalParameter_getElementName(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (std::string *) &((LocalParameter const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocalParameter_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "LocalParameter const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (bool)((LocalParameter const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfLocalParameters;

SWIGINTERN VALUE
_wrap_new_ListOfLocalParameters__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfLocalParameters", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfLocalParameters", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfLocalParameters *)new ListOfLocalParameters(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfLocalParameters_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfLocalParameters_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfLocalParameters);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfLocalParameters__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfLocalParameters", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfLocalParameters *)new ListOfLocalParameters(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfLocalParameters(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfLocalParameters__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfLocalParameters__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfLocalParameters.new", 
    "    ListOfLocalParameters.new(unsigned int level, unsigned int version)\n"
    "    ListOfLocalParameters.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfLocalParameters.clone

  call-seq:
    clone -> ListOfLocalParameters

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfLocalParameters_clone(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfLocalParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (ListOfLocalParameters *)((ListOfLocalParameters const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (int)((ListOfLocalParameters const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (int)((ListOfLocalParameters const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (std::string *) &((ListOfLocalParameters const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)((ListOfLocalParameters const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)((ListOfLocalParameters const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfLocalParameters_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfLocalParameters.get", 
    "    LocalParameter const * ListOfLocalParameters.get(unsigned int n)\n"
    "    LocalParameter const * ListOfLocalParameters.get(unsigned int n)\n"
    "    LocalParameter const * ListOfLocalParameters.get(std::string const &sid)\n"
    "    LocalParameter const * ListOfLocalParameters.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfLocalParameters_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfLocalParameters *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfLocalParameters_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfLocalParameters(ListOfLocalParameters *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassInitialAssignment;

SWIGINTERN VALUE
_wrap_new_InitialAssignment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","InitialAssignment", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","InitialAssignment", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InitialAssignment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","InitialAssignment", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_InitialAssignment(InitialAssignment *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InitialAssignment_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InitialAssignment_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_InitialAssignment);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InitialAssignment__SWIG_2(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_InitialAssignment,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const &","InitialAssignment", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "InitialAssignment const &","InitialAssignment", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment((InitialAssignment const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InitialAssignment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InitialAssignment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InitialAssignment__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_InitialAssignment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "InitialAssignment.new", 
    "    InitialAssignment.new(unsigned int level, unsigned int version)\n"
    "    InitialAssignment.new(SBMLNamespaces *sbmlns)\n"
    "    InitialAssignment.new(InitialAssignment const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::InitialAssignment.clone

  call-seq:
    clone -> InitialAssignment

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_InitialAssignment_clone(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (InitialAssignment *)((InitialAssignment const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getSymbol(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","getSymbol", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getSymbol();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getMath(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (ASTNode *)((InitialAssignment const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_isSetSymbol(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","isSetSymbol", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->isSetSymbol();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_isSetMath(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_setSymbol(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment *","setSymbol", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSymbol", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSymbol", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSymbol((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_setMath(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (UnitDefinition *)((InitialAssignment const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_InitialAssignment_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "InitialAssignment.getDerivedUnitDefinition", 
    "    UnitDefinition const * InitialAssignment.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * InitialAssignment.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_containsUndeclaredUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_containsUndeclaredUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_InitialAssignment_containsUndeclaredUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_containsUndeclaredUnits__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_containsUndeclaredUnits__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "InitialAssignment.containsUndeclaredUnits", 
    "    bool InitialAssignment.containsUndeclaredUnits()\n"
    "    bool InitialAssignment.containsUndeclaredUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getTypeCode(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (int)((InitialAssignment const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getElementName(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InitialAssignment_getId(int argc, VALUE *argv, VALUE self) {
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "InitialAssignment const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfInitialAssignments;

SWIGINTERN VALUE
_wrap_new_ListOfInitialAssignments__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfInitialAssignments", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfInitialAssignments", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfInitialAssignments *)new ListOfInitialAssignments(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfInitialAssignments_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfInitialAssignments);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfInitialAssignments__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfInitialAssignments", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfInitialAssignments *)new ListOfInitialAssignments(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfInitialAssignments(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfInitialAssignments__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfInitialAssignments__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfInitialAssignments.new", 
    "    ListOfInitialAssignments.new(unsigned int level, unsigned int version)\n"
    "    ListOfInitialAssignments.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfInitialAssignments.clone

  call-seq:
    clone -> ListOfInitialAssignments

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_clone(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (ListOfInitialAssignments *)((ListOfInitialAssignments const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (int)((ListOfInitialAssignments const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (int)((ListOfInitialAssignments const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (std::string *) &((ListOfInitialAssignments const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)((ListOfInitialAssignments const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)((ListOfInitialAssignments const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfInitialAssignments_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfInitialAssignments.get", 
    "    InitialAssignment const * ListOfInitialAssignments.get(unsigned int n)\n"
    "    InitialAssignment const * ListOfInitialAssignments.get(unsigned int n)\n"
    "    InitialAssignment const * ListOfInitialAssignments.get(std::string const &sid)\n"
    "    InitialAssignment const * ListOfInitialAssignments.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfInitialAssignments_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  InitialAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfInitialAssignments *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfInitialAssignments_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfInitialAssignments(ListOfInitialAssignments *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassRule;

SWIGINTERN void
free_Rule(Rule *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Rule_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Rule_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Rule);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Rule(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Rule *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Rule,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const &","Rule", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Rule const &","Rule", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (Rule *)new Rule((Rule const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::Rule.clone

  call-seq:
    clone -> Rule

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Rule_clone(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (Rule *)((Rule const *)arg1)->clone();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getFormula(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getFormula", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getFormula();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getMath(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (ASTNode *)((Rule const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getVariable(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getVariable", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getVariable();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getUnits(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isSetFormula(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isSetFormula", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetFormula();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isSetMath(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isSetVariable(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isSetVariable", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetVariable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isSetUnits(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isSetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_setFormula(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","setFormula", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setFormula", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setFormula", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFormula((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_setMath(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_setVariable(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","setVariable", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setVariable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setVariable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVariable((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_setUnits(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","setUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_unsetUnits(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","unsetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (int)(arg1)->unsetUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (UnitDefinition *)((Rule const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Rule_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Rule.getDerivedUnitDefinition", 
    "    UnitDefinition const * Rule.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * Rule.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_containsUndeclaredUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_containsUndeclaredUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Rule_containsUndeclaredUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_containsUndeclaredUnits__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_containsUndeclaredUnits__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Rule.containsUndeclaredUnits", 
    "    bool Rule.containsUndeclaredUnits()\n"
    "    bool Rule.containsUndeclaredUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getType(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RuleType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getType", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (RuleType_t)((Rule const *)arg1)->getType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isAlgebraic(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isAlgebraic", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isAlgebraic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isAssignment(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isAssignment();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isCompartmentVolume(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isCompartmentVolume", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isCompartmentVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isParameter(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isParameter();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isRate(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isRate", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isRate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isScalar(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isScalar", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isScalar();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_isSpeciesConcentration(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","isSpeciesConcentration", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSpeciesConcentration();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (int)((Rule const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getL1TypeCode(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getL1TypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (int)((Rule const *)arg1)->getL1TypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getElementName(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_setL1TypeCode(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule *","setL1TypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setL1TypeCode", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setL1TypeCode(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Rule_getId(int argc, VALUE *argv, VALUE self) {
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Rule const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassAlgebraicRule;

SWIGINTERN VALUE
_wrap_new_AlgebraicRule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","AlgebraicRule", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","AlgebraicRule", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (AlgebraicRule *)new AlgebraicRule(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AlgebraicRule_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AlgebraicRule_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AlgebraicRule);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AlgebraicRule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","AlgebraicRule", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (AlgebraicRule *)new AlgebraicRule(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AlgebraicRule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AlgebraicRule__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_AlgebraicRule__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "AlgebraicRule.new", 
    "    AlgebraicRule.new(unsigned int level, unsigned int version)\n"
    "    AlgebraicRule.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}


SWIGINTERN void
free_AlgebraicRule(AlgebraicRule *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/*
  Document-method: LibSBML::AlgebraicRule.clone

  call-seq:
    clone -> AlgebraicRule

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_AlgebraicRule_clone(int argc, VALUE *argv, VALUE self) {
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AlgebraicRule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "AlgebraicRule const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  result = (AlgebraicRule *)((AlgebraicRule const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AlgebraicRule_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "AlgebraicRule const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  result = (bool)((AlgebraicRule const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassAssignmentRule;

SWIGINTERN VALUE
_wrap_new_AssignmentRule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  AssignmentRule *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","AssignmentRule", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","AssignmentRule", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (AssignmentRule *)new AssignmentRule(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AssignmentRule_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AssignmentRule_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_AssignmentRule);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AssignmentRule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AssignmentRule *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","AssignmentRule", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (AssignmentRule *)new AssignmentRule(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AssignmentRule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AssignmentRule__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_AssignmentRule__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "AssignmentRule.new", 
    "    AssignmentRule.new(unsigned int level, unsigned int version)\n"
    "    AssignmentRule.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}


SWIGINTERN void
free_AssignmentRule(AssignmentRule *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/*
  Document-method: LibSBML::AssignmentRule.clone

  call-seq:
    clone -> AssignmentRule

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_AssignmentRule_clone(int argc, VALUE *argv, VALUE self) {
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AssignmentRule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_AssignmentRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "AssignmentRule const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  result = (AssignmentRule *)((AssignmentRule const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AssignmentRule_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_AssignmentRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "AssignmentRule const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  result = (bool)((AssignmentRule const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRateRule;

SWIGINTERN VALUE
_wrap_new_RateRule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  RateRule *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","RateRule", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","RateRule", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (RateRule *)new RateRule(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RateRule_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RateRule_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_RateRule);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RateRule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RateRule *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","RateRule", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (RateRule *)new RateRule(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RateRule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RateRule__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_RateRule__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RateRule.new", 
    "    RateRule.new(unsigned int level, unsigned int version)\n"
    "    RateRule.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}


SWIGINTERN void
free_RateRule(RateRule *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/*
  Document-method: LibSBML::RateRule.clone

  call-seq:
    clone -> RateRule

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_RateRule_clone(int argc, VALUE *argv, VALUE self) {
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RateRule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RateRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "RateRule const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  result = (RateRule *)((RateRule const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RateRule_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RateRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "RateRule const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  result = (bool)((RateRule const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfRules;

SWIGINTERN VALUE
_wrap_new_ListOfRules__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfRules *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfRules", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfRules", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfRules *)new ListOfRules(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfRules_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfRules_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfRules);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfRules__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfRules *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfRules", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfRules *)new ListOfRules(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfRules(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfRules__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfRules__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfRules.new", 
    "    ListOfRules.new(unsigned int level, unsigned int version)\n"
    "    ListOfRules.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfRules.clone

  call-seq:
    clone -> ListOfRules

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfRules_clone(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfRules *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (ListOfRules *)((ListOfRules const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (int)((ListOfRules const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (int)((ListOfRules const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (std::string *) &((ListOfRules const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->get(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)((ListOfRules const *)arg1)->get(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->get((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Rule *)((ListOfRules const *)arg1)->get((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfRules_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfRules.get", 
    "    Rule const * ListOfRules.get(unsigned int n)\n"
    "    Rule const * ListOfRules.get(unsigned int n)\n"
    "    Rule const * ListOfRules.get(std::string const &sid)\n"
    "    Rule const * ListOfRules.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->remove(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfRules_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Rule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfRules *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->remove((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfRules_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfRules(ListOfRules *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassConstraint;

SWIGINTERN VALUE
_wrap_new_Constraint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Constraint", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Constraint", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Constraint *)new Constraint(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Constraint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Constraint *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Constraint", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Constraint *)new Constraint(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Constraint(Constraint *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Constraint_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Constraint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Constraint);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Constraint__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Constraint *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Constraint,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const &","Constraint", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Constraint const &","Constraint", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  {
    try {
      result = (Constraint *)new Constraint((Constraint const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Constraint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Constraint__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Constraint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Constraint__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Constraint__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Constraint.new", 
    "    Constraint.new(unsigned int level, unsigned int version)\n"
    "    Constraint.new(SBMLNamespaces *sbmlns)\n"
    "    Constraint.new(Constraint const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Constraint.clone

  call-seq:
    clone -> Constraint

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Constraint_clone(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (Constraint *)((Constraint const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_getMessage(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","getMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (XMLNode *)((Constraint const *)arg1)->getMessage();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_getMessageString(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","getMessageString", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = ((Constraint const *)arg1)->getMessageString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_getMath(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (ASTNode *)((Constraint const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_isSetMessage(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","isSetMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->isSetMessage();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_isSetMath(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_setMessage(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint *","setMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","setMessage", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setMessage((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_setMath(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_unsetMessage(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint *","unsetMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (int)(arg1)->unsetMessage();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (int)((Constraint const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_getElementName(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (std::string *) &((Constraint const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Constraint_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Constraint const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfConstraints;

SWIGINTERN VALUE
_wrap_new_ListOfConstraints__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfConstraints", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfConstraints", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfConstraints *)new ListOfConstraints(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfConstraints_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfConstraints_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfConstraints);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfConstraints__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfConstraints", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfConstraints *)new ListOfConstraints(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfConstraints(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfConstraints__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfConstraints__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfConstraints.new", 
    "    ListOfConstraints.new(unsigned int level, unsigned int version)\n"
    "    ListOfConstraints.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfConstraints.clone

  call-seq:
    clone -> ListOfConstraints

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfConstraints_clone(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfConstraints *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (ListOfConstraints *)((ListOfConstraints const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfConstraints_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (int)((ListOfConstraints const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfConstraints_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (int)((ListOfConstraints const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfConstraints_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (std::string *) &((ListOfConstraints const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfConstraints_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfConstraints_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)((ListOfConstraints const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfConstraints_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfConstraints, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfConstraints_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfConstraints, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfConstraints_get__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfConstraints.get", 
    "    Constraint const * ListOfConstraints.get(unsigned int n)\n"
    "    Constraint const * ListOfConstraints.get(unsigned int n)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfConstraints_remove(int argc, VALUE *argv, VALUE self) {
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Constraint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfConstraints *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_ListOfConstraints(ListOfConstraints *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassReaction;

SWIGINTERN VALUE
_wrap_new_Reaction__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Reaction", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Reaction", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Reaction *)new Reaction(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Reaction__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Reaction *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Reaction", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Reaction *)new Reaction(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Reaction(Reaction *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Reaction_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Reaction_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Reaction);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Reaction__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Reaction *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Reaction,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const &","Reaction", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Reaction const &","Reaction", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    try {
      result = (Reaction *)new Reaction((Reaction const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Reaction(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Reaction__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Reaction__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Reaction__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Reaction.new", 
    "    Reaction.new(unsigned int level, unsigned int version)\n"
    "    Reaction.new(SBMLNamespaces *sbmlns)\n"
    "    Reaction.new(Reaction const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Reaction.clone

  call-seq:
    clone -> Reaction

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Reaction_clone(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (Reaction *)((Reaction const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_initDefaults(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","initDefaults", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  (arg1)->initDefaults();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getId(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getName(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getKineticLaw__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)((Reaction const *)arg1)->getKineticLaw();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getKineticLaw__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)(arg1)->getKineticLaw();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getKineticLaw(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getKineticLaw__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getKineticLaw__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Reaction.getKineticLaw", 
    "    KineticLaw * Reaction.getKineticLaw()\n"
    "    KineticLaw * Reaction.getKineticLaw()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getReversible(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getReversible", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->getReversible();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getFast(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getFast", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->getFast();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getCompartment(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getCompartment();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_isSetId(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_isSetName(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_isSetKineticLaw(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","isSetKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetKineticLaw();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_isSetFast(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","isSetFast", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetFast();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_isSetCompartment(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","isSetCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetCompartment();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_isSetReversible(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","isSetReversible", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetReversible();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_setId(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_setName(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_setKineticLaw(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  KineticLaw *arg2 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","setKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "KineticLaw const *","setKineticLaw", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< KineticLaw * >(argp2);
  result = (int)(arg1)->setKineticLaw((KineticLaw const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_setReversible(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","setReversible", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setReversible", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setReversible(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_setFast(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","setFast", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setFast", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setFast(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_setCompartment(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","setCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setCompartment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setCompartment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartment((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_unsetName(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_unsetKineticLaw(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","unsetKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetKineticLaw();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_unsetFast(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","unsetFast", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetFast();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_unsetCompartment(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","unsetCompartment", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetCompartment();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_addReactant(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  SpeciesReference *arg2 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","addReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SpeciesReference const *","addReactant", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SpeciesReference * >(argp2);
  result = (int)(arg1)->addReactant((SpeciesReference const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_addProduct(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  SpeciesReference *arg2 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","addProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SpeciesReference const *","addProduct", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SpeciesReference * >(argp2);
  result = (int)(arg1)->addProduct((SpeciesReference const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_addModifier(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  ModifierSpeciesReference *arg2 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","addModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ModifierSpeciesReference const *","addModifier", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ModifierSpeciesReference * >(argp2);
  result = (int)(arg1)->addModifier((ModifierSpeciesReference const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_createReactant(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","createReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SpeciesReference *)(arg1)->createReactant();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_createProduct(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","createProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SpeciesReference *)(arg1)->createProduct();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_createModifier(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","createModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ModifierSpeciesReference *)(arg1)->createModifier();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_createKineticLaw(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","createKineticLaw", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)(arg1)->createKineticLaw();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getListOfReactants__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getListOfReactants", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfReactants();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getListOfReactants__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getListOfReactants", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfReactants();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getListOfReactants(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfReactants__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfReactants__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Reaction.getListOfReactants", 
    "    ListOfSpeciesReferences * Reaction.getListOfReactants()\n"
    "    ListOfSpeciesReferences * Reaction.getListOfReactants()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getListOfProducts__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getListOfProducts", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfProducts();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getListOfProducts__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getListOfProducts", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfProducts();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getListOfProducts(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfProducts__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfProducts__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Reaction.getListOfProducts", 
    "    ListOfSpeciesReferences * Reaction.getListOfProducts()\n"
    "    ListOfSpeciesReferences * Reaction.getListOfProducts()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getListOfModifiers__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getListOfModifiers", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfModifiers();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getListOfModifiers__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getListOfModifiers", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfModifiers();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getListOfModifiers(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfModifiers__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfModifiers__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Reaction.getListOfModifiers", 
    "    ListOfSpeciesReferences * Reaction.getListOfModifiers()\n"
    "    ListOfSpeciesReferences * Reaction.getListOfModifiers()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getReactant__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getReactant", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)((Reaction const *)arg1)->getReactant(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getReactant__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getReactant", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->getReactant(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getReactant__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getReactant", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getReactant", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Reaction const *)arg1)->getReactant((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getReactant__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getReactant", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getReactant", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getReactant((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getReactant(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Reaction.getReactant", 
    "    SpeciesReference * Reaction.getReactant(unsigned int n)\n"
    "    SpeciesReference * Reaction.getReactant(unsigned int n)\n"
    "    SpeciesReference * Reaction.getReactant(std::string const &species)\n"
    "    SpeciesReference * Reaction.getReactant(std::string const &species)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getProduct__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getProduct", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)((Reaction const *)arg1)->getProduct(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getProduct__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getProduct", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->getProduct(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getProduct__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getProduct", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getProduct", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Reaction const *)arg1)->getProduct((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getProduct__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getProduct", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getProduct", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getProduct((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getProduct(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Reaction.getProduct", 
    "    SpeciesReference * Reaction.getProduct(unsigned int n)\n"
    "    SpeciesReference * Reaction.getProduct(unsigned int n)\n"
    "    SpeciesReference * Reaction.getProduct(std::string const &species)\n"
    "    SpeciesReference * Reaction.getProduct(std::string const &species)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getModifier__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getModifier", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)((Reaction const *)arg1)->getModifier(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getModifier__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getModifier", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)(arg1)->getModifier(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getModifier__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getModifier", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getModifier", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)((Reaction const *)arg1)->getModifier((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getModifier__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","getModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getModifier", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getModifier", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)(arg1)->getModifier((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_getModifier(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Reaction.getModifier", 
    "    ModifierSpeciesReference * Reaction.getModifier(unsigned int n)\n"
    "    ModifierSpeciesReference * Reaction.getModifier(unsigned int n)\n"
    "    ModifierSpeciesReference * Reaction.getModifier(std::string const &species)\n"
    "    ModifierSpeciesReference * Reaction.getModifier(std::string const &species)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getNumReactants(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getNumReactants", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumReactants();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getNumProducts(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getNumProducts", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumProducts();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getNumModifiers(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getNumModifiers", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumModifiers();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_removeReactant__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","removeReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeReactant", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->removeReactant(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_removeReactant__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","removeReactant", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeReactant", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeReactant", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->removeReactant((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_removeReactant(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeReactant__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeReactant__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeReactant.new", 
    "    removeReactant.new(unsigned int n)\n"
    "    removeReactant.new(std::string const &species)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_removeProduct__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","removeProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeProduct", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->removeProduct(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_removeProduct__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","removeProduct", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeProduct", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeProduct", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->removeProduct((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_removeProduct(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeProduct__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeProduct__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeProduct.new", 
    "    removeProduct.new(unsigned int n)\n"
    "    removeProduct.new(std::string const &species)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_removeModifier__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","removeModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeModifier", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)(arg1)->removeModifier(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_removeModifier__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","removeModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeModifier", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeModifier", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)(arg1)->removeModifier((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Reaction_removeModifier(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeModifier__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeModifier__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeModifier.new", 
    "    removeModifier.new(unsigned int n)\n"
    "    removeModifier.new(std::string const &species)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_connectToChild(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)((Reaction const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_getElementName(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Reaction_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Reaction const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfReactions;

SWIGINTERN VALUE
_wrap_new_ListOfReactions__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfReactions *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfReactions", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfReactions", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfReactions *)new ListOfReactions(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfReactions_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfReactions_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfReactions);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfReactions__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfReactions *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfReactions", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfReactions *)new ListOfReactions(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfReactions(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfReactions__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfReactions__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfReactions.new", 
    "    ListOfReactions.new(unsigned int level, unsigned int version)\n"
    "    ListOfReactions.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfReactions.clone

  call-seq:
    clone -> ListOfReactions

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfReactions_clone(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfReactions *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (ListOfReactions *)((ListOfReactions const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (int)((ListOfReactions const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (int)((ListOfReactions const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (std::string *) &((ListOfReactions const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)((ListOfReactions const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)((ListOfReactions const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfReactions_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfReactions.get", 
    "    Reaction const * ListOfReactions.get(unsigned int n)\n"
    "    Reaction const * ListOfReactions.get(unsigned int n)\n"
    "    Reaction const * ListOfReactions.get(std::string const &sid)\n"
    "    Reaction const * ListOfReactions.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfReactions_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Reaction *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfReactions *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfReactions_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfReactions(ListOfReactions *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassKineticLaw;

SWIGINTERN VALUE
_wrap_new_KineticLaw__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  KineticLaw *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","KineticLaw", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","KineticLaw", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (KineticLaw *)new KineticLaw(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_KineticLaw__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","KineticLaw", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (KineticLaw *)new KineticLaw(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_KineticLaw(KineticLaw *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_KineticLaw_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_KineticLaw_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_KineticLaw);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_KineticLaw__SWIG_2(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_KineticLaw,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const &","KineticLaw", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "KineticLaw const &","KineticLaw", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    try {
      result = (KineticLaw *)new KineticLaw((KineticLaw const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_KineticLaw(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_KineticLaw__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_KineticLaw__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_KineticLaw__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "KineticLaw.new", 
    "    KineticLaw.new(unsigned int level, unsigned int version)\n"
    "    KineticLaw.new(SBMLNamespaces *sbmlns)\n"
    "    KineticLaw.new(KineticLaw const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::KineticLaw.clone

  call-seq:
    clone -> KineticLaw

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_KineticLaw_clone(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  KineticLaw *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (KineticLaw *)((KineticLaw const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getFormula(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getFormula", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getFormula();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getMath(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ASTNode *)((KineticLaw const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getTimeUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getTimeUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getSubstanceUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_isSetFormula(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","isSetFormula", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetFormula();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_isSetMath(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_isSetTimeUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","isSetTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetTimeUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_isSetSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","isSetSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetSubstanceUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_setFormula(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","setFormula", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setFormula", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setFormula", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFormula((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_setMath(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_setTimeUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","setTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setTimeUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setTimeUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_setSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","setSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSubstanceUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSubstanceUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_unsetTimeUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","unsetTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_unsetSubstanceUnits(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","unsetSubstanceUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_addParameter(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  Parameter *arg2 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","addParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Parameter const *","addParameter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Parameter * >(argp2);
  result = (int)(arg1)->addParameter((Parameter const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_addLocalParameter(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  LocalParameter *arg2 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","addLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "LocalParameter const *","addLocalParameter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< LocalParameter * >(argp2);
  result = (int)(arg1)->addLocalParameter((LocalParameter const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_createParameter(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","createParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (Parameter *)(arg1)->createParameter();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_createLocalParameter(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","createLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (LocalParameter *)(arg1)->createLocalParameter();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getListOfParameters__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getListOfParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfParameters *)((KineticLaw const *)arg1)->getListOfParameters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getListOfParameters__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getListOfParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfParameters *)(arg1)->getListOfParameters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_getListOfParameters(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfParameters__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfParameters__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "KineticLaw.getListOfParameters", 
    "    ListOfParameters * KineticLaw.getListOfParameters()\n"
    "    ListOfParameters * KineticLaw.getListOfParameters()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getListOfLocalParameters__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfLocalParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getListOfLocalParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfLocalParameters *)((KineticLaw const *)arg1)->getListOfLocalParameters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getListOfLocalParameters__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfLocalParameters *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getListOfLocalParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfLocalParameters *)(arg1)->getListOfLocalParameters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_getListOfLocalParameters(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfLocalParameters__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfLocalParameters__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "KineticLaw.getListOfLocalParameters", 
    "    ListOfLocalParameters * KineticLaw.getListOfLocalParameters()\n"
    "    ListOfLocalParameters * KineticLaw.getListOfLocalParameters()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((KineticLaw const *)arg1)->getParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->getParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getLocalParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getLocalParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)((KineticLaw const *)arg1)->getLocalParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getLocalParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getLocalParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->getLocalParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getParameter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((KineticLaw const *)arg1)->getParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getParameter__SWIG_3(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->getParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_getParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "KineticLaw.getParameter", 
    "    Parameter * KineticLaw.getParameter(unsigned int n)\n"
    "    Parameter * KineticLaw.getParameter(unsigned int n)\n"
    "    Parameter * KineticLaw.getParameter(std::string const &sid)\n"
    "    Parameter * KineticLaw.getParameter(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getLocalParameter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getLocalParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getLocalParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)((KineticLaw const *)arg1)->getLocalParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getLocalParameter__SWIG_3(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getLocalParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getLocalParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->getLocalParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_getLocalParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "KineticLaw.getLocalParameter", 
    "    LocalParameter * KineticLaw.getLocalParameter(unsigned int n)\n"
    "    LocalParameter * KineticLaw.getLocalParameter(unsigned int n)\n"
    "    LocalParameter * KineticLaw.getLocalParameter(std::string const &sid)\n"
    "    LocalParameter * KineticLaw.getLocalParameter(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getNumParameters(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getNumParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (unsigned int)((KineticLaw const *)arg1)->getNumParameters();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getNumLocalParameters(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getNumLocalParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (unsigned int)((KineticLaw const *)arg1)->getNumLocalParameters();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (UnitDefinition *)((KineticLaw const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "KineticLaw.getDerivedUnitDefinition", 
    "    UnitDefinition const * KineticLaw.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * KineticLaw.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_containsUndeclaredUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_containsUndeclaredUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_containsUndeclaredUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_containsUndeclaredUnits__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_containsUndeclaredUnits__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "KineticLaw.containsUndeclaredUnits", 
    "    bool KineticLaw.containsUndeclaredUnits()\n"
    "    bool KineticLaw.containsUndeclaredUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_removeParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","removeParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->removeParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_removeLocalParameter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","removeLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeLocalParameter", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->removeLocalParameter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_removeParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Parameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","removeParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->removeParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_removeParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_removeParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_removeParameter__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeParameter.new", 
    "    removeParameter.new(unsigned int n)\n"
    "    removeParameter.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_removeLocalParameter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  LocalParameter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","removeLocalParameter", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeLocalParameter", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeLocalParameter", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->removeLocalParameter((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_KineticLaw_removeLocalParameter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_removeLocalParameter__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_removeLocalParameter__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeLocalParameter.new", 
    "    removeLocalParameter.new(unsigned int n)\n"
    "    removeLocalParameter.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_connectToChild(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getTypeCode(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)((KineticLaw const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_getElementName(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_KineticLaw_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "KineticLaw const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSimpleSpeciesReference;

SWIGINTERN void
free_SimpleSpeciesReference(SimpleSpeciesReference *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_getId(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_getName(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_getSpecies(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","getSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getSpecies();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_isSetId(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_isSetName(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_isSetSpecies(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","isSetSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetSpecies();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_setSpecies(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference *","setSpecies", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setSpecies", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setSpecies", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpecies((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_setId(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_setName(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_unsetId(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference *","unsetId", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (int)(arg1)->unsetId();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_unsetName(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SimpleSpeciesReference_isModifier(int argc, VALUE *argv, VALUE self) {
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SimpleSpeciesReference const *","isModifier", 1, self )); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isModifier();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSpeciesReference;

SWIGINTERN VALUE
_wrap_new_SpeciesReference__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SpeciesReference *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SpeciesReference", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SpeciesReference", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SpeciesReference__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","SpeciesReference", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SpeciesReference(SpeciesReference *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SpeciesReference_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SpeciesReference_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SpeciesReference);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SpeciesReference__SWIG_2(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SpeciesReference,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const &","SpeciesReference", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SpeciesReference const &","SpeciesReference", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference((SpeciesReference const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SpeciesReference(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesReference__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesReference__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SpeciesReference__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SpeciesReference.new", 
    "    SpeciesReference.new(unsigned int level, unsigned int version)\n"
    "    SpeciesReference.new(SBMLNamespaces *sbmlns)\n"
    "    SpeciesReference.new(SpeciesReference const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::SpeciesReference.clone

  call-seq:
    clone -> SpeciesReference

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SpeciesReference_clone(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (SpeciesReference *)((SpeciesReference const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_initDefaults(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","initDefaults", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  (arg1)->initDefaults();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getStoichiometry(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","getStoichiometry", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (double)((SpeciesReference const *)arg1)->getStoichiometry();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getStoichiometryMath__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StoichiometryMath *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","getStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)((SpeciesReference const *)arg1)->getStoichiometryMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getStoichiometryMath__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StoichiometryMath *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","getStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)(arg1)->getStoichiometryMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SpeciesReference_getStoichiometryMath(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SpeciesReference_getStoichiometryMath__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SpeciesReference_getStoichiometryMath__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SpeciesReference.getStoichiometryMath", 
    "    StoichiometryMath * SpeciesReference.getStoichiometryMath()\n"
    "    StoichiometryMath * SpeciesReference.getStoichiometryMath()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getDenominator(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","getDenominator", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)((SpeciesReference const *)arg1)->getDenominator();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getConstant(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","getConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->getConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_isSetStoichiometryMath(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","isSetStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetStoichiometryMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_isSetConstant(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","isSetConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_isSetStoichiometry(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","isSetStoichiometry", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetStoichiometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_setStoichiometry(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","setStoichiometry", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setStoichiometry", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setStoichiometry(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_setStoichiometryMath(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  StoichiometryMath *arg2 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","setStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "StoichiometryMath const *","setStoichiometryMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< StoichiometryMath * >(argp2);
  result = (int)(arg1)->setStoichiometryMath((StoichiometryMath const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_setDenominator(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","setDenominator", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setDenominator", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setDenominator(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_setConstant(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","setConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setConstant", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_unsetStoichiometryMath(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","unsetStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)(arg1)->unsetStoichiometryMath();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_unsetStoichiometry(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","unsetStoichiometry", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)(arg1)->unsetStoichiometry();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_createStoichiometryMath(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StoichiometryMath *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","createStoichiometryMath", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)(arg1)->createStoichiometryMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_setAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","setAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","setAnnotation", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_setAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","setAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setAnnotation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setAnnotation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SpeciesReference_setAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_setAnnotation__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_setAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SpeciesReference.setAnnotation", 
    "    int SpeciesReference.setAnnotation(XMLNode const *annotation)\n"
    "    int SpeciesReference.setAnnotation(std::string const &annotation)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_appendAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","appendAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const *","appendAnnotation", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_appendAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference *","appendAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","appendAnnotation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","appendAnnotation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SpeciesReference_appendAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_appendAnnotation__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_appendAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SpeciesReference.appendAnnotation", 
    "    int SpeciesReference.appendAnnotation(XMLNode const *annotation)\n"
    "    int SpeciesReference.appendAnnotation(std::string const &annotation)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getTypeCode(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)((SpeciesReference const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_getElementName(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (std::string *) &((SpeciesReference const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SpeciesReference_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SpeciesReference const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassModifierSpeciesReference;

SWIGINTERN VALUE
_wrap_new_ModifierSpeciesReference__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ModifierSpeciesReference", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ModifierSpeciesReference", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (ModifierSpeciesReference *)new ModifierSpeciesReference(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ModifierSpeciesReference_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ModifierSpeciesReference_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ModifierSpeciesReference);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ModifierSpeciesReference__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ModifierSpeciesReference", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (ModifierSpeciesReference *)new ModifierSpeciesReference(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ModifierSpeciesReference(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModifierSpeciesReference__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ModifierSpeciesReference__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ModifierSpeciesReference.new", 
    "    ModifierSpeciesReference.new(unsigned int level, unsigned int version)\n"
    "    ModifierSpeciesReference.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ModifierSpeciesReference(ModifierSpeciesReference *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/*
  Document-method: LibSBML::ModifierSpeciesReference.clone

  call-seq:
    clone -> ModifierSpeciesReference

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ModifierSpeciesReference_clone(int argc, VALUE *argv, VALUE self) {
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModifierSpeciesReference const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (ModifierSpeciesReference *)((ModifierSpeciesReference const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModifierSpeciesReference_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModifierSpeciesReference const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (int)((ModifierSpeciesReference const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModifierSpeciesReference_getElementName(int argc, VALUE *argv, VALUE self) {
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModifierSpeciesReference const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (std::string *) &((ModifierSpeciesReference const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModifierSpeciesReference_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModifierSpeciesReference const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (bool)((ModifierSpeciesReference const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfSpeciesReferences;

SWIGINTERN VALUE
_wrap_new_ListOfSpeciesReferences__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfSpeciesReferences", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfSpeciesReferences", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfSpeciesReferences *)new ListOfSpeciesReferences(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfSpeciesReferences_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfSpeciesReferences);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfSpeciesReferences__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfSpeciesReferences", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfSpeciesReferences *)new ListOfSpeciesReferences(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfSpeciesReferences(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfSpeciesReferences__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfSpeciesReferences__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfSpeciesReferences.new", 
    "    ListOfSpeciesReferences.new(unsigned int level, unsigned int version)\n"
    "    ListOfSpeciesReferences.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfSpeciesReferences.clone

  call-seq:
    clone -> ListOfSpeciesReferences

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_clone(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (ListOfSpeciesReferences *)((ListOfSpeciesReferences const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (int)((ListOfSpeciesReferences const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (int)((ListOfSpeciesReferences const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (std::string *) &((ListOfSpeciesReferences const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)(arg1)->get(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)((ListOfSpeciesReferences const *)arg1)->get(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SimpleSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)(arg1)->get((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SimpleSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)((ListOfSpeciesReferences const *)arg1)->get((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfSpeciesReferences_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfSpeciesReferences.get", 
    "    SimpleSpeciesReference const * ListOfSpeciesReferences.get(unsigned int n)\n"
    "    SimpleSpeciesReference const * ListOfSpeciesReferences.get(unsigned int n)\n"
    "    SimpleSpeciesReference const * ListOfSpeciesReferences.get(std::string const &sid)\n"
    "    SimpleSpeciesReference const * ListOfSpeciesReferences.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)(arg1)->remove(arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfSpeciesReferences_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SimpleSpeciesReference *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfSpeciesReferences *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)(arg1)->remove((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfSpeciesReferences_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfSpeciesReferences(ListOfSpeciesReferences *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassEvent;

SWIGINTERN VALUE
_wrap_new_Event__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Event", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Event", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Event *)new Event(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Event__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Event *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Event", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Event *)new Event(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Event(Event *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Event_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Event_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Event);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Event__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Event *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Event,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const &","Event", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Event const &","Event", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    try {
      result = (Event *)new Event((Event const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Event(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Event__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Event__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Event__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Event.new", 
    "    Event.new(unsigned int level, unsigned int version)\n"
    "    Event.new(SBMLNamespaces *sbmlns)\n"
    "    Event.new(Event const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Event.clone

  call-seq:
    clone -> Event

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Event_clone(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Event *)((Event const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getId(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getName(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getTrigger__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getTrigger", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)((Event const *)arg1)->getTrigger();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getTrigger__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","getTrigger", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)(arg1)->getTrigger();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Event_getTrigger(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getTrigger__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getTrigger__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Event.getTrigger", 
    "    Trigger * Event.getTrigger()\n"
    "    Trigger * Event.getTrigger()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getDelay__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)((Event const *)arg1)->getDelay();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getDelay__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","getDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)(arg1)->getDelay();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Event_getDelay(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getDelay__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getDelay__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Event.getDelay", 
    "    Delay * Event.getDelay()\n"
    "    Delay * Event.getDelay()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getPriority__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Priority *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getPriority", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Priority *)((Event const *)arg1)->getPriority();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getPriority__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Priority *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","getPriority", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Priority *)(arg1)->getPriority();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Event_getPriority(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getPriority__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getPriority__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Event.getPriority", 
    "    Priority * Event.getPriority()\n"
    "    Priority * Event.getPriority()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getTimeUnits(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getTimeUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getUseValuesFromTriggerTime(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getUseValuesFromTriggerTime", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->getUseValuesFromTriggerTime();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetId(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetId();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetName(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetTrigger(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetTrigger", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetTrigger();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetDelay(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetDelay();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetPriority(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetPriority", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetPriority();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetTimeUnits(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetTimeUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_isSetUseValuesFromTriggerTime(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","isSetUseValuesFromTriggerTime", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetUseValuesFromTriggerTime();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setId(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setId", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setId", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setId", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setName(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setTrigger(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  Trigger *arg2 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setTrigger", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Trigger const *","setTrigger", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Trigger * >(argp2);
  result = (int)(arg1)->setTrigger((Trigger const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setDelay(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  Delay *arg2 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Delay const *","setDelay", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Delay * >(argp2);
  result = (int)(arg1)->setDelay((Delay const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setPriority(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  Priority *arg2 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setPriority", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Priority const *","setPriority", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Priority * >(argp2);
  result = (int)(arg1)->setPriority((Priority const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setTimeUnits(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setTimeUnits", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setTimeUnits", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_setUseValuesFromTriggerTime(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","setUseValuesFromTriggerTime", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setUseValuesFromTriggerTime", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setUseValuesFromTriggerTime(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_unsetId(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","unsetId", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetId();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_unsetName(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","unsetName", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_unsetDelay(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","unsetDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetDelay();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_unsetPriority(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","unsetPriority", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetPriority();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_unsetTimeUnits(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","unsetTimeUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_addEventAssignment(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  EventAssignment *arg2 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","addEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "EventAssignment const *","addEventAssignment", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< EventAssignment * >(argp2);
  result = (int)(arg1)->addEventAssignment((EventAssignment const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_createEventAssignment(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","createEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (EventAssignment *)(arg1)->createEventAssignment();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_createTrigger(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","createTrigger", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)(arg1)->createTrigger();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_createDelay(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","createDelay", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)(arg1)->createDelay();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_createPriority(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Priority *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","createPriority", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Priority *)(arg1)->createPriority();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getListOfEventAssignments__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEventAssignments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getListOfEventAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (ListOfEventAssignments *)((Event const *)arg1)->getListOfEventAssignments();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getListOfEventAssignments__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEventAssignments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","getListOfEventAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (ListOfEventAssignments *)(arg1)->getListOfEventAssignments();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Event_getListOfEventAssignments(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getListOfEventAssignments__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getListOfEventAssignments__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Event.getListOfEventAssignments", 
    "    ListOfEventAssignments * Event.getListOfEventAssignments()\n"
    "    ListOfEventAssignments * Event.getListOfEventAssignments()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getEventAssignment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getEventAssignment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)((Event const *)arg1)->getEventAssignment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getEventAssignment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","getEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getEventAssignment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->getEventAssignment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getEventAssignment__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getEventAssignment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getEventAssignment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)((Event const *)arg1)->getEventAssignment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getEventAssignment__SWIG_3(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","getEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getEventAssignment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getEventAssignment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->getEventAssignment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Event_getEventAssignment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Event.getEventAssignment", 
    "    EventAssignment * Event.getEventAssignment(unsigned int n)\n"
    "    EventAssignment * Event.getEventAssignment(unsigned int n)\n"
    "    EventAssignment * Event.getEventAssignment(std::string const &variable)\n"
    "    EventAssignment * Event.getEventAssignment(std::string const &variable)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getNumEventAssignments(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getNumEventAssignments", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (unsigned int)((Event const *)arg1)->getNumEventAssignments();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_removeEventAssignment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","removeEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeEventAssignment", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->removeEventAssignment(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_removeEventAssignment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","removeEventAssignment", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeEventAssignment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeEventAssignment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->removeEventAssignment((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_Event_removeEventAssignment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_removeEventAssignment__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_removeEventAssignment__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "removeEventAssignment.new", 
    "    removeEventAssignment.new(unsigned int n)\n"
    "    removeEventAssignment.new(std::string const &variable)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_connectToChild(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","connectToChild", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  (arg1)->connectToChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)((Event const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_getElementName(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Event_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Event const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfEvents;

SWIGINTERN VALUE
_wrap_new_ListOfEvents__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfEvents *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfEvents", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfEvents", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfEvents *)new ListOfEvents(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfEvents_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfEvents_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfEvents);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfEvents__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEvents *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfEvents", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfEvents *)new ListOfEvents(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfEvents(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfEvents__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfEvents__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfEvents.new", 
    "    ListOfEvents.new(unsigned int level, unsigned int version)\n"
    "    ListOfEvents.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfEvents.clone

  call-seq:
    clone -> ListOfEvents

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfEvents_clone(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEvents *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (ListOfEvents *)((ListOfEvents const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (int)((ListOfEvents const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (int)((ListOfEvents const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (std::string *) &((ListOfEvents const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)((ListOfEvents const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Event *)((ListOfEvents const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfEvents_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfEvents.get", 
    "    Event const * ListOfEvents.get(unsigned int n)\n"
    "    Event const * ListOfEvents.get(unsigned int n)\n"
    "    Event const * ListOfEvents.get(std::string const &sid)\n"
    "    Event const * ListOfEvents.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEvents_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  Event *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEvents *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfEvents_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfEvents(ListOfEvents *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassEventAssignment;

SWIGINTERN VALUE
_wrap_new_EventAssignment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","EventAssignment", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","EventAssignment", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (EventAssignment *)new EventAssignment(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_EventAssignment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  EventAssignment *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","EventAssignment", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (EventAssignment *)new EventAssignment(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_EventAssignment(EventAssignment *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_EventAssignment_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_EventAssignment_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_EventAssignment);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_EventAssignment__SWIG_2(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  EventAssignment *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_EventAssignment,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const &","EventAssignment", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "EventAssignment const &","EventAssignment", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  {
    try {
      result = (EventAssignment *)new EventAssignment((EventAssignment const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_EventAssignment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_EventAssignment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_EventAssignment__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_EventAssignment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "EventAssignment.new", 
    "    EventAssignment.new(unsigned int level, unsigned int version)\n"
    "    EventAssignment.new(SBMLNamespaces *sbmlns)\n"
    "    EventAssignment.new(EventAssignment const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::EventAssignment.clone

  call-seq:
    clone -> EventAssignment

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_EventAssignment_clone(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (EventAssignment *)((EventAssignment const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getVariable(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","getVariable", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getVariable();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getMath(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (ASTNode *)((EventAssignment const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_isSetVariable(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","isSetVariable", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->isSetVariable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_isSetMath(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_setVariable(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment *","setVariable", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setVariable", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setVariable", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVariable((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_setMath(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (UnitDefinition *)((EventAssignment const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_EventAssignment_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "EventAssignment.getDerivedUnitDefinition", 
    "    UnitDefinition const * EventAssignment.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * EventAssignment.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_containsUndeclaredUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_containsUndeclaredUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_EventAssignment_containsUndeclaredUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_containsUndeclaredUnits__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_containsUndeclaredUnits__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "EventAssignment.containsUndeclaredUnits", 
    "    bool EventAssignment.containsUndeclaredUnits()\n"
    "    bool EventAssignment.containsUndeclaredUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getTypeCode(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (int)((EventAssignment const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getElementName(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EventAssignment_getId(int argc, VALUE *argv, VALUE self) {
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "EventAssignment const *","getId", 1, self )); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getId();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListOfEventAssignments;

SWIGINTERN VALUE
_wrap_new_ListOfEventAssignments__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","ListOfEventAssignments", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","ListOfEventAssignments", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ListOfEventAssignments *)new ListOfEventAssignments(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListOfEventAssignments_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListOfEventAssignments_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ListOfEventAssignments);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListOfEventAssignments__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","ListOfEventAssignments", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (ListOfEventAssignments *)new ListOfEventAssignments(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListOfEventAssignments(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOfEventAssignments__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ListOfEventAssignments__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ListOfEventAssignments.new", 
    "    ListOfEventAssignments.new(unsigned int level, unsigned int version)\n"
    "    ListOfEventAssignments.new(SBMLNamespaces *sbmlns)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ListOfEventAssignments.clone

  call-seq:
    clone -> ListOfEventAssignments

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListOfEventAssignments_clone(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListOfEventAssignments *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (ListOfEventAssignments *)((ListOfEventAssignments const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_getTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (int)((ListOfEventAssignments const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_getItemTypeCode(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments const *","getItemTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (int)((ListOfEventAssignments const *)arg1)->getItemTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_getElementName(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (std::string *) &((ListOfEventAssignments const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_get__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_get__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","get", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)((ListOfEventAssignments const *)arg1)->get(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_get__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_get__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments const *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","get", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","get", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)((ListOfEventAssignments const *)arg1)->get((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfEventAssignments_get(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListOfEventAssignments.get", 
    "    EventAssignment const * ListOfEventAssignments.get(unsigned int n)\n"
    "    EventAssignment const * ListOfEventAssignments.get(unsigned int n)\n"
    "    EventAssignment const * ListOfEventAssignments.get(std::string const &sid)\n"
    "    EventAssignment const * ListOfEventAssignments.get(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->remove(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListOfEventAssignments_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  EventAssignment *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ListOfEventAssignments *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListOfEventAssignments_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(unsigned int n)\n"
    "    remove.new(std::string const &sid)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ListOfEventAssignments(ListOfEventAssignments *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassTrigger;

SWIGINTERN VALUE
_wrap_new_Trigger__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Trigger *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Trigger", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Trigger", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Trigger *)new Trigger(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Trigger__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Trigger", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Trigger *)new Trigger(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Trigger(Trigger *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Trigger_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Trigger_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Trigger);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Trigger__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Trigger,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const &","Trigger", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Trigger const &","Trigger", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  {
    try {
      result = (Trigger *)new Trigger((Trigger const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Trigger(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trigger__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Trigger, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trigger__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Trigger__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Trigger.new", 
    "    Trigger.new(unsigned int level, unsigned int version)\n"
    "    Trigger.new(SBMLNamespaces *sbmlns)\n"
    "    Trigger.new(Trigger const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Trigger.clone

  call-seq:
    clone -> Trigger

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Trigger_clone(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Trigger *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (Trigger *)((Trigger const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_getMath(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (ASTNode *)((Trigger const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_getInitialValue(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","getInitialValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->getInitialValue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_getPersistent(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","getPersistent", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->getPersistent();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_isSetMath(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_isSetInitialValue(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","isSetInitialValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetInitialValue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_isSetPersistent(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","isSetPersistent", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetPersistent();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_setMath(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_setInitialValue(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger *","setInitialValue", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setInitialValue", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setInitialValue(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_setPersistent(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger *","setPersistent", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setPersistent", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setPersistent(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (int)((Trigger const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_getElementName(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (std::string *) &((Trigger const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Trigger_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Trigger const *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassDelay;

SWIGINTERN VALUE
_wrap_new_Delay__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Delay *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Delay", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Delay", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Delay *)new Delay(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Delay__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Delay", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Delay *)new Delay(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Delay(Delay *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Delay_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Delay_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Delay);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Delay__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Delay,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const &","Delay", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Delay const &","Delay", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  {
    try {
      result = (Delay *)new Delay((Delay const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Delay(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Delay__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Delay__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Delay__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Delay.new", 
    "    Delay.new(unsigned int level, unsigned int version)\n"
    "    Delay.new(SBMLNamespaces *sbmlns)\n"
    "    Delay.new(Delay const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Delay.clone

  call-seq:
    clone -> Delay

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Delay_clone(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Delay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (Delay *)((Delay const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_getMath(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (ASTNode *)((Delay const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_isSetMath(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_setMath(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (UnitDefinition *)((Delay const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Delay_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Delay.getDerivedUnitDefinition", 
    "    UnitDefinition const * Delay.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * Delay.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_containsUndeclaredUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_containsUndeclaredUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Delay_containsUndeclaredUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_containsUndeclaredUnits__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_containsUndeclaredUnits__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Delay.containsUndeclaredUnits", 
    "    bool Delay.containsUndeclaredUnits()\n"
    "    bool Delay.containsUndeclaredUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (int)((Delay const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_getElementName(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (std::string *) &((Delay const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Delay_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Delay const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassPriority;

SWIGINTERN VALUE
_wrap_new_Priority__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Priority *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Priority", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Priority", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Priority *)new Priority(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Priority__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Priority *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","Priority", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Priority *)new Priority(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_Priority(Priority *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Priority_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Priority_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Priority);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Priority__SWIG_2(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Priority *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Priority,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const &","Priority", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Priority const &","Priority", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  {
    try {
      result = (Priority *)new Priority((Priority const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Priority(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Priority__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Priority, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Priority__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Priority__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "Priority.new", 
    "    Priority.new(unsigned int level, unsigned int version)\n"
    "    Priority.new(SBMLNamespaces *sbmlns)\n"
    "    Priority.new(Priority const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Priority.clone

  call-seq:
    clone -> Priority

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Priority_clone(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Priority *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (Priority *)((Priority const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Priority_getMath(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (ASTNode *)((Priority const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Priority_isSetMath(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (bool)((Priority const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Priority_setMath(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Priority_getTypeCode(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (int)((Priority const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Priority_getElementName(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (std::string *) &((Priority const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Priority_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Priority const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (bool)((Priority const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBO;

SWIGINTERN VALUE
_wrap_SBO_isQuantitativeParameter(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isQuantitativeParameter", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isQuantitativeParameter(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isParticipantRole(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isParticipantRole", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isParticipantRole(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isModellingFramework(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isModellingFramework", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isModellingFramework(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isMathematicalExpression(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isMathematicalExpression", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isMathematicalExpression(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isKineticConstant(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isKineticConstant", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isKineticConstant(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isReactant(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isReactant", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isReactant(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isProduct(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isProduct", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isProduct(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isModifier(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isModifier", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isModifier(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isRateLaw(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isRateLaw", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isRateLaw(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isEvent(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isEvent", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isEvent(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isPhysicalParticipant(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isPhysicalParticipant", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isPhysicalParticipant(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isParticipant(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isParticipant", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isParticipant(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isInteraction(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isInteraction", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isInteraction(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isEntity(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isEntity", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isEntity(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isFunctionalEntity(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isFunctionalEntity", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isFunctionalEntity(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isMaterialEntity(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isMaterialEntity", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isMaterialEntity(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isConservationLaw(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isConservationLaw", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isConservationLaw(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isSteadyStateExpression(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isSteadyStateExpression", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isSteadyStateExpression(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isFunctionalCompartment(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isFunctionalCompartment", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isFunctionalCompartment(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isContinuousFramework(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isContinuousFramework", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isContinuousFramework(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isDiscreteFramework(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isDiscreteFramework", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isDiscreteFramework(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isLogicalFramework(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isLogicalFramework", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isLogicalFramework(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_isObselete(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBO::isObselete", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isObselete(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_intToString(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","SBO::intToString", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = SBO::intToString(arg1);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_stringToInt(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SBO::stringToInt", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBO::stringToInt", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (int)SBO::stringToInt((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_checkTerm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SBO::checkTerm", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBO::checkTerm", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (bool)SBO::checkTerm((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBO_checkTerm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","SBO::checkTerm", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (bool)SBO::checkTerm(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBO_checkTerm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_SBO_checkTerm__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBO_checkTerm__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SBO.checkTerm", 
    "    bool SBO.checkTerm(std::string const &sboTerm)\n"
    "    bool SBO.checkTerm(int sboTerm)\n");
  
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBO_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBO_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBO);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBO(int argc, VALUE *argv, VALUE self) {
  SBO *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBO *)new SBO();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBO(SBO *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSyntaxChecker;

SWIGINTERN VALUE
_wrap_SyntaxChecker_isValidSBMLSId(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SyntaxChecker::isValidSBMLSId", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidSBMLSId(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SyntaxChecker_isValidXMLID(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SyntaxChecker::isValidXMLID", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidXMLID(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SyntaxChecker_isValidUnitSId(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SyntaxChecker::isValidUnitSId", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidUnitSId(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","SyntaxChecker::hasExpectedXHTMLSyntax", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLNamespaces *","SyntaxChecker::hasExpectedXHTMLSyntax", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  result = (bool)SyntaxChecker::hasExpectedXHTMLSyntax((XMLNode const *)arg1,arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","SyntaxChecker::hasExpectedXHTMLSyntax", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (bool)SyntaxChecker::hasExpectedXHTMLSyntax((XMLNode const *)arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SyntaxChecker_hasExpectedXHTMLSyntax(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SyntaxChecker.hasExpectedXHTMLSyntax", 
    "    bool SyntaxChecker.hasExpectedXHTMLSyntax(XMLNode const *xhtml, SBMLNamespaces *sbmlns)\n"
    "    bool SyntaxChecker.hasExpectedXHTMLSyntax(XMLNode const *xhtml)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SyntaxChecker_isValidInternalSId(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SyntaxChecker::isValidInternalSId", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidInternalSId(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SyntaxChecker_isValidInternalUnitSId(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SyntaxChecker::isValidInternalUnitSId", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidInternalUnitSId(arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SyntaxChecker_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SyntaxChecker_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SyntaxChecker);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SyntaxChecker(int argc, VALUE *argv, VALUE self) {
  SyntaxChecker *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SyntaxChecker *)new SyntaxChecker();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SyntaxChecker(SyntaxChecker *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassStoichiometryMath;

SWIGINTERN VALUE
_wrap_new_StoichiometryMath__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","StoichiometryMath", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","StoichiometryMath", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath(arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StoichiometryMath__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","StoichiometryMath", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_StoichiometryMath(StoichiometryMath *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_StoichiometryMath_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_StoichiometryMath_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_StoichiometryMath);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_StoichiometryMath__SWIG_2(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_StoichiometryMath,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const &","StoichiometryMath", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "StoichiometryMath const &","StoichiometryMath", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath((StoichiometryMath const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const SBMLConstructorException &e){
      static VALUE cpperror = rb_define_class("SBMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_StoichiometryMath(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StoichiometryMath__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StoichiometryMath__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_StoichiometryMath__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StoichiometryMath.new", 
    "    StoichiometryMath.new(unsigned int level, unsigned int version)\n"
    "    StoichiometryMath.new(SBMLNamespaces *sbmlns)\n"
    "    StoichiometryMath.new(StoichiometryMath const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::StoichiometryMath.clone

  call-seq:
    clone -> StoichiometryMath

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_StoichiometryMath_clone(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StoichiometryMath *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (StoichiometryMath *)((StoichiometryMath const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_getMath(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","getMath", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (ASTNode *)((StoichiometryMath const *)arg1)->getMath();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_isSetMath(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","isSetMath", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->isSetMath();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_setMath(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath *","setMath", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode const *","setMath", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_0(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_1(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  UnitDefinition *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","getDerivedUnitDefinition", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (UnitDefinition *)((StoichiometryMath const *)arg1)->getDerivedUnitDefinition();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StoichiometryMath_getDerivedUnitDefinition(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StoichiometryMath.getDerivedUnitDefinition", 
    "    UnitDefinition const * StoichiometryMath.getDerivedUnitDefinition()\n"
    "    UnitDefinition const * StoichiometryMath.getDerivedUnitDefinition()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","containsUndeclaredUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->containsUndeclaredUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StoichiometryMath_containsUndeclaredUnits(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StoichiometryMath.containsUndeclaredUnits", 
    "    bool StoichiometryMath.containsUndeclaredUnits()\n"
    "    bool StoichiometryMath.containsUndeclaredUnits()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_getTypeCode(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (int)((StoichiometryMath const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_getElementName(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","getElementName", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (std::string *) &((StoichiometryMath const *)arg1)->getElementName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StoichiometryMath_hasRequiredElements(int argc, VALUE *argv, VALUE self) {
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "StoichiometryMath const *","hasRequiredElements", 1, self )); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->hasRequiredElements();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLNamespaces;

SWIGINTERN VALUE
_wrap_new_SBMLNamespaces__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLNamespaces__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLNamespaces__SWIG_2(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLNamespaces *)new SBMLNamespaces();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLNamespaces__SWIG_3(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  std::string *arg3 = 0 ;
  unsigned int arg4 ;
  std::string *arg5 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  int res5 = SWIG_OLDOBJ ;
  SBMLNamespaces *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","SBMLNamespaces", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLNamespaces", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","SBMLNamespaces", 5, argv[4] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLNamespaces", 5, argv[4])); 
    }
    arg5 = ptr;
  }
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1,arg2,(std::string const &)*arg3,arg4,(std::string const &)*arg5);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLNamespaces__SWIG_4(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  std::string *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","SBMLNamespaces", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLNamespaces", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1,arg2,(std::string const &)*arg3,arg4);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res3)) delete arg3;
  return self;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN void
free_SBMLNamespaces(SBMLNamespaces *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLNamespaces_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLNamespaces_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLNamespaces);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLNamespaces__SWIG_5(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SBMLNamespaces,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const &","SBMLNamespaces", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SBMLNamespaces const &","SBMLNamespaces", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (SBMLNamespaces *)new SBMLNamespaces((SBMLNamespaces const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SBMLNamespaces(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SBMLNamespaces__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLNamespaces__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLNamespaces__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLNamespaces__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_SBMLNamespaces__SWIG_4(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_SBMLNamespaces__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SBMLNamespaces.new", 
    "    SBMLNamespaces.new(unsigned int level, unsigned int version)\n"
    "    SBMLNamespaces.new(unsigned int level)\n"
    "    SBMLNamespaces.new()\n"
    "    SBMLNamespaces.new(unsigned int level, unsigned int version, std::string const &pkgName, unsigned int pkgVersion, std::string const &pkgPrefix)\n"
    "    SBMLNamespaces.new(unsigned int level, unsigned int version, std::string const &pkgName, unsigned int pkgVersion)\n"
    "    SBMLNamespaces.new(SBMLNamespaces const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::SBMLNamespaces.clone

  call-seq:
    clone -> SBMLNamespaces

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBMLNamespaces_clone(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (SBMLNamespaces *)((SBMLNamespaces const *)arg1)->clone();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getSBMLNamespaceURI(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces::getSBMLNamespaceURI", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLNamespaces::getSBMLNamespaceURI", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = SBMLNamespaces::getSBMLNamespaceURI(arg1,arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getSupportedNamespaces(int argc, VALUE *argv, VALUE self) {
  List *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (List *)SBMLNamespaces::getSupportedNamespaces();
  {
    ListWrapper<SBMLNamespaces> *listw = (result != 0) ? new ListWrapper<SBMLNamespaces>(result) : 0;
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t,
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getURI(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = ((SBMLNamespaces const *)arg1)->getURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getLevel__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)(arg1)->getLevel();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getLevel__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)((SBMLNamespaces const *)arg1)->getLevel();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLNamespaces_getLevel(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getLevel__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getLevel__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBMLNamespaces.getLevel", 
    "    unsigned int SBMLNamespaces.getLevel()\n"
    "    unsigned int SBMLNamespaces.getLevel()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getVersion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)(arg1)->getVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getVersion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)((SBMLNamespaces const *)arg1)->getVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLNamespaces_getVersion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getVersion__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getVersion__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBMLNamespaces.getVersion", 
    "    unsigned int SBMLNamespaces.getVersion()\n"
    "    unsigned int SBMLNamespaces.getVersion()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getNamespaces__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","getNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (XMLNamespaces *)(arg1)->getNamespaces();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getNamespaces__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const *","getNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (XMLNamespaces *)((SBMLNamespaces const *)arg1)->getNamespaces();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLNamespaces_getNamespaces(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getNamespaces__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getNamespaces__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBMLNamespaces.getNamespaces", 
    "    XMLNamespaces const * SBMLNamespaces.getNamespaces()\n"
    "    XMLNamespaces const * SBMLNamespaces.getNamespaces()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_addNamespaces(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","addNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNamespaces const *","addNamespaces", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  (arg1)->addNamespaces((XMLNamespaces const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_addNamespace(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","addNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addNamespace", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addNamespace", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->addNamespace((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_removeNamespace(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","removeNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeNamespace((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_addPkgNamespace__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","addPkgNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addPkgNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addPkgNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","addPkgNamespace", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","addPkgNamespace", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addPkgNamespace", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->addPkgNamespace((std::string const &)*arg2,arg3,(std::string const &)*arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_addPkgNamespace__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","addPkgNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addPkgNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addPkgNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","addPkgNamespace", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (int)(arg1)->addPkgNamespace((std::string const &)*arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBMLNamespaces_addPkgNamespace(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBMLNamespaces_addPkgNamespace__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_SBMLNamespaces_addPkgNamespace__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SBMLNamespaces.addPkgNamespace", 
    "    int SBMLNamespaces.addPkgNamespace(std::string const &pkgName, unsigned int pkgVersion, std::string const &prefix)\n"
    "    int SBMLNamespaces.addPkgNamespace(std::string const &pkgName, unsigned int pkgVersion)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_addPkgNamespaces(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","addPkgNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNamespaces const *","addPkgNamespaces", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->addPkgNamespaces((XMLNamespaces const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_removePkgNamespace(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces *","removePkgNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removePkgNamespace", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","removePkgNamespace", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","removePkgNamespace", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removePkgNamespace", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","removePkgNamespace", 5, argv[3] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (int)(arg1)->removePkgNamespace(arg2,arg3,(std::string const &)*arg4,arg5);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_isSBMLNamespace(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SBMLNamespaces::isSBMLNamespace", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLNamespaces::isSBMLNamespace", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (bool)SBMLNamespaces::isSBMLNamespace((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLNamespaces_getPackageName(int argc, VALUE *argv, VALUE self) {
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLNamespaces const *","getPackageName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (std::string *) &((SBMLNamespaces const *)arg1)->getPackageName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLTransforms;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLTransforms_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLTransforms_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLTransforms);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLTransforms(int argc, VALUE *argv, VALUE self) {
  SBMLTransforms *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLTransforms *)new SBMLTransforms();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBMLTransforms(SBMLTransforms *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_readMathMLFromString(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  ASTNode_t *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","readMathMLFromString", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (ASTNode_t *)readMathMLFromString((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_writeMathMLToString(int argc, VALUE *argv, VALUE self) {
  ASTNode_t *arg1 = (ASTNode_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode_t const *","writeMathMLToString", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< ASTNode_t * >(argp1);
  result = (char *)writeMathMLToString((ASTNode const *)arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  free(result);
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassASTNode;

SWIGINTERN VALUE
_wrap_new_ASTNode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ASTNodeType_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  ASTNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "ASTNodeType_t","ASTNode", 1, argv[0] ));
  } 
  arg1 = static_cast< ASTNodeType_t >(val1);
  result = (ASTNode *)new ASTNode(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ASTNode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ASTNode *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ASTNode *)new ASTNode();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ASTNode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ASTNode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ASTNode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ASTNode__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ASTNode,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const &","ASTNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ASTNode const &","ASTNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)new ASTNode((ASTNode const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ASTNode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ASTNode__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ASTNode__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_ASTNode__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ASTNode.new", 
    "    ASTNode.new(ASTNodeType_t type)\n"
    "    ASTNode.new()\n"
    "    ASTNode.new(ASTNode const &orig)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ASTNode(ASTNode *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ASTNode_freeName(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","freeName", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)(arg1)->freeName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_canonicalize(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","canonicalize", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)(arg1)->canonicalize();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_addChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","addChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_ASTNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode *","addChild", 2, argv[0] ));
  }
  result = (int)(arg1)->addChild(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_prependChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","prependChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_ASTNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode *","prependChild", 2, argv[0] ));
  }
  result = (int)(arg1)->prependChild(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_removeChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","removeChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->removeChild(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_replaceChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int res3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","replaceChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","replaceChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&arg3), SWIGTYPE_p_ASTNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ASTNode *","replaceChild", 3, argv[1] ));
  }
  result = (int)(arg1)->replaceChild(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_insertChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int res3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","insertChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","insertChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&arg3), SWIGTYPE_p_ASTNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ASTNode *","insertChild", 3, argv[1] ));
  }
  result = (int)(arg1)->insertChild(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_deepCopy(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","deepCopy", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->deepCopy();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((ASTNode const *)arg1)->getChild(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getLeftChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getLeftChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->getLeftChild();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getRightChild(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getRightChild", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->getRightChild();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getNumChildren(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getNumChildren", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (unsigned int)((ASTNode const *)arg1)->getNumChildren();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_addSemanticsAnnotation(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","addSemanticsAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&arg2), SWIGTYPE_p_XMLNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode *","addSemanticsAnnotation", 2, argv[0] ));
  }
  result = (int)(arg1)->addSemanticsAnnotation(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getNumSemanticsAnnotations(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getNumSemanticsAnnotations", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (unsigned int)((ASTNode const *)arg1)->getNumSemanticsAnnotations();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getSemanticsAnnotation(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getSemanticsAnnotation", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getSemanticsAnnotation", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)((ASTNode const *)arg1)->getSemanticsAnnotation(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getCharacter(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getCharacter", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (char)((ASTNode const *)arg1)->getCharacter();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getInteger(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getInteger", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getInteger();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getName(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (char *)((ASTNode const *)arg1)->getName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getNumerator(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getNumerator", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getNumerator();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getDenominator(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getDenominator", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getDenominator();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getReal(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getReal", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (double)((ASTNode const *)arg1)->getReal();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getMantissa(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getMantissa", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (double)((ASTNode const *)arg1)->getMantissa();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getExponent(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getExponent", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getExponent();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getPrecedence(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getPrecedence", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)((ASTNode const *)arg1)->getPrecedence();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getType(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ASTNodeType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getType", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNodeType_t)((ASTNode const *)arg1)->getType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getUnits(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = ((ASTNode const *)arg1)->getUnits();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isBoolean(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isBoolean", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isBoolean();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isConstant(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isConstant", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isConstant();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isFunction(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isFunction", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isFunction();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isInfinity(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isInfinity", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isInfinity();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isInteger(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isInteger", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isInteger();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isLambda(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isLambda", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLambda();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isLog10(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isLog10", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLog10();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isLogical(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isLogical", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLogical();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isName(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isName", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isNaN(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isNaN", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNaN();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isNegInfinity(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isNegInfinity", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNegInfinity();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isNumber(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isNumber", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNumber();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isOperator(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isOperator", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isOperator();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isPiecewise(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isPiecewise", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isPiecewise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isRational(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isRational", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isRational();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isReal(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isReal", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isReal();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isRelational(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isRelational", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isRelational();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isSqrt(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isSqrt", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isSqrt();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isUMinus(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isUMinus", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isUMinus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isUnknown(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isUnknown", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isUnknown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isSetUnits(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isSetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isSetUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_hasUnits(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","hasUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->hasUnits();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setCharacter(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setCharacter", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setCharacter", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (int)(arg1)->setCharacter(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setName(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setName", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setName", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)(arg1)->setName((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (int)(arg1)->setValue(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  long arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setValue", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  result = (int)(arg1)->setValue(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setValue(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setValue__SWIG_3(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  double arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","setValue", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setValue", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  result = (int)(arg1)->setValue(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ASTNode_setValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ASTNode_setValue__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ASTNode_setValue__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_ASTNode_setValue__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_ASTNode_setValue__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "ASTNode.setValue", 
    "    int ASTNode.setValue(long value)\n"
    "    int ASTNode.setValue(long numerator, long denominator)\n"
    "    int ASTNode.setValue(double value)\n"
    "    int ASTNode.setValue(double mantissa, long exponent)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setType(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNodeType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setType", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ASTNodeType_t","setType", 2, argv[0] ));
  } 
  arg2 = static_cast< ASTNodeType_t >(val2);
  result = (int)(arg1)->setType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setUnits(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","setUnits", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setUnits(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_swapChildren(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","swapChildren", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ASTNode *","swapChildren", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->swapChildren(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_unsetUnits(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","unsetUnits", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)(arg1)->unsetUnits();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getDefinitionURL(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLAttributes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getDefinitionURL", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (XMLAttributes *)((ASTNode const *)arg1)->getDefinitionURL();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_replaceArgument(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  std::string arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","replaceArgument", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","replaceArgument", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "ASTNode *","replaceArgument", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  (arg1)->replaceArgument(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getParentSBMLObject(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","getParentSBMLObject", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (SBase *)((ASTNode const *)arg1)->getParentSBMLObject();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_reduceToBinary(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","reduceToBinary", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  (arg1)->reduceToBinary();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isWellFormedASTNode(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isWellFormedASTNode", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isWellFormedASTNode();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_hasCorrectNumberArguments(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","hasCorrectNumberArguments", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->hasCorrectNumberArguments();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_isBvar(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode const *","isBvar", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isBvar();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_setBvar(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","setBvar", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  (arg1)->setBvar();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ASTNode_getListOfNodes(int argc, VALUE *argv, VALUE self) {
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ListWrapper< ASTNode > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode *","getListOfNodes", 1, self )); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ListWrapper< ASTNode > *)ASTNode_getListOfNodes(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_parseFormula(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  ASTNode_t *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","SBML_parseFormula", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (ASTNode_t *)SBML_parseFormula((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_formulaToString(int argc, VALUE *argv, VALUE self) {
  ASTNode_t *arg1 = (ASTNode_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ASTNode_t const *","SBML_formulaToString", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< ASTNode_t * >(argp1);
  result = (char *)SBML_formulaToString((ASTNode const *)arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  free(result);
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassXMLConstructorException;

SWIGINTERN VALUE
_wrap_new_XMLConstructorException__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  XMLConstructorException *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","XMLConstructorException", 1, argv[0] )); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (XMLConstructorException *)new XMLConstructorException(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLConstructorException_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLConstructorException_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLConstructorException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLConstructorException__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLConstructorException *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (XMLConstructorException *)new XMLConstructorException();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLConstructorException(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLConstructorException__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLConstructorException__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "XMLConstructorException.new", 
    "    XMLConstructorException.new(std::string message)\n"
    "    XMLConstructorException.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_XMLConstructorException(XMLConstructorException *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassXMLAttributes;

SWIGINTERN VALUE
_wrap_new_XMLAttributes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    try {
      result = (XMLAttributes *)new XMLAttributes();
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_XMLAttributes(XMLAttributes *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLAttributes_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLAttributes_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLAttributes);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLAttributes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLAttributes *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLAttributes", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLAttributes", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    try {
      result = (XMLAttributes *)new XMLAttributes((XMLAttributes const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLAttributes(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLAttributes__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLAttributes__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "XMLAttributes.new", 
    "    XMLAttributes.new()\n"
    "    XMLAttributes.new(XMLAttributes const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLAttributes.clone

  call-seq:
    clone -> XMLAttributes

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_XMLAttributes_clone(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLAttributes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (XMLAttributes *)((XMLAttributes const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_add__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","add", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","add", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","add", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","add", 5, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 5, argv[3])); 
    }
    arg5 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_add__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","add", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","add", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","add", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_add__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","add", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","add", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_add__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","add", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","add", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","add", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((XMLTriple const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLAttributes_add(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_add__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_add__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLAttributes_add__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_XMLAttributes_add__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "XMLAttributes.add", 
    "    int XMLAttributes.add(std::string const &name, std::string const &value, std::string const &namespaceURI, std::string const &prefix)\n"
    "    int XMLAttributes.add(std::string const &name, std::string const &value, std::string const &namespaceURI)\n"
    "    int XMLAttributes.add(std::string const &name, std::string const &value)\n"
    "    int XMLAttributes.add(XMLTriple const &triple, std::string const &value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_removeResource(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","removeResource", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeResource", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeResource(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->remove(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","remove", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_remove__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_remove__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","remove", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","remove", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->remove((XMLTriple const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLAttributes_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_remove__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "remove.new", 
    "    remove.new(int n)\n"
    "    remove.new(std::string const &name, std::string const &uri)\n"
    "    remove.new(std::string const &name)\n"
    "    remove.new(XMLTriple const &triple)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLAttributes.clear

  call-seq:
    clear -> int

Clear XMLAttributes contents.
*/
SWIGINTERN VALUE
_wrap_XMLAttributes_clear(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)(arg1)->clear();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getIndex__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getIndex", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getIndex", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLAttributes const *)arg1)->getIndex((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getIndex__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getIndex", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getIndex", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","getIndex", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getIndex", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)((XMLAttributes const *)arg1)->getIndex((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getIndex__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","getIndex", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","getIndex", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)((XMLAttributes const *)arg1)->getIndex((XMLTriple const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLAttributes_getIndex(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getIndex__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getIndex__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_getIndex__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLAttributes.getIndex", 
    "    int XMLAttributes.getIndex(std::string const &name)\n"
    "    int XMLAttributes.getIndex(std::string const &name, std::string const &uri)\n"
    "    int XMLAttributes.getIndex(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getLength(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getLength", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)((XMLAttributes const *)arg1)->getLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getNumAttributes(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getNumAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)((XMLAttributes const *)arg1)->getNumAttributes();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getName(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getName(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getPrefix(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getPrefix", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getPrefix(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getPrefixedName(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getPrefixedName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getPrefixedName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getPrefixedName(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getURI(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getURI", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getURI(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getValue(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getValue", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLAttributes const *)arg1)->getValue(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getValue", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getValue", 3, argv[1] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLAttributes const *)arg1)->getValue(arg2,arg3);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_getValue__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","getValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","getValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","getValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = ((XMLAttributes const *)arg1)->getValue((XMLTriple const &)*arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLAttributes_getValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_getValue__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLAttributes.getValue", 
    "    std::string XMLAttributes.getValue(int index)\n"
    "    std::string XMLAttributes.getValue(std::string const name)\n"
    "    std::string XMLAttributes.getValue(std::string const name, std::string const uri)\n"
    "    std::string XMLAttributes.getValue(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_hasAttribute__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","hasAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasAttribute", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_hasAttribute__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","hasAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","hasAttribute", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","hasAttribute", 3, argv[1] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_hasAttribute__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","hasAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","hasAttribute", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_hasAttribute__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","hasAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","hasAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","hasAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute((XMLTriple const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLAttributes_hasAttribute(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_hasAttribute__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLAttributes.hasAttribute", 
    "    bool XMLAttributes.hasAttribute(int index)\n"
    "    bool XMLAttributes.hasAttribute(std::string const name, std::string const uri)\n"
    "    bool XMLAttributes.hasAttribute(std::string const name)\n"
    "    bool XMLAttributes.hasAttribute(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLAttributes_isEmpty(int argc, VALUE *argv, VALUE self) {
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLAttributes const *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (bool)((XMLAttributes const *)arg1)->isEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassXMLNamespaces;

SWIGINTERN VALUE
_wrap_new_XMLNamespaces__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    try {
      result = (XMLNamespaces *)new XMLNamespaces();
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_XMLNamespaces(XMLNamespaces *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLNamespaces_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLNamespaces_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLNamespaces);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLNamespaces__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLNamespaces", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLNamespaces", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    try {
      result = (XMLNamespaces *)new XMLNamespaces((XMLNamespaces const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLNamespaces(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLNamespaces__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNamespaces__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "XMLNamespaces.new", 
    "    XMLNamespaces.new()\n"
    "    XMLNamespaces.new(XMLNamespaces const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLNamespaces.clone

  call-seq:
    clone -> XMLNamespaces

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_XMLNamespaces_clone(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (XMLNamespaces *)((XMLNamespaces const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_add__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","add", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","add", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_add__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","add", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","add", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLNamespaces_add(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_add__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLNamespaces_add__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLNamespaces.add", 
    "    int XMLNamespaces.add(std::string const &uri, std::string const &prefix)\n"
    "    int XMLNamespaces.add(std::string const &uri)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_remove__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","remove", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->remove(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_remove__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","remove", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","remove", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLNamespaces_remove(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_remove__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_remove__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "remove.new", 
    "    remove.new(int index)\n"
    "    remove.new(std::string const &prefix)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLNamespaces.clear

  call-seq:
    clear -> int

Clear XMLNamespaces contents.
*/
SWIGINTERN VALUE
_wrap_XMLNamespaces_clear(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)(arg1)->clear();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getIndex(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getIndex", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)((XMLNamespaces const *)arg1)->getIndex(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getIndexByPrefix(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getIndexByPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getIndexByPrefix", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)((XMLNamespaces const *)arg1)->getIndexByPrefix(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getLength(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getLength", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)((XMLNamespaces const *)arg1)->getLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getNumNamespaces(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getNumNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)((XMLNamespaces const *)arg1)->getNumNamespaces();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getPrefix__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getPrefix", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLNamespaces const *)arg1)->getPrefix(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getPrefix__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getPrefix", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getPrefix", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((XMLNamespaces const *)arg1)->getPrefix((std::string const &)*arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLNamespaces_getPrefix(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_getPrefix__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_getPrefix__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLNamespaces.getPrefix", 
    "    std::string XMLNamespaces.getPrefix(int index)\n"
    "    std::string XMLNamespaces.getPrefix(std::string const &uri)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getURI__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getURI", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLNamespaces const *)arg1)->getURI(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getURI__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getURI", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getURI", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((XMLNamespaces const *)arg1)->getURI((std::string const &)*arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_getURI__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = ((XMLNamespaces const *)arg1)->getURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLNamespaces_getURI(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLNamespaces_getURI__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_getURI__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_getURI__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLNamespaces.getURI", 
    "    std::string XMLNamespaces.getURI(int index)\n"
    "    std::string XMLNamespaces.getURI(std::string const &prefix)\n"
    "    std::string XMLNamespaces.getURI()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_isEmpty(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (bool)((XMLNamespaces const *)arg1)->isEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_hasURI(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","hasURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasURI", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasURI", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasURI((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_hasPrefix(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","hasPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasPrefix", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasPrefix", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasPrefix((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNamespaces_hasNS(int argc, VALUE *argv, VALUE self) {
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNamespaces const *","hasNS", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasNS", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasNS", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","hasNS", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasNS", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasNS((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


swig_class SwigClassXMLToken;

SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    try {
      result = (XMLToken *)new XMLToken();
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLToken", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLToken", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLToken", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLToken", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4,arg5);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLToken", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLToken", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLToken", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLToken", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLToken", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLToken", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLToken", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLToken", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_4(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLToken", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLToken", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3,arg4);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_5(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLToken", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLToken", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_6(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLToken", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLToken", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_7(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_8(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_9(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_10(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLToken", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLToken", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLToken *)new XMLToken((std::string const &)*arg1,arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_11(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLToken", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLToken", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLToken", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLToken *)new XMLToken((std::string const &)*arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_12(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  XMLToken *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLToken", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLToken", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (XMLToken *)new XMLToken((std::string const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_XMLToken(XMLToken *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLToken_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLToken_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLToken);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLToken__SWIG_13(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLToken *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLToken,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const &","XMLToken", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLToken const &","XMLToken", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLToken const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLToken(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLToken__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_9(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_13(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_12(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLToken__SWIG_6(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLToken__SWIG_8(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLToken__SWIG_11(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLToken__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_5(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_7(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_10(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLToken__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLToken__SWIG_4(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLToken__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "XMLToken.new", 
    "    XMLToken.new()\n"
    "    XMLToken.new(XMLTriple const &triple, XMLAttributes const &attributes, XMLNamespaces const &namespaces, unsigned int const line, unsigned int const column)\n"
    "    XMLToken.new(XMLTriple const &triple, XMLAttributes const &attributes, XMLNamespaces const &namespaces, unsigned int const line)\n"
    "    XMLToken.new(XMLTriple const &triple, XMLAttributes const &attributes, XMLNamespaces const &namespaces)\n"
    "    XMLToken.new(XMLTriple const &triple, XMLAttributes const &attributes, unsigned int const line, unsigned int const column)\n"
    "    XMLToken.new(XMLTriple const &triple, XMLAttributes const &attributes, unsigned int const line)\n"
    "    XMLToken.new(XMLTriple const &triple, XMLAttributes const &attributes)\n"
    "    XMLToken.new(XMLTriple const &triple, unsigned int const line, unsigned int const column)\n"
    "    XMLToken.new(XMLTriple const &triple, unsigned int const line)\n"
    "    XMLToken.new(XMLTriple const &triple)\n"
    "    XMLToken.new(std::string const &chars, unsigned int const line, unsigned int const column)\n"
    "    XMLToken.new(std::string const &chars, unsigned int const line)\n"
    "    XMLToken.new(std::string const &chars)\n"
    "    XMLToken.new(XMLToken const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLToken.clone

  call-seq:
    clone -> XMLToken

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_XMLToken_clone(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLToken *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLToken *)((XMLToken const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttributes(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLAttributes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLAttributes *) &((XMLToken const *)arg1)->getAttributes();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_setAttributes(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","setAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","setAttributes", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","setAttributes", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  result = (int)(arg1)->setAttributes((XMLAttributes const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_addAttr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","addAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addAttr", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addAttr", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","addAttr", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","addAttr", 5, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 5, argv[3])); 
    }
    arg5 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_addAttr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","addAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addAttr", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addAttr", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","addAttr", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_addAttr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","addAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addAttr", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addAttr", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_addAttr__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","addAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","addAttr", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","addAttr", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addAttr", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addAttr", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addAttr((XMLTriple const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_addAttr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addAttr__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addAttr__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLToken_addAttr__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_XMLToken_addAttr__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "XMLToken.addAttr", 
    "    int XMLToken.addAttr(std::string const &name, std::string const &value, std::string const &namespaceURI, std::string const &prefix)\n"
    "    int XMLToken.addAttr(std::string const &name, std::string const &value, std::string const &namespaceURI)\n"
    "    int XMLToken.addAttr(std::string const &name, std::string const &value)\n"
    "    int XMLToken.addAttr(XMLTriple const &triple, std::string const &value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_removeAttr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","removeAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeAttr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeAttr(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_removeAttr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","removeAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeAttr", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeAttr", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","removeAttr", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeAttr", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->removeAttr((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_removeAttr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","removeAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeAttr", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeAttr", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeAttr((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_removeAttr__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","removeAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","removeAttr", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","removeAttr", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->removeAttr((XMLTriple const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_removeAttr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_removeAttr__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLToken.removeAttr", 
    "    int XMLToken.removeAttr(int n)\n"
    "    int XMLToken.removeAttr(std::string const &name, std::string const &uri)\n"
    "    int XMLToken.removeAttr(std::string const &name)\n"
    "    int XMLToken.removeAttr(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_clearAttributes(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","clearAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->clearAttributes();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrIndex__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getAttrIndex", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getAttrIndex", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","getAttrIndex", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getAttrIndex", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getAttrIndex((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrIndex__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getAttrIndex", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getAttrIndex", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getAttrIndex((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrIndex__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","getAttrIndex", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","getAttrIndex", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)((XMLToken const *)arg1)->getAttrIndex((XMLTriple const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_getAttrIndex(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrIndex__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrIndex__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_getAttrIndex__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLToken.getAttrIndex", 
    "    int XMLToken.getAttrIndex(std::string const &name, std::string const &uri)\n"
    "    int XMLToken.getAttrIndex(std::string const &name)\n"
    "    int XMLToken.getAttrIndex(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttributesLength(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttributesLength", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)((XMLToken const *)arg1)->getAttributesLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrName(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAttrName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrName(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrPrefix(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAttrPrefix", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrPrefix(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrPrefixedName(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrPrefixedName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAttrPrefixedName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrPrefixedName(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrURI(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAttrURI", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrURI(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrValue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAttrValue", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrValue(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrValue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getAttrValue", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getAttrValue", 3, argv[1] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLToken const *)arg1)->getAttrValue(arg2,arg3);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrValue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","getAttrValue", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLToken const *)arg1)->getAttrValue(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getAttrValue__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getAttrValue", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","getAttrValue", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","getAttrValue", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = ((XMLToken const *)arg1)->getAttrValue((XMLTriple const &)*arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_getAttrValue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_getAttrValue__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLToken.getAttrValue", 
    "    std::string XMLToken.getAttrValue(int index)\n"
    "    std::string XMLToken.getAttrValue(std::string const name, std::string const uri)\n"
    "    std::string XMLToken.getAttrValue(std::string const name)\n"
    "    std::string XMLToken.getAttrValue(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasAttr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","hasAttr", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasAttr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","hasAttr", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","hasAttr", 3, argv[1] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasAttr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","hasAttr", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasAttr__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasAttr", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","hasAttr", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","hasAttr", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (bool)((XMLToken const *)arg1)->hasAttr((XMLTriple const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_hasAttr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_hasAttr__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLToken.hasAttr", 
    "    bool XMLToken.hasAttr(int index)\n"
    "    bool XMLToken.hasAttr(std::string const name, std::string const uri)\n"
    "    bool XMLToken.hasAttr(std::string const name)\n"
    "    bool XMLToken.hasAttr(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isAttributesEmpty(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isAttributesEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isAttributesEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespaces(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLNamespaces *) &((XMLToken const *)arg1)->getNamespaces();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_setNamespaces(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLNamespaces *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","setNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNamespaces const &","setNamespaces", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","setNamespaces", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->setNamespaces((XMLNamespaces const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_addNamespace__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","addNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","addNamespace", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addNamespace", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addNamespace((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_addNamespace__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","addNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->addNamespace((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_addNamespace(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_addNamespace__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addNamespace__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLToken.addNamespace", 
    "    int XMLToken.addNamespace(std::string const &uri, std::string const &prefix)\n"
    "    int XMLToken.addNamespace(std::string const &uri)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_removeNamespace__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","removeNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","removeNamespace", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeNamespace(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_removeNamespace__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","removeNamespace", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","removeNamespace", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","removeNamespace", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeNamespace((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_removeNamespace(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_removeNamespace__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeNamespace__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLToken.removeNamespace", 
    "    int XMLToken.removeNamespace(int index)\n"
    "    int XMLToken.removeNamespace(std::string const &prefix)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_clearNamespaces(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","clearNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->clearNamespaces();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespaceIndex(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespaceIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getNamespaceIndex", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getNamespaceIndex", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getNamespaceIndex((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespaceIndexByPrefix(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespaceIndexByPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getNamespaceIndexByPrefix", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getNamespaceIndexByPrefix", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getNamespaceIndexByPrefix((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespacesLength(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespacesLength", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)((XMLToken const *)arg1)->getNamespacesLength();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespacePrefix__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespacePrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getNamespacePrefix", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getNamespacePrefix(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespacePrefix__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespacePrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getNamespacePrefix", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getNamespacePrefix", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((XMLToken const *)arg1)->getNamespacePrefix((std::string const &)*arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_getNamespacePrefix(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getNamespacePrefix__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getNamespacePrefix__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLToken.getNamespacePrefix", 
    "    std::string XMLToken.getNamespacePrefix(int index)\n"
    "    std::string XMLToken.getNamespacePrefix(std::string const &uri)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespaceURI__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespaceURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getNamespaceURI", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getNamespaceURI(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespaceURI__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespaceURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getNamespaceURI", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getNamespaceURI", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = ((XMLToken const *)arg1)->getNamespaceURI((std::string const &)*arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getNamespaceURI__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getNamespaceURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = ((XMLToken const *)arg1)->getNamespaceURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLToken_getNamespaceURI(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLToken_getNamespaceURI__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getNamespaceURI__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getNamespaceURI__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLToken.getNamespaceURI", 
    "    std::string XMLToken.getNamespaceURI(int index)\n"
    "    std::string XMLToken.getNamespaceURI(std::string const &prefix)\n"
    "    std::string XMLToken.getNamespaceURI()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isNamespacesEmpty(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isNamespacesEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isNamespacesEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasNamespaceURI(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasNamespaceURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasNamespaceURI", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasNamespaceURI", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespaceURI((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasNamespacePrefix(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasNamespacePrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasNamespacePrefix", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasNamespacePrefix", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespacePrefix((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_hasNamespaceNS(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","hasNamespaceNS", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasNamespaceNS", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasNamespaceNS", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","hasNamespaceNS", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasNamespaceNS", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespaceNS((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_setTriple(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","setTriple", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","setTriple", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","setTriple", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->setTriple((XMLTriple const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getName(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getPrefix(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getPrefix();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getURI(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getCharacters(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getCharacters", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getCharacters();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_append(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","append", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","append", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->append((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getColumn(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getColumn", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (unsigned int)((XMLToken const *)arg1)->getColumn();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_getLine(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","getLine", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (unsigned int)((XMLToken const *)arg1)->getLine();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isElement(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isElement();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isEnd(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isEnd();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isEndFor(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLToken *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isEndFor", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLToken,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLToken const &","isEndFor", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLToken const &","isEndFor", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLToken * >(argp2);
  result = (bool)((XMLToken const *)arg1)->isEndFor((XMLToken const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isEOF(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isEOF", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isEOF();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isStart(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isStart", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isStart();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_isText(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const *","isText", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isText();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_setEnd(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","setEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->setEnd();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_setEOF(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","setEOF", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->setEOF();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_unsetEnd(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","unsetEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->unsetEnd();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLToken_toString(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (arg1)->toString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassXMLNode;

SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNode *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    try {
      result = (XMLNode *)new XMLNode();
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLToken *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLToken,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLToken const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLToken const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLToken const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLNode", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLNode", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLNode", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLNode", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4,arg5);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLNode", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLNode", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLNode", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLNode", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_4(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLNode", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLNode", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_XMLNamespaces,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNamespaces const &","XMLNode", 3, argv[2] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNamespaces const &","XMLNode", 3, argv[2])); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_5(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLNode", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLNode", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3,arg4);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_6(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLNode", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLNode", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_7(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_XMLAttributes,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLAttributes const &","XMLNode", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLAttributes const &","XMLNode", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_8(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_9(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_10(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_11(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLNode", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLNode", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLNode *)new XMLNode((std::string const &)*arg1,arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_12(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLNode", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLNode", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","XMLNode", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLNode *)new XMLNode((std::string const &)*arg1,arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_13(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  XMLNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLNode", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLNode", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (XMLNode *)new XMLNode((std::string const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_14(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLInputStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLInputStream &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode(*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_XMLNode(XMLNode *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLNode_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLNode_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLNode);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLNode__SWIG_15(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLNode,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const &","XMLNode", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNode const &","XMLNode", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLNode const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLNode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLNode__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_15(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_10(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLInputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_14(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_13(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLNode__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLNode__SWIG_9(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLNode__SWIG_12(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLNode__SWIG_4(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_8(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_11(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLNode__SWIG_3(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLNode__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLNode__SWIG_2(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "XMLNode.new", 
    "    XMLNode.new()\n"
    "    XMLNode.new(XMLToken const &token)\n"
    "    XMLNode.new(XMLTriple const &triple, XMLAttributes const &attributes, XMLNamespaces const &namespaces, unsigned int const line, unsigned int const column)\n"
    "    XMLNode.new(XMLTriple const &triple, XMLAttributes const &attributes, XMLNamespaces const &namespaces, unsigned int const line)\n"
    "    XMLNode.new(XMLTriple const &triple, XMLAttributes const &attributes, XMLNamespaces const &namespaces)\n"
    "    XMLNode.new(XMLTriple const &triple, XMLAttributes const &attributes, unsigned int const line, unsigned int const column)\n"
    "    XMLNode.new(XMLTriple const &triple, XMLAttributes const &attributes, unsigned int const line)\n"
    "    XMLNode.new(XMLTriple const &triple, XMLAttributes const &attributes)\n"
    "    XMLNode.new(XMLTriple const &triple, unsigned int const line, unsigned int const column)\n"
    "    XMLNode.new(XMLTriple const &triple, unsigned int const line)\n"
    "    XMLNode.new(XMLTriple const &triple)\n"
    "    XMLNode.new(std::string const &chars, unsigned int const line, unsigned int const column)\n"
    "    XMLNode.new(std::string const &chars, unsigned int const line)\n"
    "    XMLNode.new(std::string const &chars)\n"
    "    XMLNode.new(XMLInputStream &stream)\n"
    "    XMLNode.new(XMLNode const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLNode.clone

  call-seq:
    clone -> XMLNode

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_XMLNode_clone(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)((XMLNode const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_addChild(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  XMLNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode *","addChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const &","addChild", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNode const &","addChild", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->addChild((XMLNode const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_insertChild(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  XMLNode *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode *","insertChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","insertChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_XMLNode,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "XMLNode const &","insertChild", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNode const &","insertChild", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< XMLNode * >(argp3);
  result = (XMLNode *) &(arg1)->insertChild(arg2,(XMLNode const &)*arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_removeChild(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode *","removeChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","removeChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)(arg1)->removeChild(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_removeChildren(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode *","removeChildren", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (int)(arg1)->removeChildren();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_getChild__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode *","getChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *) &(arg1)->getChild(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_getChild__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","getChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getChild", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *) &((XMLNode const *)arg1)->getChild(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_getChild__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode *","getChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getChild", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getChild", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (XMLNode *) &(arg1)->getChild((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_getChild__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","getChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getChild", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getChild", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (XMLNode *) &((XMLNode const *)arg1)->getChild((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLNode_getChild(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLNode.getChild", 
    "    XMLNode const & XMLNode.getChild(unsigned int n)\n"
    "    XMLNode const & XMLNode.getChild(unsigned int n)\n"
    "    XMLNode const & XMLNode.getChild(std::string const &name)\n"
    "    XMLNode const & XMLNode.getChild(std::string const &name)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_getIndex(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getIndex", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getIndex", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLNode const *)arg1)->getIndex((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_hasChild(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","hasChild", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","hasChild", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","hasChild", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNode const *)arg1)->hasChild((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_equals(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  XMLNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","equals", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNode const &","equals", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNode const &","equals", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (bool)((XMLNode const *)arg1)->equals((XMLNode const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_getNumChildren(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","getNumChildren", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (unsigned int)((XMLNode const *)arg1)->getNumChildren();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_toXMLString(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","toXMLString", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = ((XMLNode const *)arg1)->toXMLString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_convertXMLNodeToString(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","XMLNode::convertXMLNodeToString", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = XMLNode::convertXMLNodeToString((XMLNode const *)arg1);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_convertStringToXMLNode__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLNode::convertStringToXMLNode", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLNode::convertStringToXMLNode", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLNamespaces const *","XMLNode::convertStringToXMLNode", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (XMLNode *)XMLNode::convertStringToXMLNode((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,(XMLNamespaces const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLNode_convertStringToXMLNode__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLNode::convertStringToXMLNode", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLNode::convertStringToXMLNode", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (XMLNode *)XMLNode::convertStringToXMLNode((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLNode_convertStringToXMLNode(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLNode_convertStringToXMLNode__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_convertStringToXMLNode__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "convertStringToXMLNode.new", 
    "    convertStringToXMLNode.new(std::string const &xmlstr, XMLNamespaces const *xmlns)\n"
    "    convertStringToXMLNode.new(std::string const &xmlstr)\n");
  
  return Qnil;
}


swig_class SwigClassXMLTriple;

SWIGINTERN VALUE
_wrap_new_XMLTriple__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLTriple *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (XMLTriple *)new XMLTriple();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLTriple__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  XMLTriple *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLTriple", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLTriple", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLTriple", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLTriple", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","XMLTriple", 3, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLTriple", 3, argv[2])); 
    }
    arg3 = ptr;
  }
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLTriple__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  char arg2 ;
  int res1 = SWIG_OLDOBJ ;
  char val2 ;
  int ecode2 = 0 ;
  XMLTriple *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLTriple", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLTriple", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","XMLTriple", 2, argv[1] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLTriple__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  XMLTriple *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","XMLTriple", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLTriple", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLTriple_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLTriple_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLTriple);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLTriple__SWIG_4(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLTriple *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const &","XMLTriple", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","XMLTriple", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLTriple *)new XMLTriple((XMLTriple const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLTriple(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLTriple__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTriple__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTriple__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLTriple__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLTriple__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLTriple.new", 
    "    XMLTriple.new()\n"
    "    XMLTriple.new(std::string const &name, std::string const &uri, std::string const &prefix)\n"
    "    XMLTriple.new(std::string const &triplet, char const sepchar)\n"
    "    XMLTriple.new(std::string const &triplet)\n"
    "    XMLTriple.new(XMLTriple const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::XMLTriple.clone

  call-seq:
    clone -> XMLTriple

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_XMLTriple_clone(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLTriple *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLTriple *)((XMLTriple const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTriple_getName(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTriple_getPrefix(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const *","getPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getPrefix();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTriple_getURI(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTriple_getPrefixedName(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const *","getPrefixedName", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = ((XMLTriple const *)arg1)->getPrefixedName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTriple_isEmpty(int argc, VALUE *argv, VALUE self) {
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLTriple const *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (bool)((XMLTriple const *)arg1)->isEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_XMLTriple(XMLTriple *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassXMLOutputStream;

SWIGINTERN VALUE
_wrap_new_XMLOutputStream__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  XMLOutputStream *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","XMLOutputStream", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","XMLOutputStream", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","XMLOutputStream", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 5, argv[4] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 5, argv[4])); 
    }
    arg5 = ptr;
  }
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4,(std::string const &)*arg5);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLOutputStream__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  XMLOutputStream *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","XMLOutputStream", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","XMLOutputStream", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","XMLOutputStream", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLOutputStream__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","XMLOutputStream", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","XMLOutputStream", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","XMLOutputStream", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLOutputStream__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  XMLOutputStream *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","XMLOutputStream", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","XMLOutputStream", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLOutputStream", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLOutputStream", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLOutputStream_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLOutputStream_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLOutputStream);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLOutputStream__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","XMLOutputStream", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","XMLOutputStream", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLOutputStream(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLOutputStream__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLOutputStream__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLOutputStream__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_XMLOutputStream__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_XMLOutputStream__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "XMLOutputStream.new", 
    "    XMLOutputStream.new(std::ostream &stream, std::string const &encoding, bool writeXMLDecl, std::string const &programName, std::string const &programVersion)\n"
    "    XMLOutputStream.new(std::ostream &stream, std::string const &encoding, bool writeXMLDecl, std::string const &programName)\n"
    "    XMLOutputStream.new(std::ostream &stream, std::string const &encoding, bool writeXMLDecl)\n"
    "    XMLOutputStream.new(std::ostream &stream, std::string const &encoding)\n"
    "    XMLOutputStream.new(std::ostream &stream)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_endElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","endElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","endElement", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","endElement", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","endElement", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","endElement", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->endElement((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_endElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","endElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","endElement", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","endElement", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->endElement((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_endElement__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","endElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","endElement", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","endElement", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->endElement((XMLTriple const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLOutputStream_endElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_endElement__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_endElement__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_endElement__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLOutputStream.endElement", 
    "    void XMLOutputStream.endElement(std::string const &name, std::string const &prefix)\n"
    "    void XMLOutputStream.endElement(std::string const &name)\n"
    "    void XMLOutputStream.endElement(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_setAutoIndent(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","setAutoIndent", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setAutoIndent", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setAutoIndent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_startElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","startElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","startElement", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","startElement", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","startElement", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","startElement", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->startElement((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_startElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","startElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","startElement", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","startElement", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->startElement((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_startElement__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","startElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","startElement", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","startElement", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->startElement((XMLTriple const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLOutputStream_startElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startElement__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startElement__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_startElement__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLOutputStream.startElement", 
    "    void XMLOutputStream.startElement(std::string const &name, std::string const &prefix)\n"
    "    void XMLOutputStream.startElement(std::string const &name)\n"
    "    void XMLOutputStream.startElement(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_startEndElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","startEndElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","startEndElement", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","startEndElement", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","startEndElement", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","startEndElement", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->startEndElement((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_startEndElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","startEndElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","startEndElement", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","startEndElement", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  (arg1)->startEndElement((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_startEndElement__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","startEndElement", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","startEndElement", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","startEndElement", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->startEndElement((XMLTriple const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLOutputStream_startEndElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startEndElement__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startEndElement__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_startEndElement__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLOutputStream.startEndElement", 
    "    void XMLOutputStream.startEndElement(std::string const &name, std::string const &prefix)\n"
    "    void XMLOutputStream.startEndElement(std::string const &name)\n"
    "    void XMLOutputStream.startEndElement(XMLTriple const &triple)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_3(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","writeAttribute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->writeAttribute((std::string const &)*arg2,(char const *)arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_4(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","writeAttribute", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(char const *)arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_5(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","writeAttribute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(char const *)arg3);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_6(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(bool const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_7(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool temp4 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","writeAttribute", 4, argv[2] ));
  } 
  temp4 = static_cast< bool >(val4);
  arg4 = &temp4;
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(bool const &)*arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_8(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(bool const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_9(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  double *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(double const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_10(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  double *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  double temp4 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","writeAttribute", 4, argv[2] ));
  } 
  temp4 = static_cast< double >(val4);
  arg4 = &temp4;
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(double const &)*arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_11(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  double *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(double const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_12(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  long *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  long temp3 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< long >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(long const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_13(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  long *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  long temp4 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","writeAttribute", 4, argv[2] ));
  } 
  temp4 = static_cast< long >(val4);
  arg4 = &temp4;
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(long const &)*arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_14(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  long *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  long temp3 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< long >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(long const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_15(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int temp3 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< int >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(int const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_16(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int temp4 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","writeAttribute", 4, argv[2] ));
  } 
  temp4 = static_cast< int >(val4);
  arg4 = &temp4;
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(int const &)*arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_17(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int temp3 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttribute", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttribute", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","writeAttribute", 3, argv[1] ));
  } 
  temp3 = static_cast< int >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(int const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttribute__SWIG_18(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  unsigned int *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  unsigned int temp4 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeAttribute", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttribute", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","writeAttribute", 4, argv[2] ));
  } 
  temp4 = static_cast< unsigned int >(val4);
  arg4 = &temp4;
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3,(unsigned int const &)*arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLOutputStream_writeAttribute(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_17(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_14(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_11(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_5(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_8(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_15(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_12(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_9(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_18(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_16(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_13(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_10(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_4(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLOutputStream_writeAttribute__SWIG_7(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "XMLOutputStream.writeAttribute", 
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, std::string const &value)\n"
    "    void XMLOutputStream.writeAttribute(XMLTriple const &triple, std::string const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, char const *value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, char const *value)\n"
    "    void XMLOutputStream.writeAttribute(XMLTriple const &triple, char const *value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, bool const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, bool const &value)\n"
    "    void XMLOutputStream.writeAttribute(XMLTriple const &triple, bool const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, double const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, double const &value)\n"
    "    void XMLOutputStream.writeAttribute(XMLTriple const &triple, double const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, long const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, long const &value)\n"
    "    void XMLOutputStream.writeAttribute(XMLTriple const &triple, long const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, int const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, int const &value)\n"
    "    void XMLOutputStream.writeAttribute(XMLTriple const &triple, int const &value)\n"
    "    void XMLOutputStream.writeAttribute(std::string const &name, std::string const &prefix, unsigned int const &value)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeXMLDecl(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeXMLDecl", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->writeXMLDecl();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeComment(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeComment", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeComment", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeComment", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","writeComment", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeComment", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  (arg1)->writeComment((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_downIndent(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","downIndent", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->downIndent();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_upIndent(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","upIndent", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->upIndent();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttributeBool__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttributeBool", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","writeAttributeBool", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","writeAttributeBool", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","writeAttributeBool", 3, argv[1] ));
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  XMLOutputStream_writeAttributeBool__SWIG_0(arg1,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg2,(bool const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLOutputStream_writeAttributeBool__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLOutputStream *","writeAttributeBool", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLTriple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLTriple const &","writeAttributeBool", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLTriple const &","writeAttributeBool", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","writeAttributeBool", 3, argv[1] ));
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  XMLOutputStream_writeAttributeBool__SWIG_1(arg1,(XMLTriple const &)*arg2,(bool const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLOutputStream_writeAttributeBool(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttributeBool__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttributeBool__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "writeAttributeBool", 
    "    void writeAttributeBool(std::string const &name, bool const &value)\n"
    "    void writeAttributeBool(XMLTriple const &name, bool const &value)\n");
  
  return Qnil;
}


SWIGINTERN void
free_XMLOutputStream(XMLOutputStream *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassXMLInputStream;

SWIGINTERN VALUE
_wrap_new_XMLInputStream__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  std::string arg3 ;
  XMLErrorLog *arg4 = (XMLErrorLog *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  XMLInputStream *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","XMLInputStream", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","XMLInputStream", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","XMLInputStream", 3, argv[2] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "XMLErrorLog *","XMLInputStream", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< XMLErrorLog * >(argp4);
  result = (XMLInputStream *)new XMLInputStream((char const *)arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLInputStream__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  std::string arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  XMLInputStream *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","XMLInputStream", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","XMLInputStream", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","XMLInputStream", 3, argv[2] )); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (XMLInputStream *)new XMLInputStream((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLInputStream__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  XMLInputStream *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","XMLInputStream", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","XMLInputStream", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (XMLInputStream *)new XMLInputStream((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLInputStream_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLInputStream_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLInputStream);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLInputStream__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  XMLInputStream *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","XMLInputStream", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (XMLInputStream *)new XMLInputStream((char const *)arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLInputStream(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLInputStream__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLInputStream__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLInputStream__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_XMLErrorLog, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_XMLInputStream__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLInputStream.new", 
    "    XMLInputStream.new(char const *content, bool isFile, std::string const library, XMLErrorLog *errorLog)\n"
    "    XMLInputStream.new(char const *content, bool isFile, std::string const library)\n"
    "    XMLInputStream.new(char const *content, bool isFile)\n"
    "    XMLInputStream.new(char const *content)\n");
  
  return Qnil;
}


SWIGINTERN void
free_XMLInputStream(XMLInputStream *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_XMLInputStream_getEncoding(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","getEncoding", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (std::string *) &(arg1)->getEncoding();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_getVersion(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (std::string *) &(arg1)->getVersion();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_getErrorLog(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLErrorLog *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","getErrorLog", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (XMLErrorLog *)(arg1)->getErrorLog();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_isEOF(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream const *","isEOF", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (bool)((XMLInputStream const *)arg1)->isEOF();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_isError(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream const *","isError", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (bool)((XMLInputStream const *)arg1)->isError();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_isGood(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream const *","isGood", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (bool)((XMLInputStream const *)arg1)->isGood();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_next(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLToken result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (arg1)->next();
  vresult = SWIG_NewPointerObj((new XMLToken(static_cast< const XMLToken& >(result))), SWIGTYPE_p_XMLToken, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_peek(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLToken *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","peek", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (XMLToken *) &(arg1)->peek();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_skipPastEnd(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  XMLToken *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","skipPastEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_XMLToken,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLToken const &","skipPastEnd", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLToken const &","skipPastEnd", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< XMLToken * >(argp2);
  (arg1)->skipPastEnd((XMLToken const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_skipText(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","skipText", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  (arg1)->skipText();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_setErrorLog(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  XMLErrorLog *arg2 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","setErrorLog", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "XMLErrorLog *","setErrorLog", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< XMLErrorLog * >(argp2);
  result = (int)(arg1)->setErrorLog(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_toString(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (arg1)->toString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_getSBMLNamespaces(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","getSBMLNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  result = (SBMLNamespaces *)(arg1)->getSBMLNamespaces();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLInputStream_setSBMLNamespaces(int argc, VALUE *argv, VALUE self) {
  XMLInputStream *arg1 = (XMLInputStream *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLInputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLInputStream *","setSBMLNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLInputStream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLNamespaces *","setSBMLNamespaces", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  (arg1)->setSBMLNamespaces(arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassXMLError;

SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  XMLError *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLError", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLError", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLError", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","XMLError", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","XMLError", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4,arg5,arg6);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  XMLError *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLError", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLError", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLError", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","XMLError", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4,arg5);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  XMLError *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLError", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLError", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","XMLError", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_3(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  XMLError *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLError", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLError", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","XMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_4(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  XMLError *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","XMLError", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","XMLError", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_5(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  XMLError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      result = (XMLError *)new XMLError(arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_6(int argc, VALUE *argv, VALUE self) {
  XMLError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    try {
      result = (XMLError *)new XMLError();
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_XMLError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLError__SWIG_7(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  XMLError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLError,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const &","XMLError", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLError const &","XMLError", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  {
    try {
      result = (XMLError *)new XMLError((XMLError const &)*arg1);
      DATA_PTR(self) = result;
      SWIG_RubyAddTracking(result, self);
    }
    catch (const XMLConstructorException &e){
      static VALUE cpperror = rb_define_class("XMLConstructorException", rb_eArgError);
      rb_raise(cpperror, e.what());    
    }
  }
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLError__SWIG_6(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLError, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLError__SWIG_7(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_XMLError__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLError__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLError__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLError__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLError__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_XMLError__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "XMLError.new", 
    "    XMLError.new(int const errorId, std::string const &details, unsigned int const line, unsigned int const column, unsigned int const severity, unsigned int const category)\n"
    "    XMLError.new(int const errorId, std::string const &details, unsigned int const line, unsigned int const column, unsigned int const severity)\n"
    "    XMLError.new(int const errorId, std::string const &details, unsigned int const line, unsigned int const column)\n"
    "    XMLError.new(int const errorId, std::string const &details, unsigned int const line)\n"
    "    XMLError.new(int const errorId, std::string const &details)\n"
    "    XMLError.new(int const errorId)\n"
    "    XMLError.new()\n"
    "    XMLError.new(XMLError const &orig)\n");
  
  return Qnil;
}


SWIGINTERN void
free_XMLError(XMLError *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_XMLError_getErrorId(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getErrorId", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getErrorId();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getMessage(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getMessage();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getShortMessage(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getShortMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getShortMessage();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getLine(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getLine", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getLine();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getColumn(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getColumn", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getColumn();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getSeverity(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getSeverity", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getSeverity();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getSeverityAsString(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getSeverityAsString", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getSeverityAsString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getCategory(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getCategory", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getCategory();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getCategoryAsString(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","getCategoryAsString", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getCategoryAsString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isInfo(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isInfo", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isInfo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isWarning(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isWarning", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isWarning();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isError(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isError", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isError();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isFatal(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isFatal", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isFatal();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isInternal(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isInternal();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isSystem(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isSystem", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isSystem();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_isXML(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError const *","isXML", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isXML();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_setLine(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError *","setLine", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setLine", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setLine(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_setColumn(int argc, VALUE *argv, VALUE self) {
  XMLError *arg1 = (XMLError *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLError *","setColumn", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setColumn", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setColumn(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLError_getStandardMessage(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","XMLError::getStandardMessage", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = XMLError::getStandardMessage(arg1);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassXMLErrorLog;

SWIGINTERN VALUE
_wrap_XMLErrorLog_getNumErrors(int argc, VALUE *argv, VALUE self) {
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLErrorLog const *","getNumErrors", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  result = (unsigned int)((XMLErrorLog const *)arg1)->getNumErrors();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLErrorLog_getError(int argc, VALUE *argv, VALUE self) {
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  XMLError *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLErrorLog const *","getError", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getError", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLError *)((XMLErrorLog const *)arg1)->getError(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLErrorLog_clearLog(int argc, VALUE *argv, VALUE self) {
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLErrorLog *","clearLog", 1, self )); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  (arg1)->clearLog();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_XMLErrorLog(XMLErrorLog *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSBMLErrorLog;

SWIGINTERN VALUE
_wrap_SBMLErrorLog_getError(int argc, VALUE *argv, VALUE self) {
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLError *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLErrorLog const *","getError", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getError", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)((SBMLErrorLog const *)arg1)->getError(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLErrorLog_getNumFailsWithSeverity(int argc, VALUE *argv, VALUE self) {
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLErrorLog *","getNumFailsWithSeverity", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getNumFailsWithSeverity", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (unsigned int)(arg1)->getNumFailsWithSeverity(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBMLErrorLog(SBMLErrorLog *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSBMLError;

SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","SBMLError", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLError", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 7, argv[6] ));
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 8, argv[7] ));
  } 
  arg8 = static_cast< unsigned int >(val8);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6,arg7,arg8);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","SBMLError", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLError", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 7, argv[6] ));
  } 
  arg7 = static_cast< unsigned int >(val7);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","SBMLError", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLError", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_3(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","SBMLError", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLError", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_4(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  SBMLError *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","SBMLError", 4, argv[3] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLError", 4, argv[3])); 
    }
    arg4 = ptr;
  }
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_5(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_6(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)new SBMLError(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_7(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","SBMLError", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLError *)new SBMLError(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_8(int argc, VALUE *argv, VALUE self) {
  SBMLError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLError *)new SBMLError();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLError__SWIG_9(int argc, VALUE *argv, VALUE self) {
  SBMLError *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SBMLError *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SBMLError,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLError const &","SBMLError", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SBMLError const &","SBMLError", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SBMLError * >(argp1);
  result = (SBMLError *)new SBMLError((SBMLError const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SBMLError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[8];
  int ii;
  
  argc = nargs;
  if (argc > 8) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SBMLError__SWIG_8(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLError, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLError__SWIG_9(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLError__SWIG_7(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLError__SWIG_6(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_SBMLError__SWIG_5(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SBMLError__SWIG_4(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_SBMLError__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_SBMLError__SWIG_2(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_SBMLError__SWIG_1(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_SBMLError__SWIG_0(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 8, "SBMLError.new", 
    "    SBMLError.new(unsigned int const errorId, unsigned int const level, unsigned int const version, std::string const &details, unsigned int const line, unsigned int const column, unsigned int const severity, unsigned int const category)\n"
    "    SBMLError.new(unsigned int const errorId, unsigned int const level, unsigned int const version, std::string const &details, unsigned int const line, unsigned int const column, unsigned int const severity)\n"
    "    SBMLError.new(unsigned int const errorId, unsigned int const level, unsigned int const version, std::string const &details, unsigned int const line, unsigned int const column)\n"
    "    SBMLError.new(unsigned int const errorId, unsigned int const level, unsigned int const version, std::string const &details, unsigned int const line)\n"
    "    SBMLError.new(unsigned int const errorId, unsigned int const level, unsigned int const version, std::string const &details)\n"
    "    SBMLError.new(unsigned int const errorId, unsigned int const level, unsigned int const version)\n"
    "    SBMLError.new(unsigned int const errorId, unsigned int const level)\n"
    "    SBMLError.new(unsigned int const errorId)\n"
    "    SBMLError.new()\n"
    "    SBMLError.new(SBMLError const &orig)\n");
  
  return Qnil;
}


SWIGINTERN void
free_SBMLError(SBMLError *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassCVTerm;

SWIGINTERN VALUE
_wrap_new_CVTerm__SWIG_0(int argc, VALUE *argv, VALUE self) {
  QualifierType_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  CVTerm *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "QualifierType_t","CVTerm", 1, argv[0] ));
  } 
  arg1 = static_cast< QualifierType_t >(val1);
  result = (CVTerm *)new CVTerm(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_CVTerm__SWIG_1(int argc, VALUE *argv, VALUE self) {
  CVTerm *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (CVTerm *)new CVTerm();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_CVTerm__SWIG_2(int argc, VALUE *argv, VALUE self) {
  XMLNode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  CVTerm *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLNode,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const","CVTerm", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNode const","CVTerm", 1, argv[0]));
    } else {
      arg1 = *(reinterpret_cast< XMLNode * >(argp1));
    }
  }
  result = (CVTerm *)new CVTerm(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_CVTerm(CVTerm *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CVTerm_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CVTerm_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_CVTerm);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CVTerm__SWIG_3(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  CVTerm *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_CVTerm,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm const &","CVTerm", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "CVTerm const &","CVTerm", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (CVTerm *)new CVTerm((CVTerm const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_CVTerm(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_CVTerm__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CVTerm__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CVTerm__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CVTerm__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "CVTerm.new", 
    "    CVTerm.new(QualifierType_t type)\n"
    "    CVTerm.new()\n"
    "    CVTerm.new(XMLNode const node)\n"
    "    CVTerm.new(CVTerm const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::CVTerm.clone

  call-seq:
    clone -> CVTerm

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_CVTerm_clone(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CVTerm *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (CVTerm *)((CVTerm const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getQualifierType(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  QualifierType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","getQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (QualifierType_t)(arg1)->getQualifierType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getModelQualifierType(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelQualifierType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","getModelQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (ModelQualifierType_t)(arg1)->getModelQualifierType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getBiologicalQualifierType(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BiolQualifierType_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","getBiologicalQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (BiolQualifierType_t)(arg1)->getBiologicalQualifierType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getResources__SWIG_0(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLAttributes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","getResources", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (XMLAttributes *)(arg1)->getResources();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getResources__SWIG_1(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLAttributes *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm const *","getResources", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (XMLAttributes *)((CVTerm const *)arg1)->getResources();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_CVTerm_getResources(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CVTerm_getResources__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CVTerm_getResources__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "CVTerm.getResources", 
    "    XMLAttributes const * CVTerm.getResources()\n"
    "    XMLAttributes const * CVTerm.getResources()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getNumResources(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","getNumResources", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (unsigned int)(arg1)->getNumResources();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_getResourceURI(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","getResourceURI", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getResourceURI", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (arg1)->getResourceURI(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_setQualifierType(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  QualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","setQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "QualifierType_t","setQualifierType", 2, argv[0] ));
  } 
  arg2 = static_cast< QualifierType_t >(val2);
  result = (int)(arg1)->setQualifierType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_setModelQualifierType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  ModelQualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","setModelQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ModelQualifierType_t","setModelQualifierType", 2, argv[0] ));
  } 
  arg2 = static_cast< ModelQualifierType_t >(val2);
  result = (int)(arg1)->setModelQualifierType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_setBiologicalQualifierType__SWIG_0(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  BiolQualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","setBiologicalQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "BiolQualifierType_t","setBiologicalQualifierType", 2, argv[0] ));
  } 
  arg2 = static_cast< BiolQualifierType_t >(val2);
  result = (int)(arg1)->setBiologicalQualifierType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_setModelQualifierType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","setModelQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setModelQualifierType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setModelQualifierType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setModelQualifierType((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_CVTerm_setModelQualifierType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CVTerm_setModelQualifierType__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CVTerm_setModelQualifierType__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "CVTerm.setModelQualifierType", 
    "    int CVTerm.setModelQualifierType(ModelQualifierType_t type)\n"
    "    int CVTerm.setModelQualifierType(std::string const &qualifier)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_setBiologicalQualifierType__SWIG_1(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","setBiologicalQualifierType", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setBiologicalQualifierType", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setBiologicalQualifierType", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setBiologicalQualifierType((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_CVTerm_setBiologicalQualifierType(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CVTerm_setBiologicalQualifierType__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CVTerm_setBiologicalQualifierType__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "CVTerm.setBiologicalQualifierType", 
    "    int CVTerm.setBiologicalQualifierType(BiolQualifierType_t type)\n"
    "    int CVTerm.setBiologicalQualifierType(std::string const &qualifier)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_addResource(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","addResource", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","addResource", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","addResource", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->addResource((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_removeResource(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","removeResource", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","removeResource", 2, argv[0] )); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->removeResource(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_CVTerm_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "CVTerm *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassDate;

SWIGINTERN VALUE
_wrap_new_Date__SWIG_0(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  unsigned int val9 ;
  int ecode9 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Date", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","Date", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","Date", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "unsigned int","Date", 7, argv[6] ));
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "unsigned int","Date", 8, argv[7] ));
  } 
  arg8 = static_cast< unsigned int >(val8);
  ecode9 = SWIG_AsVal_unsigned_SS_int(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "unsigned int","Date", 9, argv[8] ));
  } 
  arg9 = static_cast< unsigned int >(val9);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Date", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","Date", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","Date", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "unsigned int","Date", 7, argv[6] ));
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "unsigned int","Date", 8, argv[7] ));
  } 
  arg8 = static_cast< unsigned int >(val8);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Date", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","Date", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","Date", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "unsigned int","Date", 7, argv[6] ));
  } 
  arg7 = static_cast< unsigned int >(val7);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_3(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Date", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","Date", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "unsigned int","Date", 6, argv[5] ));
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_4(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Date", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned int","Date", 5, argv[4] ));
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_5(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Date", 4, argv[3] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (Date *)new Date(arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_6(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Date", 3, argv[2] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (Date *)new Date(arg1,arg2,arg3);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_7(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","Date", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)new Date(arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_8(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","Date", 1, argv[0] ));
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (Date *)new Date(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_9(int argc, VALUE *argv, VALUE self) {
  Date *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (Date *)new Date();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Date__SWIG_10(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  Date *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","Date", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Date", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (Date *)new Date((std::string const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_Date(Date *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Date_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Date_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Date);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Date__SWIG_11(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  Date *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_Date,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date const &","Date", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "Date const &","Date", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (Date *)new Date((Date const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Date(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[9];
  int ii;
  
  argc = nargs;
  if (argc > 9) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Date__SWIG_9(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Date, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Date__SWIG_11(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Date__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Date__SWIG_10(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Date__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Date__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_Date__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_Date__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_Date__SWIG_3(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_Date__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_Date__SWIG_1(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_unsigned_SS_int(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_Date__SWIG_0(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 9, "Date.new", 
    "    Date.new(unsigned int year, unsigned int month, unsigned int day, unsigned int hour, unsigned int minute, unsigned int second, unsigned int sign, unsigned int hoursOffset, unsigned int minutesOffset)\n"
    "    Date.new(unsigned int year, unsigned int month, unsigned int day, unsigned int hour, unsigned int minute, unsigned int second, unsigned int sign, unsigned int hoursOffset)\n"
    "    Date.new(unsigned int year, unsigned int month, unsigned int day, unsigned int hour, unsigned int minute, unsigned int second, unsigned int sign)\n"
    "    Date.new(unsigned int year, unsigned int month, unsigned int day, unsigned int hour, unsigned int minute, unsigned int second)\n"
    "    Date.new(unsigned int year, unsigned int month, unsigned int day, unsigned int hour, unsigned int minute)\n"
    "    Date.new(unsigned int year, unsigned int month, unsigned int day, unsigned int hour)\n"
    "    Date.new(unsigned int year, unsigned int month, unsigned int day)\n"
    "    Date.new(unsigned int year, unsigned int month)\n"
    "    Date.new(unsigned int year)\n"
    "    Date.new()\n"
    "    Date.new(std::string const &date)\n"
    "    Date.new(Date const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::Date.clone

  call-seq:
    clone -> Date

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_Date_clone(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Date *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (Date *)((Date const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getYear(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getYear", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getYear();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getMonth(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getMonth", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMonth();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getDay(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getDay", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getDay();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getHour(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getHour", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getHour();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getMinute(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getMinute", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMinute();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getSecond(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getSecond", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getSecond();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getSignOffset(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getSignOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getSignOffset();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getHoursOffset(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getHoursOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getHoursOffset();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getMinutesOffset(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getMinutesOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMinutesOffset();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_getDateAsString(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","getDateAsString", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (std::string *) &(arg1)->getDateAsString();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setYear(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setYear", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setYear", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setYear(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setMonth(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setMonth", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setMonth", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMonth(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setDay(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setDay", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setDay", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setDay(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setHour(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setHour", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setHour", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setHour(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setMinute(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setMinute", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setMinute", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMinute(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setSecond(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setSecond", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setSecond", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSecond(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setSignOffset(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setSignOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setSignOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSignOffset(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setHoursOffset(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setHoursOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setHoursOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setHoursOffset(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setMinutesOffset(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setMinutesOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setMinutesOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMinutesOffset(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_setDateAsString(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","setDateAsString", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setDateAsString", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setDateAsString", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setDateAsString((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Date_representsValidDate(int argc, VALUE *argv, VALUE self) {
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "Date *","representsValidDate", 1, self )); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (bool)(arg1)->representsValidDate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassModelCreator;

SWIGINTERN VALUE
_wrap_new_ModelCreator__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ModelCreator *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ModelCreator *)new ModelCreator();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ModelCreator__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  ModelCreator *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_XMLNode,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const","ModelCreator", 1, argv[0] )); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "XMLNode const","ModelCreator", 1, argv[0]));
    } else {
      arg1 = *(reinterpret_cast< XMLNode * >(argp1));
    }
  }
  result = (ModelCreator *)new ModelCreator(arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ModelCreator(ModelCreator *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ModelCreator_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ModelCreator_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ModelCreator);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ModelCreator__SWIG_2(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  ModelCreator *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ModelCreator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const &","ModelCreator", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ModelCreator const &","ModelCreator", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (ModelCreator *)new ModelCreator((ModelCreator const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ModelCreator(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ModelCreator__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelCreator__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelCreator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelCreator__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ModelCreator.new", 
    "    ModelCreator.new()\n"
    "    ModelCreator.new(XMLNode const creator)\n"
    "    ModelCreator.new(ModelCreator const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ModelCreator.clone

  call-seq:
    clone -> ModelCreator

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ModelCreator_clone(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelCreator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (ModelCreator *)((ModelCreator const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_getFamilyName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const *","getFamilyName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getFamilyName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_getGivenName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const *","getGivenName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getGivenName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_getEmail(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const *","getEmail", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getEmail();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_getOrganization(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const *","getOrganization", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getOrganization();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_getOrganisation(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator const *","getOrganisation", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getOrganisation();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_isSetFamilyName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","isSetFamilyName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetFamilyName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_isSetGivenName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","isSetGivenName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetGivenName();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_isSetEmail(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","isSetEmail", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetEmail();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_isSetOrganization(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","isSetOrganization", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetOrganization();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_isSetOrganisation(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","isSetOrganisation", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetOrganisation();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_setFamilyName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","setFamilyName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setFamilyName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setFamilyName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFamilyName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_setGivenName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","setGivenName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setGivenName", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setGivenName", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setGivenName((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_setEmail(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","setEmail", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setEmail", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setEmail", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setEmail((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_setOrganization(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","setOrganization", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setOrganization", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setOrganization", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOrganization((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_setOrganisation(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","setOrganisation", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setOrganisation", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setOrganisation", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOrganisation((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_unsetFamilyName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","unsetFamilyName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetFamilyName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_unsetGivenName(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","unsetGivenName", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetGivenName();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_unsetEmail(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","unsetEmail", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetEmail();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_unsetOrganization(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","unsetOrganization", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetOrganization();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_unsetOrganisation(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","unsetOrganisation", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetOrganisation();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelCreator_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelCreator *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassModelHistory;

SWIGINTERN VALUE
_wrap_new_ModelHistory__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ModelHistory *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ModelHistory *)new ModelHistory();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_ModelHistory(ModelHistory *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ModelHistory_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ModelHistory_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ModelHistory);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ModelHistory__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  ModelHistory *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_ModelHistory,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory const &","ModelHistory", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "ModelHistory const &","ModelHistory", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (ModelHistory *)new ModelHistory((ModelHistory const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ModelHistory(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ModelHistory__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelHistory__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ModelHistory.new", 
    "    ModelHistory.new()\n"
    "    ModelHistory.new(ModelHistory const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::ModelHistory.clone

  call-seq:
    clone -> ModelHistory

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ModelHistory_clone(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelHistory *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (ModelHistory *)((ModelHistory const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getCreatedDate(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Date *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getCreatedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (Date *)(arg1)->getCreatedDate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getModifiedDate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Date *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getModifiedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (Date *)(arg1)->getModifiedDate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_isSetCreatedDate(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","isSetCreatedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->isSetCreatedDate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_isSetModifiedDate(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","isSetModifiedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->isSetModifiedDate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_setCreatedDate(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","setCreatedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Date *","setCreatedDate", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->setCreatedDate(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_setModifiedDate(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","setModifiedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Date *","setModifiedDate", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->setModifiedDate(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_addModifiedDate(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","addModifiedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "Date *","addModifiedDate", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->addModifiedDate(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getListModifiedDates(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  List *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getListModifiedDates", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (List *)(arg1)->getListModifiedDates();
  {
    ListWrapper<Date> *listw = (result != 0) ? new ListWrapper<Date>(result) : 0;
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_Date_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getModifiedDate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  Date *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getModifiedDate", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getModifiedDate", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)(arg1)->getModifiedDate(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ModelHistory_getModifiedDate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ModelHistory_getModifiedDate__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ModelHistory_getModifiedDate__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ModelHistory.getModifiedDate", 
    "    Date * ModelHistory.getModifiedDate()\n"
    "    Date * ModelHistory.getModifiedDate(unsigned int n)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getNumModifiedDates(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getNumModifiedDates", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (unsigned int)(arg1)->getNumModifiedDates();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_addCreator(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","addCreator", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ModelCreator *","addCreator", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  result = (int)(arg1)->addCreator(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getListCreators(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  List *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getListCreators", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (List *)(arg1)->getListCreators();
  {
    ListWrapper<ModelCreator> *listw = (result != 0) ? new ListWrapper<ModelCreator>(result) : 0;
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_ModelCreator_t,
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getCreator(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  ModelCreator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getCreator", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getCreator", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)(arg1)->getCreator(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_getNumCreators(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","getNumCreators", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (unsigned int)(arg1)->getNumCreators();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModelHistory_hasRequiredAttributes(int argc, VALUE *argv, VALUE self) {
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ModelHistory *","hasRequiredAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRDFAnnotationParser;

SWIGINTERN VALUE
_wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_0(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ModelHistory *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","RDFAnnotationParser::parseRDFAnnotation", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (ModelHistory *)RDFAnnotationParser::parseRDFAnnotation((XMLNode const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_createAnnotation(int argc, VALUE *argv, VALUE self) {
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (XMLNode *)RDFAnnotationParser::createAnnotation();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_createRDFAnnotation(int argc, VALUE *argv, VALUE self) {
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (XMLNode *)RDFAnnotationParser::createRDFAnnotation();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_deleteRDFAnnotation(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","RDFAnnotationParser::deleteRDFAnnotation", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::deleteRDFAnnotation((XMLNode const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_createRDFDescription(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","RDFAnnotationParser::createRDFDescription", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::createRDFDescription((SBase const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_createCVTerms(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","RDFAnnotationParser::createCVTerms", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::createCVTerms((SBase const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_parseCVTerms(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","RDFAnnotationParser::parseCVTerms", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::parseCVTerms((SBase const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_parseModelHistory(int argc, VALUE *argv, VALUE self) {
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  XMLNode *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBase const *","RDFAnnotationParser::parseModelHistory", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::parseModelHistory((SBase const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_1(int argc, VALUE *argv, VALUE self) {
  XMLNode *arg1 = (XMLNode *) 0 ;
  ListWrapper< CVTerm > *arg2 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "XMLNode const *","RDFAnnotationParser_parseRDFAnnotation__SWIG_1", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "ListWrapper< CVTerm > *","RDFAnnotationParser_parseRDFAnnotation__SWIG_1", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< ListWrapper< CVTerm > * >(argp2);
  RDFAnnotationParser_parseRDFAnnotation__SWIG_1((XMLNode const *)arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RDFAnnotationParser_parseRDFAnnotation(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_ListWrapperT_CVTerm_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RDFAnnotationParser.parseRDFAnnotation", 
    "    void RDFAnnotationParser.parseRDFAnnotation(XMLNode const *annotation)\n"
    "    void RDFAnnotationParser.parseRDFAnnotation(XMLNode const *annotation, ListWrapper< CVTerm > *CVTerms)\n");
  
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RDFAnnotationParser_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RDFAnnotationParser_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_RDFAnnotationParser);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RDFAnnotationParser(int argc, VALUE *argv, VALUE self) {
  RDFAnnotationParser *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (RDFAnnotationParser *)new RDFAnnotationParser();
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_RDFAnnotationParser(RDFAnnotationParser *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassISBMLExtensionNamespaces;

SWIGINTERN void
free_ISBMLExtensionNamespaces(ISBMLExtensionNamespaces *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ISBMLExtensionNamespaces_getURI(int argc, VALUE *argv, VALUE self) {
  ISBMLExtensionNamespaces *arg1 = (ISBMLExtensionNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ISBMLExtensionNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ISBMLExtensionNamespaces const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< ISBMLExtensionNamespaces * >(argp1);
  result = ((ISBMLExtensionNamespaces const *)arg1)->getURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ISBMLExtensionNamespaces_getPackageVersion(int argc, VALUE *argv, VALUE self) {
  ISBMLExtensionNamespaces *arg1 = (ISBMLExtensionNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ISBMLExtensionNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ISBMLExtensionNamespaces const *","getPackageVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< ISBMLExtensionNamespaces * >(argp1);
  result = (unsigned int)((ISBMLExtensionNamespaces const *)arg1)->getPackageVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ISBMLExtensionNamespaces_getPackageName(int argc, VALUE *argv, VALUE self) {
  ISBMLExtensionNamespaces *arg1 = (ISBMLExtensionNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ISBMLExtensionNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ISBMLExtensionNamespaces const *","getPackageName", 1, self )); 
  }
  arg1 = reinterpret_cast< ISBMLExtensionNamespaces * >(argp1);
  result = (std::string *) &((ISBMLExtensionNamespaces const *)arg1)->getPackageName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ISBMLExtensionNamespaces_setPackageVersion(int argc, VALUE *argv, VALUE self) {
  ISBMLExtensionNamespaces *arg1 = (ISBMLExtensionNamespaces *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ISBMLExtensionNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ISBMLExtensionNamespaces *","setPackageVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< ISBMLExtensionNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","setPackageVersion", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->setPackageVersion(arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassSBaseExtensionPoint;

SWIGINTERN VALUE
_wrap_new_SBaseExtensionPoint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  int val2 ;
  int ecode2 = 0 ;
  SBaseExtensionPoint *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SBaseExtensionPoint", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBaseExtensionPoint", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SBaseExtensionPoint", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (SBaseExtensionPoint *)new SBaseExtensionPoint((std::string const &)*arg1,arg2);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBaseExtensionPoint_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBaseExtensionPoint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBaseExtensionPoint);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBaseExtensionPoint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBaseExtensionPoint *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SBaseExtensionPoint *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SBaseExtensionPoint,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBaseExtensionPoint const &","SBaseExtensionPoint", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SBaseExtensionPoint const &","SBaseExtensionPoint", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SBaseExtensionPoint * >(argp1);
  result = (SBaseExtensionPoint *)new SBaseExtensionPoint((SBaseExtensionPoint const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SBaseExtensionPoint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBaseExtensionPoint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBaseExtensionPoint__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBaseExtensionPoint__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBaseExtensionPoint.new", 
    "    SBaseExtensionPoint.new(std::string const &pkgName, int typeCode)\n"
    "    SBaseExtensionPoint.new(SBaseExtensionPoint const &orig)\n");
  
  return Qnil;
}



/*
  Document-method: LibSBML::SBaseExtensionPoint.clone

  call-seq:
    clone -> SBaseExtensionPoint

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBaseExtensionPoint_clone(int argc, VALUE *argv, VALUE self) {
  SBaseExtensionPoint *arg1 = (SBaseExtensionPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBaseExtensionPoint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBaseExtensionPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBaseExtensionPoint const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBaseExtensionPoint * >(argp1);
  result = (SBaseExtensionPoint *)((SBaseExtensionPoint const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBaseExtensionPoint, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBaseExtensionPoint_getPackageName(int argc, VALUE *argv, VALUE self) {
  SBaseExtensionPoint *arg1 = (SBaseExtensionPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBaseExtensionPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBaseExtensionPoint const *","getPackageName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBaseExtensionPoint * >(argp1);
  result = (std::string *) &((SBaseExtensionPoint const *)arg1)->getPackageName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBaseExtensionPoint_getTypeCode(int argc, VALUE *argv, VALUE self) {
  SBaseExtensionPoint *arg1 = (SBaseExtensionPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBaseExtensionPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBaseExtensionPoint const *","getTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< SBaseExtensionPoint * >(argp1);
  result = (int)((SBaseExtensionPoint const *)arg1)->getTypeCode();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_SBaseExtensionPoint(SBaseExtensionPoint *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSBasePlugin;

SWIGINTERN void
free_SBasePlugin(SBasePlugin *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SBasePlugin_getURI(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (std::string *) &((SBasePlugin const *)arg1)->getURI();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getPrefix(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (std::string *) &((SBasePlugin const *)arg1)->getPrefix();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getPackageName(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getPackageName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (std::string *) &((SBasePlugin const *)arg1)->getPackageName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::SBasePlugin.clone

  call-seq:
    clone -> SBasePlugin

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBasePlugin_clone(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBasePlugin *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (SBasePlugin *)((SBasePlugin const *)arg1)->clone();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_connectToParent(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin *","connectToParent", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBase *","connectToParent", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  (arg1)->connectToParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_enablePackageInternal(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin *","enablePackageInternal", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","enablePackageInternal", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","enablePackageInternal", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","enablePackageInternal", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->enablePackageInternal((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getSBMLDocument__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin *","getSBMLDocument", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (SBMLDocument *)(arg1)->getSBMLDocument();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getSBMLDocument__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocument *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getSBMLDocument", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (SBMLDocument *)((SBasePlugin const *)arg1)->getSBMLDocument();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBasePlugin_getSBMLDocument(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBasePlugin, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBasePlugin_getSBMLDocument__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBasePlugin, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBasePlugin_getSBMLDocument__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBasePlugin.getSBMLDocument", 
    "    SBMLDocument const * SBasePlugin.getSBMLDocument()\n"
    "    SBMLDocument const * SBasePlugin.getSBMLDocument()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getParentSBMLObject__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin *","getParentSBMLObject", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (SBase *)(arg1)->getParentSBMLObject();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getParentSBMLObject__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBase *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getParentSBMLObject", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (SBase *)((SBasePlugin const *)arg1)->getParentSBMLObject();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SBasePlugin_getParentSBMLObject(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBasePlugin, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBasePlugin_getParentSBMLObject__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBasePlugin, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBasePlugin_getParentSBMLObject__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SBasePlugin.getParentSBMLObject", 
    "    SBase const * SBasePlugin.getParentSBMLObject()\n"
    "    SBase const * SBasePlugin.getParentSBMLObject()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getLevel(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (unsigned int)((SBasePlugin const *)arg1)->getLevel();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getVersion(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (unsigned int)((SBasePlugin const *)arg1)->getVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBasePlugin_getPackageVersion(int argc, VALUE *argv, VALUE self) {
  SBasePlugin *arg1 = (SBasePlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBasePlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBasePlugin const *","getPackageVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBasePlugin * >(argp1);
  result = (unsigned int)((SBasePlugin const *)arg1)->getPackageVersion();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLDocumentPlugin;

SWIGINTERN VALUE
_wrap_new_SBMLDocumentPlugin__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  SBMLNamespaces *arg3 = (SBMLNamespaces *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  SBMLDocumentPlugin *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SBMLDocumentPlugin", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLDocumentPlugin", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SBMLDocumentPlugin", 2, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLDocumentPlugin", 2, argv[1])); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "SBMLNamespaces *","SBMLDocumentPlugin", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< SBMLNamespaces * >(argp3);
  result = (SBMLDocumentPlugin *)new SBMLDocumentPlugin((std::string const &)*arg1,(std::string const &)*arg2,arg3);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLDocumentPlugin_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLDocumentPlugin_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLDocumentPlugin);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLDocumentPlugin__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SBMLDocumentPlugin *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  SBMLDocumentPlugin *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_SBMLDocumentPlugin,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocumentPlugin const &","SBMLDocumentPlugin", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SBMLDocumentPlugin const &","SBMLDocumentPlugin", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< SBMLDocumentPlugin * >(argp1);
  result = (SBMLDocumentPlugin *)new SBMLDocumentPlugin((SBMLDocumentPlugin const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SBMLDocumentPlugin(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocumentPlugin, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLDocumentPlugin__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SBMLDocumentPlugin__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SBMLDocumentPlugin.new", 
    "    SBMLDocumentPlugin.new(std::string const &uri, std::string const &prefix, SBMLNamespaces *sbmlns)\n"
    "    SBMLDocumentPlugin.new(SBMLDocumentPlugin const &orig)\n");
  
  return Qnil;
}


SWIGINTERN void
free_SBMLDocumentPlugin(SBMLDocumentPlugin *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/*
  Document-method: LibSBML::SBMLDocumentPlugin.clone

  call-seq:
    clone -> SBMLDocumentPlugin

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBMLDocumentPlugin_clone(int argc, VALUE *argv, VALUE self) {
  SBMLDocumentPlugin *arg1 = (SBMLDocumentPlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLDocumentPlugin *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocumentPlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocumentPlugin const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocumentPlugin * >(argp1);
  result = (SBMLDocumentPlugin *)((SBMLDocumentPlugin const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocumentPlugin, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocumentPlugin_getRequired(int argc, VALUE *argv, VALUE self) {
  SBMLDocumentPlugin *arg1 = (SBMLDocumentPlugin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocumentPlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocumentPlugin const *","getRequired", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocumentPlugin * >(argp1);
  result = (bool)((SBMLDocumentPlugin const *)arg1)->getRequired();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLDocumentPlugin_setRequired(int argc, VALUE *argv, VALUE self) {
  SBMLDocumentPlugin *arg1 = (SBMLDocumentPlugin *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLDocumentPlugin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLDocumentPlugin *","setRequired", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLDocumentPlugin * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setRequired", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setRequired(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLExtension;

SWIGINTERN void
free_SBMLExtension(SBMLExtension *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SBMLExtension_getNumOfSBasePlugins(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getNumOfSBasePlugins", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  result = (int)((SBMLExtension const *)arg1)->getNumOfSBasePlugins();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getNumOfSupportedPackageURI(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getNumOfSupportedPackageURI", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  result = (unsigned int)((SBMLExtension const *)arg1)->getNumOfSupportedPackageURI();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_isSupported(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","isSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isSupported", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isSupported", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)((SBMLExtension const *)arg1)->isSupported((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getSupportedPackageURI(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getSupportedPackageURI", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getSupportedPackageURI", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (std::string *) &((SBMLExtension const *)arg1)->getSupportedPackageURI(arg2);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: LibSBML::SBMLExtension.clone

  call-seq:
    clone -> SBMLExtension

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SBMLExtension_clone(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SBMLExtension *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  result = (SBMLExtension *)((SBMLExtension const *)arg1)->clone();
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), SWIG_POINTER_OWN |  0 );
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getName(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  result = (std::string *) &((SBMLExtension const *)arg1)->getName();
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getURI(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  std::string *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getURI", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","getURI", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","getURI", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","getURI", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (std::string *) &((SBMLExtension const *)arg1)->getURI(arg2,arg3,arg4);
  vresult = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getLevel(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getLevel", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getLevel", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (unsigned int)((SBMLExtension const *)arg1)->getLevel((std::string const &)*arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getVersion(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getVersion", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getVersion", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (unsigned int)((SBMLExtension const *)arg1)->getVersion((std::string const &)*arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getPackageVersion(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getPackageVersion", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getPackageVersion", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getPackageVersion", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (unsigned int)((SBMLExtension const *)arg1)->getPackageVersion((std::string const &)*arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getStringFromTypeCode(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getStringFromTypeCode", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getStringFromTypeCode", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (char *)((SBMLExtension const *)arg1)->getStringFromTypeCode(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_getSBMLExtensionNamespaces(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBMLNamespaces *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","getSBMLExtensionNamespaces", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getSBMLExtensionNamespaces", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getSBMLExtensionNamespaces", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBMLNamespaces *)((SBMLExtension const *)arg1)->getSBMLExtensionNamespaces((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_setEnabled(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension *","setEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setEnabled", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(arg1)->setEnabled(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtension_isEnabled(int argc, VALUE *argv, VALUE self) {
  SBMLExtension *arg1 = (SBMLExtension *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtension const *","isEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtension * >(argp1);
  result = (bool)((SBMLExtension const *)arg1)->isEnabled();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSBMLExtensionException;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SBMLExtensionException_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SBMLExtensionException_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SBMLExtensionException);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SBMLExtensionException(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  SBMLExtensionException *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","SBMLExtensionException", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SBMLExtensionException", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (SBMLExtensionException *)new SBMLExtensionException((std::string const &)*arg1);
  DATA_PTR(self) = result;
  SWIG_RubyAddTracking(result, self);
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_SBMLExtensionException(SBMLExtensionException *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}

swig_class SwigClassSBMLExtensionRegistry;

SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_getInstance(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (SBMLExtensionRegistry *) &SBMLExtensionRegistry::getInstance();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_addExtension(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *arg1 = (SBMLExtensionRegistry *) 0 ;
  SBMLExtension *arg2 = (SBMLExtension *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtensionRegistry *","addExtension", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtensionRegistry * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_SBMLExtension, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBMLExtension const *","addExtension", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< SBMLExtension * >(argp2);
  result = (int)(arg1)->addExtension((SBMLExtension const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_getExtension(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *arg1 = (SBMLExtensionRegistry *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  SBMLExtension *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtensionRegistry *","getExtension", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtensionRegistry * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","getExtension", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","getExtension", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (SBMLExtension *)(arg1)->getExtension((std::string const &)*arg2);
  {
    vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result), 0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_getNumExtension(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *arg1 = (SBMLExtensionRegistry *) 0 ;
  SBaseExtensionPoint *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtensionRegistry *","getNumExtension", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtensionRegistry * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_SBaseExtensionPoint,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "SBaseExtensionPoint const &","getNumExtension", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "SBaseExtensionPoint const &","getNumExtension", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< SBaseExtensionPoint * >(argp2);
  result = (unsigned int)(arg1)->getNumExtension((SBaseExtensionPoint const &)*arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_setEnabled(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *arg1 = (SBMLExtensionRegistry *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtensionRegistry *","setEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtensionRegistry * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","setEnabled", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","setEnabled", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setEnabled", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (bool)(arg1)->setEnabled((std::string const &)*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_isEnabled(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *arg1 = (SBMLExtensionRegistry *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtensionRegistry *","isEnabled", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtensionRegistry * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isEnabled", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isEnabled", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->isEnabled((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SBMLExtensionRegistry_isRegistered(int argc, VALUE *argv, VALUE self) {
  SBMLExtensionRegistry *arg1 = (SBMLExtensionRegistry *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SBMLExtensionRegistry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SBMLExtensionRegistry *","isRegistered", 1, self )); 
  }
  arg1 = reinterpret_cast< SBMLExtensionRegistry * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","isRegistered", 2, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","isRegistered", 2, argv[0])); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->isRegistered((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN void
free_SBMLExtensionRegistry(SBMLExtensionRegistry *arg1) {
    SWIG_RubyRemoveTracking(arg1);
    delete arg1;
}


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_SBMLConstructorExceptionTo_p_std__invalid_argument(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::invalid_argument *)  ((SBMLConstructorException *) x));
}
static void *_p_XMLConstructorExceptionTo_p_std__invalid_argument(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::invalid_argument *)  ((XMLConstructorException *) x));
}
static void *_p_SBMLExtensionExceptionTo_p_std__invalid_argument(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::invalid_argument *)  ((SBMLExtensionException *) x));
}
static void *_p_AlgebraicRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((AlgebraicRule *) x));
}
static void *_p_AssignmentRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((AssignmentRule *) x));
}
static void *_p_RateRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((RateRule *) x));
}
static void *_p_ISBMLExtensionNamespacesTo_p_SBMLNamespaces(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBMLNamespaces *)  ((ISBMLExtensionNamespaces *) x));
}
static void *_p_SpeciesReferenceTo_p_SimpleSpeciesReference(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SimpleSpeciesReference *)  ((SpeciesReference *) x));
}
static void *_p_ModifierSpeciesReferenceTo_p_SimpleSpeciesReference(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SimpleSpeciesReference *)  ((ModifierSpeciesReference *) x));
}
static void *_p_swig__IteratorTo_p_swig__ConstIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((swig::ConstIterator *)  ((swig::Iterator *) x));
}
static void *_p_XMLOutputStringStreamTo_p_XMLOutputStream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLOutputStream *)  ((XMLOutputStringStream *) x));
}
static void *_p_XMLOutputFileStreamTo_p_XMLOutputStream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLOutputStream *)  ((XMLOutputFileStream *) x));
}
static void *_p_ListOfReactionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfReactions *) x));
}
static void *_p_ListOfLocalParametersTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *) (ListOfParameters *) ((ListOfLocalParameters *) x));
}
static void *_p_ListOfParametersTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfParameters *) x));
}
static void *_p_ListOfRulesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfRules *) x));
}
static void *_p_ListOfEventsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfEvents *) x));
}
static void *_p_ListOfCompartmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfCompartments *) x));
}
static void *_p_ListOfCompartmentTypesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfCompartmentTypes *) x));
}
static void *_p_ListOfUnitDefinitionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfUnitDefinitions *) x));
}
static void *_p_ListOfFunctionDefinitionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfFunctionDefinitions *) x));
}
static void *_p_ListOfSpeciesTypesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpeciesTypes *) x));
}
static void *_p_ListOfSpeciesReferencesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpeciesReferences *) x));
}
static void *_p_ListOfInitialAssignmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfInitialAssignments *) x));
}
static void *_p_ListOfEventAssignmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfEventAssignments *) x));
}
static void *_p_ListOfConstraintsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfConstraints *) x));
}
static void *_p_ListOfUnitsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfUnits *) x));
}
static void *_p_ListOfSpeciesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpecies *) x));
}
static void *_p_ListOfLocalParametersTo_p_ListOfParameters(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOfParameters *)  ((ListOfLocalParameters *) x));
}
static void *_p_XMLNodeTo_p_XMLToken(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLToken *)  ((XMLNode *) x));
}
static void *_p_std__basic_ostreamT_char_std__char_traitsT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ios< char,std::char_traits< char > > *)  ((std::basic_ostream< char,std::char_traits< char > > *) x));
}
static void *_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ios< char,std::char_traits< char > > *) (std::basic_ostream< char > *) ((std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *) x));
}
static void *_p_SBMLDocumentPluginTo_p_SBasePlugin(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBasePlugin *)  ((SBMLDocumentPlugin *) x));
}
static void *_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ostream< char,std::char_traits< char > > *)  ((std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *) x));
}
static void *_p_SBMLErrorLogTo_p_XMLErrorLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLErrorLog *)  ((SBMLErrorLog *) x));
}
static void *_p_LocalParameterTo_p_Parameter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Parameter *)  ((LocalParameter *) x));
}
static void *_p_SBMLErrorTo_p_XMLError(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLError *)  ((SBMLError *) x));
}
static void *_p_ConstraintTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Constraint *) x));
}
static void *_p_RateRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((RateRule *) x));
}
static void *_p_ListOfTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((ListOf *) x));
}
static void *_p_UnitTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Unit *) x));
}
static void *_p_ListOfFunctionDefinitionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfFunctionDefinitions *) x));
}
static void *_p_ListOfUnitDefinitionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfUnitDefinitions *) x));
}
static void *_p_SimpleSpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SimpleSpeciesReference *) x));
}
static void *_p_SpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (SimpleSpeciesReference *) ((SpeciesReference *) x));
}
static void *_p_ModifierSpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (SimpleSpeciesReference *) ((ModifierSpeciesReference *) x));
}
static void *_p_InitialAssignmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((InitialAssignment *) x));
}
static void *_p_RuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Rule *) x));
}
static void *_p_ListOfLocalParametersTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *)(ListOfParameters *) ((ListOfLocalParameters *) x));
}
static void *_p_ListOfParametersTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfParameters *) x));
}
static void *_p_EventAssignmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((EventAssignment *) x));
}
static void *_p_AssignmentRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((AssignmentRule *) x));
}
static void *_p_SBMLDocumentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SBMLDocument *) x));
}
static void *_p_FunctionDefinitionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((FunctionDefinition *) x));
}
static void *_p_UnitDefinitionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((UnitDefinition *) x));
}
static void *_p_ListOfInitialAssignmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfInitialAssignments *) x));
}
static void *_p_AlgebraicRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((AlgebraicRule *) x));
}
static void *_p_ListOfEventAssignmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfEventAssignments *) x));
}
static void *_p_ListOfCompartmentTypesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfCompartmentTypes *) x));
}
static void *_p_EventTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Event *) x));
}
static void *_p_CompartmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Compartment *) x));
}
static void *_p_KineticLawTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((KineticLaw *) x));
}
static void *_p_ListOfEventsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfEvents *) x));
}
static void *_p_StoichiometryMathTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((StoichiometryMath *) x));
}
static void *_p_ModelTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Model *) x));
}
static void *_p_ListOfSpeciesTypesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpeciesTypes *) x));
}
static void *_p_ListOfRulesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfRules *) x));
}
static void *_p_ListOfSpeciesReferencesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpeciesReferences *) x));
}
static void *_p_ListOfConstraintsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfConstraints *) x));
}
static void *_p_DelayTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Delay *) x));
}
static void *_p_PriorityTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Priority *) x));
}
static void *_p_CompartmentTypeTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((CompartmentType *) x));
}
static void *_p_ListOfReactionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfReactions *) x));
}
static void *_p_LocalParameterTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Parameter *) ((LocalParameter *) x));
}
static void *_p_ParameterTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Parameter *) x));
}
static void *_p_ListOfSpeciesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpecies *) x));
}
static void *_p_SpeciesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Species *) x));
}
static void *_p_TriggerTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Trigger *) x));
}
static void *_p_ListOfUnitsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfUnits *) x));
}
static void *_p_SpeciesTypeTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SpeciesType *) x));
}
static void *_p_ReactionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Reaction *) x));
}
static void *_p_ListOfCompartmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfCompartments *) x));
}
static swig_type_info _swigt__p_ASTNode = {"_p_ASTNode", "ASTNode *|ASTNode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ASTNodeType_t = {"_p_ASTNodeType_t", "enum ASTNodeType_t *|ASTNodeType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AlgebraicRule = {"_p_AlgebraicRule", "AlgebraicRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AssignmentRule = {"_p_AssignmentRule", "AssignmentRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BiolQualifierType_t = {"_p_BiolQualifierType_t", "enum BiolQualifierType_t *|BiolQualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CVTerm = {"_p_CVTerm", "CVTerm *|CVTerm_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Compartment = {"_p_Compartment", "Compartment_t *|Compartment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CompartmentType = {"_p_CompartmentType", "CompartmentType *|CompartmentType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Constraint = {"_p_Constraint", "Constraint_t *|Constraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Date = {"_p_Date", "Date *|Date_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Delay = {"_p_Delay", "Delay *|Delay_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Event = {"_p_Event", "Event *|Event_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EventAssignment = {"_p_EventAssignment", "EventAssignment_t *|EventAssignment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExpectedAttributes = {"_p_ExpectedAttributes", "ExpectedAttributes *|ExpectedAttributes_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FunctionDefinition = {"_p_FunctionDefinition", "FunctionDefinition_t *|FunctionDefinition *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ISBMLExtensionNamespaces = {"_p_ISBMLExtensionNamespaces", "SBMLExtensionNamespaces_t *|ISBMLExtensionNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_InitialAssignment = {"_p_InitialAssignment", "InitialAssignment_t *|InitialAssignment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_KineticLaw = {"_p_KineticLaw", "KineticLaw *|KineticLaw_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_List = {"_p_List", "List *|List_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOf = {"_p_ListOf", "ListOf *|ListOf_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfCompartmentTypes = {"_p_ListOfCompartmentTypes", "ListOfCompartmentTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfCompartments = {"_p_ListOfCompartments", "ListOfCompartments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfConstraints = {"_p_ListOfConstraints", "ListOfConstraints *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfEventAssignments = {"_p_ListOfEventAssignments", "ListOfEventAssignments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfEvents = {"_p_ListOfEvents", "ListOfEvents *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfFunctionDefinitions = {"_p_ListOfFunctionDefinitions", "ListOfFunctionDefinitions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfInitialAssignments = {"_p_ListOfInitialAssignments", "ListOfInitialAssignments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfLocalParameters = {"_p_ListOfLocalParameters", "ListOfLocalParameters *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfParameters = {"_p_ListOfParameters", "ListOfParameters *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfReactions = {"_p_ListOfReactions", "ListOfReactions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfRules = {"_p_ListOfRules", "ListOfRules *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpecies = {"_p_ListOfSpecies", "ListOfSpecies *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpeciesReferences = {"_p_ListOfSpeciesReferences", "ListOfSpeciesReferences *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpeciesTypes = {"_p_ListOfSpeciesTypes", "ListOfSpeciesTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfUnitDefinitions = {"_p_ListOfUnitDefinitions", "ListOfUnitDefinitions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfUnits = {"_p_ListOfUnits", "ListOfUnits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_ASTNode_t = {"_p_ListWrapperT_ASTNode_t", "ListWrapper< ASTNode > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_CVTerm_t = {"_p_ListWrapperT_CVTerm_t", "ListWrapper< CVTerm > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_Date_t = {"_p_ListWrapperT_Date_t", "ListWrapper< Date > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_ModelCreator_t = {"_p_ListWrapperT_ModelCreator_t", "ListWrapper< ModelCreator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_SBMLNamespaces_t = {"_p_ListWrapperT_SBMLNamespaces_t", "ListWrapper< SBMLNamespaces > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LocalParameter = {"_p_LocalParameter", "LocalParameter *|LocalParameter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Model = {"_p_Model", "Model *|Model_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelCreator = {"_p_ModelCreator", "ModelCreator *|ModelCreator_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelHistory = {"_p_ModelHistory", "ModelHistory *|ModelHistory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelQualifierType_t = {"_p_ModelQualifierType_t", "enum ModelQualifierType_t *|ModelQualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModifierSpeciesReference = {"_p_ModifierSpeciesReference", "ModifierSpeciesReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OperationReturnValues_t = {"_p_OperationReturnValues_t", "enum OperationReturnValues_t *|OperationReturnValues_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Parameter = {"_p_Parameter", "Parameter *|Parameter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ParentMap__iterator = {"_p_ParentMap__iterator", "ParentIter *|ParentMap::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Priority = {"_p_Priority", "Priority *|Priority_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_QualifierType_t = {"_p_QualifierType_t", "enum QualifierType_t *|QualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RDFAnnotationParser = {"_p_RDFAnnotationParser", "RDFAnnotationParser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RateRule = {"_p_RateRule", "RateRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Reaction = {"_p_Reaction", "Reaction_t *|Reaction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rule = {"_p_Rule", "Rule_t *|Rule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RuleType_t = {"_p_RuleType_t", "enum RuleType_t *|RuleType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLConstructorException = {"_p_SBMLConstructorException", "SBMLConstructorException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLDocument = {"_p_SBMLDocument", "SBMLDocument_t *|SBMLDocument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLDocumentPlugin = {"_p_SBMLDocumentPlugin", "SBMLDocumentPlugin_t *|SBMLDocumentPlugin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLError = {"_p_SBMLError", "SBMLError *|SBMLError_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorCategory_t = {"_p_SBMLErrorCategory_t", "enum SBMLErrorCategory_t *|SBMLErrorCategory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorCode_t = {"_p_SBMLErrorCode_t", "enum SBMLErrorCode_t *|SBMLErrorCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorLog = {"_p_SBMLErrorLog", "SBMLErrorLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorSeverity_t = {"_p_SBMLErrorSeverity_t", "enum SBMLErrorSeverity_t *|SBMLErrorSeverity_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLExtension = {"_p_SBMLExtension", "SBMLExtension *|SBMLExtension_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLExtensionException = {"_p_SBMLExtensionException", "SBMLExtensionException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLExtensionRegistry = {"_p_SBMLExtensionRegistry", "SBMLExtensionRegistry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLNamespaces = {"_p_SBMLNamespaces", "SBMLNamespaces_t *|SBMLNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLReader = {"_p_SBMLReader", "SBMLReader *|SBMLReader_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLTransforms = {"_p_SBMLTransforms", "SBMLTransforms *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLTypeCode_t = {"_p_SBMLTypeCode_t", "enum SBMLTypeCode_t *|SBMLTypeCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLWriter = {"_p_SBMLWriter", "SBMLWriter *|SBMLWriter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBO = {"_p_SBO", "SBO *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBase = {"_p_SBase", "SBase_t *|SBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBaseExtensionPoint = {"_p_SBaseExtensionPoint", "SBaseExtensionPoint_t *|SBaseExtensionPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBasePlugin = {"_p_SBasePlugin", "SBasePlugin_t *|SBasePlugin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBasePluginCreatorBase = {"_p_SBasePluginCreatorBase", "SBasePluginCreatorBase_t *|SBasePluginCreatorBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SimpleSpeciesReference = {"_p_SimpleSpeciesReference", "SimpleSpeciesReference *|SpeciesReference_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Species = {"_p_Species", "Species_t *|Species *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SpeciesReference = {"_p_SpeciesReference", "SpeciesReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SpeciesType = {"_p_SpeciesType", "SpeciesType *|SpeciesType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StoichiometryMath = {"_p_StoichiometryMath", "StoichiometryMath_t *|StoichiometryMath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SupportedPackageURIList = {"_p_SupportedPackageURIList", "SupportedPackageURIList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SupportedPackageURIListIter = {"_p_SupportedPackageURIListIter", "SupportedPackageURIListIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SyntaxChecker = {"_p_SyntaxChecker", "SyntaxChecker *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Trigger = {"_p_Trigger", "Trigger *|Trigger_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Unit = {"_p_Unit", "Unit_t *|Unit *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UnitDefinition = {"_p_UnitDefinition", "UnitDefinition_t *|UnitDefinition *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UnitKind_t = {"_p_UnitKind_t", "enum UnitKind_t *|UnitKind_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLAttributes = {"_p_XMLAttributes", "XMLAttributes *|XMLAttributes_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLConstructorException = {"_p_XMLConstructorException", "XMLConstructorException *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLError = {"_p_XMLError", "XMLError *|XMLError_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorCategory_t = {"_p_XMLErrorCategory_t", "enum XMLErrorCategory_t *|XMLErrorCategory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorCode_t = {"_p_XMLErrorCode_t", "enum XMLErrorCode_t *|XMLErrorCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorLog = {"_p_XMLErrorLog", "XMLErrorLog *|XMLErrorLog_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorSeverity_t = {"_p_XMLErrorSeverity_t", "enum XMLErrorSeverity_t *|XMLErrorSeverity_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLInputStream = {"_p_XMLInputStream", "XMLInputStream *|XMLInputStream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLNamespaces = {"_p_XMLNamespaces", "XMLNamespaces_t *|XMLNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLNode = {"_p_XMLNode", "XMLNode *|XMLNode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLOutputStream = {"_p_XMLOutputStream", "XMLOutputStream *|XMLOutputStream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLOutputStringStream = {"_p_XMLOutputStringStream", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLOutputFileStream = {"_p_XMLOutputFileStream", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLToken = {"_p_XMLToken", "XMLToken_t *|XMLToken *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLTriple = {"_p_XMLTriple", "XMLTriple *|XMLTriple_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char_type = {"_p_char_type", "char_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_reference = {"_p_const_reference", "const_reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int_type = {"_p_int_type", "int_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_off_type = {"_p_off_type", "off_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **|VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pos_type = {"_p_pos_type", "pos_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_reference = {"_p_reference", "reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_state_type = {"_p_state_type", "state_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t = {"_p_std__basic_iosT_char_std__char_traitsT_char_t_t", "std::basic_ios< char > *|std::basic_ios< char,std::char_traits< char > > *|std::ios *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t = {"_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t", "std::basic_ostream< char > *|std::basic_ostream< char,std::char_traits< char > > *|std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "std::basic_ostringstream< char > *|std::ostringstream *|std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t = {"_p_std__basic_streambufT_char_std__char_traitsT_char_t_t", "std::basic_streambuf< char,std::char_traits< char > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "std::basic_string< char > *|std::basic_string< char,std::char_traits< char >,std::allocator< char > > *|std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator", "std::basic_string< char >::const_iterator *|std::basic_string< char,std::char_traits< char >,std::allocator< char > >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator", "std::basic_string< char >::iterator *|std::basic_string< char,std::char_traits< char >,std::allocator< char > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ios_base__openmode = {"_p_std__ios_base__openmode", "std::ios_base::openmode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapT_int_int_t = {"_p_std__multimapT_int_int_t", "ParentMap *|std::multimap< int,int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t = {"_p_std__pairT_ParentMap__iterator_ParentMap__iterator_t", "ParentRange *|std::pair< ParentMap::iterator,ParentMap::iterator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__ConstIterator = {"_p_swig__ConstIterator", "swig::ConstIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__GC_VALUE = {"_p_swig__GC_VALUE", "swig::GC_VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__Iterator = {"_p_swig__Iterator", "swig::Iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ASTNode,
  &_swigt__p_ASTNodeType_t,
  &_swigt__p_AlgebraicRule,
  &_swigt__p_AssignmentRule,
  &_swigt__p_BiolQualifierType_t,
  &_swigt__p_CVTerm,
  &_swigt__p_Compartment,
  &_swigt__p_CompartmentType,
  &_swigt__p_Constraint,
  &_swigt__p_Date,
  &_swigt__p_Delay,
  &_swigt__p_Event,
  &_swigt__p_EventAssignment,
  &_swigt__p_ExpectedAttributes,
  &_swigt__p_FunctionDefinition,
  &_swigt__p_ISBMLExtensionNamespaces,
  &_swigt__p_InitialAssignment,
  &_swigt__p_KineticLaw,
  &_swigt__p_List,
  &_swigt__p_ListOf,
  &_swigt__p_ListOfCompartmentTypes,
  &_swigt__p_ListOfCompartments,
  &_swigt__p_ListOfConstraints,
  &_swigt__p_ListOfEventAssignments,
  &_swigt__p_ListOfEvents,
  &_swigt__p_ListOfFunctionDefinitions,
  &_swigt__p_ListOfInitialAssignments,
  &_swigt__p_ListOfLocalParameters,
  &_swigt__p_ListOfParameters,
  &_swigt__p_ListOfReactions,
  &_swigt__p_ListOfRules,
  &_swigt__p_ListOfSpecies,
  &_swigt__p_ListOfSpeciesReferences,
  &_swigt__p_ListOfSpeciesTypes,
  &_swigt__p_ListOfUnitDefinitions,
  &_swigt__p_ListOfUnits,
  &_swigt__p_ListWrapperT_ASTNode_t,
  &_swigt__p_ListWrapperT_CVTerm_t,
  &_swigt__p_ListWrapperT_Date_t,
  &_swigt__p_ListWrapperT_ModelCreator_t,
  &_swigt__p_ListWrapperT_SBMLNamespaces_t,
  &_swigt__p_LocalParameter,
  &_swigt__p_Model,
  &_swigt__p_ModelCreator,
  &_swigt__p_ModelHistory,
  &_swigt__p_ModelQualifierType_t,
  &_swigt__p_ModifierSpeciesReference,
  &_swigt__p_OperationReturnValues_t,
  &_swigt__p_Parameter,
  &_swigt__p_ParentMap__iterator,
  &_swigt__p_Priority,
  &_swigt__p_QualifierType_t,
  &_swigt__p_RDFAnnotationParser,
  &_swigt__p_RateRule,
  &_swigt__p_Reaction,
  &_swigt__p_Rule,
  &_swigt__p_RuleType_t,
  &_swigt__p_SBMLConstructorException,
  &_swigt__p_SBMLDocument,
  &_swigt__p_SBMLDocumentPlugin,
  &_swigt__p_SBMLError,
  &_swigt__p_SBMLErrorCategory_t,
  &_swigt__p_SBMLErrorCode_t,
  &_swigt__p_SBMLErrorLog,
  &_swigt__p_SBMLErrorSeverity_t,
  &_swigt__p_SBMLExtension,
  &_swigt__p_SBMLExtensionException,
  &_swigt__p_SBMLExtensionRegistry,
  &_swigt__p_SBMLNamespaces,
  &_swigt__p_SBMLReader,
  &_swigt__p_SBMLTransforms,
  &_swigt__p_SBMLTypeCode_t,
  &_swigt__p_SBMLWriter,
  &_swigt__p_SBO,
  &_swigt__p_SBase,
  &_swigt__p_SBaseExtensionPoint,
  &_swigt__p_SBasePlugin,
  &_swigt__p_SBasePluginCreatorBase,
  &_swigt__p_SimpleSpeciesReference,
  &_swigt__p_Species,
  &_swigt__p_SpeciesReference,
  &_swigt__p_SpeciesType,
  &_swigt__p_StoichiometryMath,
  &_swigt__p_SupportedPackageURIList,
  &_swigt__p_SupportedPackageURIListIter,
  &_swigt__p_SyntaxChecker,
  &_swigt__p_Trigger,
  &_swigt__p_Unit,
  &_swigt__p_UnitDefinition,
  &_swigt__p_UnitKind_t,
  &_swigt__p_XMLAttributes,
  &_swigt__p_XMLConstructorException,
  &_swigt__p_XMLError,
  &_swigt__p_XMLErrorCategory_t,
  &_swigt__p_XMLErrorCode_t,
  &_swigt__p_XMLErrorLog,
  &_swigt__p_XMLErrorSeverity_t,
  &_swigt__p_XMLInputStream,
  &_swigt__p_XMLNamespaces,
  &_swigt__p_XMLNode,
  &_swigt__p_XMLOutputFileStream,
  &_swigt__p_XMLOutputStream,
  &_swigt__p_XMLOutputStringStream,
  &_swigt__p_XMLToken,
  &_swigt__p_XMLTriple,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_char_type,
  &_swigt__p_const_reference,
  &_swigt__p_difference_type,
  &_swigt__p_int_type,
  &_swigt__p_off_type,
  &_swigt__p_p_void,
  &_swigt__p_pos_type,
  &_swigt__p_reference,
  &_swigt__p_size_type,
  &_swigt__p_state_type,
  &_swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,
  &_swigt__p_std__invalid_argument,
  &_swigt__p_std__ios_base__openmode,
  &_swigt__p_std__multimapT_int_int_t,
  &_swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t,
  &_swigt__p_swig__ConstIterator,
  &_swigt__p_swig__GC_VALUE,
  &_swigt__p_swig__Iterator,
  &_swigt__p_value_type,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_ASTNode[] = {  {&_swigt__p_ASTNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASTNodeType_t[] = {  {&_swigt__p_ASTNodeType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AlgebraicRule[] = {  {&_swigt__p_AlgebraicRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AssignmentRule[] = {  {&_swigt__p_AssignmentRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BiolQualifierType_t[] = {  {&_swigt__p_BiolQualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CVTerm[] = {  {&_swigt__p_CVTerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Compartment[] = {  {&_swigt__p_Compartment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CompartmentType[] = {  {&_swigt__p_CompartmentType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Constraint[] = {  {&_swigt__p_Constraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Date[] = {  {&_swigt__p_Date, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Delay[] = {  {&_swigt__p_Delay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Event[] = {  {&_swigt__p_Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EventAssignment[] = {  {&_swigt__p_EventAssignment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExpectedAttributes[] = {  {&_swigt__p_ExpectedAttributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FunctionDefinition[] = {  {&_swigt__p_FunctionDefinition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ISBMLExtensionNamespaces[] = {  {&_swigt__p_ISBMLExtensionNamespaces, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InitialAssignment[] = {  {&_swigt__p_InitialAssignment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KineticLaw[] = {  {&_swigt__p_KineticLaw, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_List[] = {  {&_swigt__p_List, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOf[] = {  {&_swigt__p_ListOfReactions, _p_ListOfReactionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfParameters, _p_ListOfParametersTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfEvents, _p_ListOfEventsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfRules, _p_ListOfRulesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfCompartments, _p_ListOfCompartmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfCompartmentTypes, _p_ListOfCompartmentTypesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfUnitDefinitions, _p_ListOfUnitDefinitionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfFunctionDefinitions, _p_ListOfFunctionDefinitionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfSpeciesTypes, _p_ListOfSpeciesTypesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfSpeciesReferences, _p_ListOfSpeciesReferencesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfInitialAssignments, _p_ListOfInitialAssignmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfEventAssignments, _p_ListOfEventAssignmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfConstraints, _p_ListOfConstraintsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfUnits, _p_ListOfUnitsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOf, 0, 0, 0},  {&_swigt__p_ListOfSpecies, _p_ListOfSpeciesTo_p_ListOf, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfCompartmentTypes[] = {  {&_swigt__p_ListOfCompartmentTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfCompartments[] = {  {&_swigt__p_ListOfCompartments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfConstraints[] = {  {&_swigt__p_ListOfConstraints, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfEventAssignments[] = {  {&_swigt__p_ListOfEventAssignments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfEvents[] = {  {&_swigt__p_ListOfEvents, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfFunctionDefinitions[] = {  {&_swigt__p_ListOfFunctionDefinitions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfInitialAssignments[] = {  {&_swigt__p_ListOfInitialAssignments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfLocalParameters[] = {  {&_swigt__p_ListOfLocalParameters, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfParameters[] = {  {&_swigt__p_ListOfParameters, 0, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_ListOfParameters, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfReactions[] = {  {&_swigt__p_ListOfReactions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfRules[] = {  {&_swigt__p_ListOfRules, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpecies[] = {  {&_swigt__p_ListOfSpecies, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpeciesReferences[] = {  {&_swigt__p_ListOfSpeciesReferences, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpeciesTypes[] = {  {&_swigt__p_ListOfSpeciesTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfUnitDefinitions[] = {  {&_swigt__p_ListOfUnitDefinitions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfUnits[] = {  {&_swigt__p_ListOfUnits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_ASTNode_t[] = {  {&_swigt__p_ListWrapperT_ASTNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_CVTerm_t[] = {  {&_swigt__p_ListWrapperT_CVTerm_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_Date_t[] = {  {&_swigt__p_ListWrapperT_Date_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_ModelCreator_t[] = {  {&_swigt__p_ListWrapperT_ModelCreator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_SBMLNamespaces_t[] = {  {&_swigt__p_ListWrapperT_SBMLNamespaces_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LocalParameter[] = {  {&_swigt__p_LocalParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Model[] = {  {&_swigt__p_Model, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelCreator[] = {  {&_swigt__p_ModelCreator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelHistory[] = {  {&_swigt__p_ModelHistory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelQualifierType_t[] = {  {&_swigt__p_ModelQualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModifierSpeciesReference[] = {  {&_swigt__p_ModifierSpeciesReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OperationReturnValues_t[] = {  {&_swigt__p_OperationReturnValues_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parameter[] = {  {&_swigt__p_Parameter, 0, 0, 0},  {&_swigt__p_LocalParameter, _p_LocalParameterTo_p_Parameter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ParentMap__iterator[] = {  {&_swigt__p_ParentMap__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Priority[] = {  {&_swigt__p_Priority, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_QualifierType_t[] = {  {&_swigt__p_QualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RDFAnnotationParser[] = {  {&_swigt__p_RDFAnnotationParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RateRule[] = {  {&_swigt__p_RateRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Reaction[] = {  {&_swigt__p_Reaction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rule[] = {  {&_swigt__p_Rule, 0, 0, 0},  {&_swigt__p_AlgebraicRule, _p_AlgebraicRuleTo_p_Rule, 0, 0},  {&_swigt__p_AssignmentRule, _p_AssignmentRuleTo_p_Rule, 0, 0},  {&_swigt__p_RateRule, _p_RateRuleTo_p_Rule, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RuleType_t[] = {  {&_swigt__p_RuleType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLConstructorException[] = {  {&_swigt__p_SBMLConstructorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLDocument[] = {  {&_swigt__p_SBMLDocument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLDocumentPlugin[] = {  {&_swigt__p_SBMLDocumentPlugin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLError[] = {  {&_swigt__p_SBMLError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorCategory_t[] = {  {&_swigt__p_SBMLErrorCategory_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorCode_t[] = {  {&_swigt__p_SBMLErrorCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorLog[] = {  {&_swigt__p_SBMLErrorLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorSeverity_t[] = {  {&_swigt__p_SBMLErrorSeverity_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLExtension[] = {  {&_swigt__p_SBMLExtension, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLExtensionException[] = {  {&_swigt__p_SBMLExtensionException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLExtensionRegistry[] = {  {&_swigt__p_SBMLExtensionRegistry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLNamespaces[] = {  {&_swigt__p_SBMLNamespaces, 0, 0, 0},  {&_swigt__p_ISBMLExtensionNamespaces, _p_ISBMLExtensionNamespacesTo_p_SBMLNamespaces, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLReader[] = {  {&_swigt__p_SBMLReader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLTransforms[] = {  {&_swigt__p_SBMLTransforms, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLTypeCode_t[] = {  {&_swigt__p_SBMLTypeCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLWriter[] = {  {&_swigt__p_SBMLWriter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBO[] = {  {&_swigt__p_SBO, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBase[] = {  {&_swigt__p_Constraint, _p_ConstraintTo_p_SBase, 0, 0},  {&_swigt__p_RateRule, _p_RateRuleTo_p_SBase, 0, 0},  {&_swigt__p_ListOfFunctionDefinitions, _p_ListOfFunctionDefinitionsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfUnitDefinitions, _p_ListOfUnitDefinitionsTo_p_SBase, 0, 0},  {&_swigt__p_SimpleSpeciesReference, _p_SimpleSpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_SpeciesReference, _p_SpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_ModifierSpeciesReference, _p_ModifierSpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_Event, _p_EventTo_p_SBase, 0, 0},  {&_swigt__p_EventAssignment, _p_EventAssignmentTo_p_SBase, 0, 0},  {&_swigt__p_InitialAssignment, _p_InitialAssignmentTo_p_SBase, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_SBase, 0, 0},  {&_swigt__p_ListOfParameters, _p_ListOfParametersTo_p_SBase, 0, 0},  {&_swigt__p_AssignmentRule, _p_AssignmentRuleTo_p_SBase, 0, 0},  {&_swigt__p_SBMLDocument, _p_SBMLDocumentTo_p_SBase, 0, 0},  {&_swigt__p_FunctionDefinition, _p_FunctionDefinitionTo_p_SBase, 0, 0},  {&_swigt__p_UnitDefinition, _p_UnitDefinitionTo_p_SBase, 0, 0},  {&_swigt__p_Model, _p_ModelTo_p_SBase, 0, 0},  {&_swigt__p_ListOfInitialAssignments, _p_ListOfInitialAssignmentsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfEventAssignments, _p_ListOfEventAssignmentsTo_p_SBase, 0, 0},  {&_swigt__p_AlgebraicRule, _p_AlgebraicRuleTo_p_SBase, 0, 0},  {&_swigt__p_Delay, _p_DelayTo_p_SBase, 0, 0},  {&_swigt__p_ListOf, _p_ListOfTo_p_SBase, 0, 0},  {&_swigt__p_ListOfCompartmentTypes, _p_ListOfCompartmentTypesTo_p_SBase, 0, 0},  {&_swigt__p_Compartment, _p_CompartmentTo_p_SBase, 0, 0},  {&_swigt__p_KineticLaw, _p_KineticLawTo_p_SBase, 0, 0},  {&_swigt__p_ListOfEvents, _p_ListOfEventsTo_p_SBase, 0, 0},  {&_swigt__p_StoichiometryMath, _p_StoichiometryMathTo_p_SBase, 0, 0},  {&_swigt__p_Unit, _p_UnitTo_p_SBase, 0, 0},  {&_swigt__p_SBase, 0, 0, 0},  {&_swigt__p_ListOfSpeciesReferences, _p_ListOfSpeciesReferencesTo_p_SBase, 0, 0},  {&_swigt__p_ListOfSpeciesTypes, _p_ListOfSpeciesTypesTo_p_SBase, 0, 0},  {&_swigt__p_ListOfRules, _p_ListOfRulesTo_p_SBase, 0, 0},  {&_swigt__p_Rule, _p_RuleTo_p_SBase, 0, 0},  {&_swigt__p_ListOfConstraints, _p_ListOfConstraintsTo_p_SBase, 0, 0},  {&_swigt__p_Priority, _p_PriorityTo_p_SBase, 0, 0},  {&_swigt__p_ListOfReactions, _p_ListOfReactionsTo_p_SBase, 0, 0},  {&_swigt__p_CompartmentType, _p_CompartmentTypeTo_p_SBase, 0, 0},  {&_swigt__p_LocalParameter, _p_LocalParameterTo_p_SBase, 0, 0},  {&_swigt__p_Parameter, _p_ParameterTo_p_SBase, 0, 0},  {&_swigt__p_ListOfSpecies, _p_ListOfSpeciesTo_p_SBase, 0, 0},  {&_swigt__p_Species, _p_SpeciesTo_p_SBase, 0, 0},  {&_swigt__p_Trigger, _p_TriggerTo_p_SBase, 0, 0},  {&_swigt__p_ListOfUnits, _p_ListOfUnitsTo_p_SBase, 0, 0},  {&_swigt__p_SpeciesType, _p_SpeciesTypeTo_p_SBase, 0, 0},  {&_swigt__p_ListOfCompartments, _p_ListOfCompartmentsTo_p_SBase, 0, 0},  {&_swigt__p_Reaction, _p_ReactionTo_p_SBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBaseExtensionPoint[] = {  {&_swigt__p_SBaseExtensionPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBasePlugin[] = {  {&_swigt__p_SBMLDocumentPlugin, _p_SBMLDocumentPluginTo_p_SBasePlugin, 0, 0},  {&_swigt__p_SBasePlugin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBasePluginCreatorBase[] = {  {&_swigt__p_SBasePluginCreatorBase, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SimpleSpeciesReference[] = {  {&_swigt__p_SimpleSpeciesReference, 0, 0, 0},  {&_swigt__p_SpeciesReference, _p_SpeciesReferenceTo_p_SimpleSpeciesReference, 0, 0},  {&_swigt__p_ModifierSpeciesReference, _p_ModifierSpeciesReferenceTo_p_SimpleSpeciesReference, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Species[] = {  {&_swigt__p_Species, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SpeciesReference[] = {  {&_swigt__p_SpeciesReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SpeciesType[] = {  {&_swigt__p_SpeciesType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StoichiometryMath[] = {  {&_swigt__p_StoichiometryMath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SupportedPackageURIList[] = {  {&_swigt__p_SupportedPackageURIList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SupportedPackageURIListIter[] = {  {&_swigt__p_SupportedPackageURIListIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SyntaxChecker[] = {  {&_swigt__p_SyntaxChecker, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Trigger[] = {  {&_swigt__p_Trigger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Unit[] = {  {&_swigt__p_Unit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UnitDefinition[] = {  {&_swigt__p_UnitDefinition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UnitKind_t[] = {  {&_swigt__p_UnitKind_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLAttributes[] = {  {&_swigt__p_XMLAttributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLConstructorException[] = {  {&_swigt__p_XMLConstructorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLError[] = {  {&_swigt__p_XMLError, 0, 0, 0},  {&_swigt__p_SBMLError, _p_SBMLErrorTo_p_XMLError, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorCategory_t[] = {  {&_swigt__p_XMLErrorCategory_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorCode_t[] = {  {&_swigt__p_XMLErrorCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorLog[] = {  {&_swigt__p_XMLErrorLog, 0, 0, 0},  {&_swigt__p_SBMLErrorLog, _p_SBMLErrorLogTo_p_XMLErrorLog, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorSeverity_t[] = {  {&_swigt__p_XMLErrorSeverity_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLInputStream[] = {  {&_swigt__p_XMLInputStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLNamespaces[] = {  {&_swigt__p_XMLNamespaces, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLNode[] = {  {&_swigt__p_XMLNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputStringStream[] = {{&_swigt__p_XMLOutputStringStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputFileStream[] = {{&_swigt__p_XMLOutputFileStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputStream[] = {  {&_swigt__p_XMLOutputStringStream, _p_XMLOutputStringStreamTo_p_XMLOutputStream, 0, 0},  {&_swigt__p_XMLOutputFileStream, _p_XMLOutputFileStreamTo_p_XMLOutputStream, 0, 0},  {&_swigt__p_XMLOutputStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLToken[] = {  {&_swigt__p_XMLToken, 0, 0, 0},  {&_swigt__p_XMLNode, _p_XMLNodeTo_p_XMLToken, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLTriple[] = {  {&_swigt__p_XMLTriple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char_type[] = {  {&_swigt__p_char_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_reference[] = {  {&_swigt__p_const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int_type[] = {  {&_swigt__p_int_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_off_type[] = {  {&_swigt__p_off_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pos_type[] = {  {&_swigt__p_pos_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_reference[] = {  {&_swigt__p_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_state_type[] = {  {&_swigt__p_state_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_iosT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0, 0},  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, _p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0},  {&_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, _p_std__basic_ostreamT_char_std__char_traitsT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, _p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0, 0},  {&_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_streambufT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_SBMLConstructorException, _p_SBMLConstructorExceptionTo_p_std__invalid_argument, 0, 0},  {&_swigt__p_XMLConstructorException, _p_XMLConstructorExceptionTo_p_std__invalid_argument, 0, 0},  {&_swigt__p_SBMLExtensionException, _p_SBMLExtensionExceptionTo_p_std__invalid_argument, 0, 0},  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ios_base__openmode[] = {  {&_swigt__p_std__ios_base__openmode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapT_int_int_t[] = {  {&_swigt__p_std__multimapT_int_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t[] = {  {&_swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__ConstIterator[] = {  {&_swigt__p_swig__ConstIterator, 0, 0, 0},  {&_swigt__p_swig__Iterator, _p_swig__IteratorTo_p_swig__ConstIterator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__GC_VALUE[] = {  {&_swigt__p_swig__GC_VALUE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__Iterator[] = {  {&_swigt__p_swig__Iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ASTNode,
  _swigc__p_ASTNodeType_t,
  _swigc__p_AlgebraicRule,
  _swigc__p_AssignmentRule,
  _swigc__p_BiolQualifierType_t,
  _swigc__p_CVTerm,
  _swigc__p_Compartment,
  _swigc__p_CompartmentType,
  _swigc__p_Constraint,
  _swigc__p_Date,
  _swigc__p_Delay,
  _swigc__p_Event,
  _swigc__p_EventAssignment,
  _swigc__p_ExpectedAttributes,
  _swigc__p_FunctionDefinition,
  _swigc__p_ISBMLExtensionNamespaces,
  _swigc__p_InitialAssignment,
  _swigc__p_KineticLaw,
  _swigc__p_List,
  _swigc__p_ListOf,
  _swigc__p_ListOfCompartmentTypes,
  _swigc__p_ListOfCompartments,
  _swigc__p_ListOfConstraints,
  _swigc__p_ListOfEventAssignments,
  _swigc__p_ListOfEvents,
  _swigc__p_ListOfFunctionDefinitions,
  _swigc__p_ListOfInitialAssignments,
  _swigc__p_ListOfLocalParameters,
  _swigc__p_ListOfParameters,
  _swigc__p_ListOfReactions,
  _swigc__p_ListOfRules,
  _swigc__p_ListOfSpecies,
  _swigc__p_ListOfSpeciesReferences,
  _swigc__p_ListOfSpeciesTypes,
  _swigc__p_ListOfUnitDefinitions,
  _swigc__p_ListOfUnits,
  _swigc__p_ListWrapperT_ASTNode_t,
  _swigc__p_ListWrapperT_CVTerm_t,
  _swigc__p_ListWrapperT_Date_t,
  _swigc__p_ListWrapperT_ModelCreator_t,
  _swigc__p_ListWrapperT_SBMLNamespaces_t,
  _swigc__p_LocalParameter,
  _swigc__p_Model,
  _swigc__p_ModelCreator,
  _swigc__p_ModelHistory,
  _swigc__p_ModelQualifierType_t,
  _swigc__p_ModifierSpeciesReference,
  _swigc__p_OperationReturnValues_t,
  _swigc__p_Parameter,
  _swigc__p_ParentMap__iterator,
  _swigc__p_Priority,
  _swigc__p_QualifierType_t,
  _swigc__p_RDFAnnotationParser,
  _swigc__p_RateRule,
  _swigc__p_Reaction,
  _swigc__p_Rule,
  _swigc__p_RuleType_t,
  _swigc__p_SBMLConstructorException,
  _swigc__p_SBMLDocument,
  _swigc__p_SBMLDocumentPlugin,
  _swigc__p_SBMLError,
  _swigc__p_SBMLErrorCategory_t,
  _swigc__p_SBMLErrorCode_t,
  _swigc__p_SBMLErrorLog,
  _swigc__p_SBMLErrorSeverity_t,
  _swigc__p_SBMLExtension,
  _swigc__p_SBMLExtensionException,
  _swigc__p_SBMLExtensionRegistry,
  _swigc__p_SBMLNamespaces,
  _swigc__p_SBMLReader,
  _swigc__p_SBMLTransforms,
  _swigc__p_SBMLTypeCode_t,
  _swigc__p_SBMLWriter,
  _swigc__p_SBO,
  _swigc__p_SBase,
  _swigc__p_SBaseExtensionPoint,
  _swigc__p_SBasePlugin,
  _swigc__p_SBasePluginCreatorBase,
  _swigc__p_SimpleSpeciesReference,
  _swigc__p_Species,
  _swigc__p_SpeciesReference,
  _swigc__p_SpeciesType,
  _swigc__p_StoichiometryMath,
  _swigc__p_SupportedPackageURIList,
  _swigc__p_SupportedPackageURIListIter,
  _swigc__p_SyntaxChecker,
  _swigc__p_Trigger,
  _swigc__p_Unit,
  _swigc__p_UnitDefinition,
  _swigc__p_UnitKind_t,
  _swigc__p_XMLAttributes,
  _swigc__p_XMLConstructorException,
  _swigc__p_XMLError,
  _swigc__p_XMLErrorCategory_t,
  _swigc__p_XMLErrorCode_t,
  _swigc__p_XMLErrorLog,
  _swigc__p_XMLErrorSeverity_t,
  _swigc__p_XMLInputStream,
  _swigc__p_XMLNamespaces,
  _swigc__p_XMLNode,
  _swigc__p_XMLOutputFileStream,
  _swigc__p_XMLOutputStream,
  _swigc__p_XMLOutputStringStream,
  _swigc__p_XMLToken,
  _swigc__p_XMLTriple,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_char_type,
  _swigc__p_const_reference,
  _swigc__p_difference_type,
  _swigc__p_int_type,
  _swigc__p_off_type,
  _swigc__p_p_void,
  _swigc__p_pos_type,
  _swigc__p_reference,
  _swigc__p_size_type,
  _swigc__p_state_type,
  _swigc__p_std__basic_iosT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__basic_streambufT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__const_iterator,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,
  _swigc__p_std__invalid_argument,
  _swigc__p_std__ios_base__openmode,
  _swigc__p_std__multimapT_int_int_t,
  _swigc__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t,
  _swigc__p_swig__ConstIterator,
  _swigc__p_swig__GC_VALUE,
  _swigc__p_swig__Iterator,
  _swigc__p_value_type,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif

/*

*/
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_libSBML(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mLibSBML = rb_define_module("LibSBML");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  
  SwigClassModelCreatorList.klass = rb_define_class_under(mLibSBML, "ModelCreatorList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ListWrapperT_ModelCreator_t, (void *) &SwigClassModelCreatorList);
  rb_define_alloc_func(SwigClassModelCreatorList.klass, _wrap_ModelCreatorList_allocate);
  rb_define_method(SwigClassModelCreatorList.klass, "initialize", VALUEFUNC(_wrap_new_ModelCreatorList), -1);
  rb_define_method(SwigClassModelCreatorList.klass, "add", VALUEFUNC(_wrap_ModelCreatorList_add), -1);
  rb_define_method(SwigClassModelCreatorList.klass, "get", VALUEFUNC(_wrap_ModelCreatorList_get), -1);
  rb_define_method(SwigClassModelCreatorList.klass, "prepend", VALUEFUNC(_wrap_ModelCreatorList_prepend), -1);
  rb_define_method(SwigClassModelCreatorList.klass, "remove", VALUEFUNC(_wrap_ModelCreatorList_remove), -1);
  rb_define_method(SwigClassModelCreatorList.klass, "getSize", VALUEFUNC(_wrap_ModelCreatorList_getSize), -1);
  SwigClassModelCreatorList.mark = 0;
  SwigClassModelCreatorList.destroy = (void (*)(void *)) free_ListWrapper_Sl_ModelCreator_Sg_;
  SwigClassModelCreatorList.trackObjects = 0;
  
  SwigClassDateList.klass = rb_define_class_under(mLibSBML, "DateList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ListWrapperT_Date_t, (void *) &SwigClassDateList);
  rb_define_alloc_func(SwigClassDateList.klass, _wrap_DateList_allocate);
  rb_define_method(SwigClassDateList.klass, "initialize", VALUEFUNC(_wrap_new_DateList), -1);
  rb_define_method(SwigClassDateList.klass, "add", VALUEFUNC(_wrap_DateList_add), -1);
  rb_define_method(SwigClassDateList.klass, "get", VALUEFUNC(_wrap_DateList_get), -1);
  rb_define_method(SwigClassDateList.klass, "prepend", VALUEFUNC(_wrap_DateList_prepend), -1);
  rb_define_method(SwigClassDateList.klass, "remove", VALUEFUNC(_wrap_DateList_remove), -1);
  rb_define_method(SwigClassDateList.klass, "getSize", VALUEFUNC(_wrap_DateList_getSize), -1);
  SwigClassDateList.mark = 0;
  SwigClassDateList.destroy = (void (*)(void *)) free_ListWrapper_Sl_Date_Sg_;
  SwigClassDateList.trackObjects = 0;
  
  SwigClassCVTermList.klass = rb_define_class_under(mLibSBML, "CVTermList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ListWrapperT_CVTerm_t, (void *) &SwigClassCVTermList);
  rb_define_alloc_func(SwigClassCVTermList.klass, _wrap_CVTermList_allocate);
  rb_define_method(SwigClassCVTermList.klass, "initialize", VALUEFUNC(_wrap_new_CVTermList), -1);
  rb_define_method(SwigClassCVTermList.klass, "add", VALUEFUNC(_wrap_CVTermList_add), -1);
  rb_define_method(SwigClassCVTermList.klass, "get", VALUEFUNC(_wrap_CVTermList_get), -1);
  rb_define_method(SwigClassCVTermList.klass, "prepend", VALUEFUNC(_wrap_CVTermList_prepend), -1);
  rb_define_method(SwigClassCVTermList.klass, "remove", VALUEFUNC(_wrap_CVTermList_remove), -1);
  rb_define_method(SwigClassCVTermList.klass, "getSize", VALUEFUNC(_wrap_CVTermList_getSize), -1);
  SwigClassCVTermList.mark = 0;
  SwigClassCVTermList.destroy = (void (*)(void *)) free_ListWrapper_Sl_CVTerm_Sg_;
  SwigClassCVTermList.trackObjects = 0;
  
  SwigClassASTNodeList.klass = rb_define_class_under(mLibSBML, "ASTNodeList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ListWrapperT_ASTNode_t, (void *) &SwigClassASTNodeList);
  rb_define_alloc_func(SwigClassASTNodeList.klass, _wrap_ASTNodeList_allocate);
  rb_define_method(SwigClassASTNodeList.klass, "initialize", VALUEFUNC(_wrap_new_ASTNodeList), -1);
  rb_define_method(SwigClassASTNodeList.klass, "add", VALUEFUNC(_wrap_ASTNodeList_add), -1);
  rb_define_method(SwigClassASTNodeList.klass, "get", VALUEFUNC(_wrap_ASTNodeList_get), -1);
  rb_define_method(SwigClassASTNodeList.klass, "prepend", VALUEFUNC(_wrap_ASTNodeList_prepend), -1);
  rb_define_method(SwigClassASTNodeList.klass, "remove", VALUEFUNC(_wrap_ASTNodeList_remove), -1);
  rb_define_method(SwigClassASTNodeList.klass, "getSize", VALUEFUNC(_wrap_ASTNodeList_getSize), -1);
  SwigClassASTNodeList.mark = 0;
  SwigClassASTNodeList.destroy = (void (*)(void *)) free_ListWrapper_Sl_ASTNode_Sg_;
  SwigClassASTNodeList.trackObjects = 0;
  
  SwigClassSBMLNamespacesList.klass = rb_define_class_under(mLibSBML, "SBMLNamespacesList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, (void *) &SwigClassSBMLNamespacesList);
  rb_define_alloc_func(SwigClassSBMLNamespacesList.klass, _wrap_SBMLNamespacesList_allocate);
  rb_define_method(SwigClassSBMLNamespacesList.klass, "initialize", VALUEFUNC(_wrap_new_SBMLNamespacesList), -1);
  rb_define_method(SwigClassSBMLNamespacesList.klass, "add", VALUEFUNC(_wrap_SBMLNamespacesList_add), -1);
  rb_define_method(SwigClassSBMLNamespacesList.klass, "get", VALUEFUNC(_wrap_SBMLNamespacesList_get), -1);
  rb_define_method(SwigClassSBMLNamespacesList.klass, "prepend", VALUEFUNC(_wrap_SBMLNamespacesList_prepend), -1);
  rb_define_method(SwigClassSBMLNamespacesList.klass, "remove", VALUEFUNC(_wrap_SBMLNamespacesList_remove), -1);
  rb_define_method(SwigClassSBMLNamespacesList.klass, "getSize", VALUEFUNC(_wrap_SBMLNamespacesList_getSize), -1);
  SwigClassSBMLNamespacesList.mark = 0;
  SwigClassSBMLNamespacesList.destroy = (void (*)(void *)) free_ListWrapper_Sl_SBMLNamespaces_Sg_;
  SwigClassSBMLNamespacesList.trackObjects = 0;
  
  SwigClassGC_VALUE.klass = rb_define_class_under(mLibSBML, "GC_VALUE", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__GC_VALUE, (void *) &SwigClassGC_VALUE);
  rb_undef_alloc_func(SwigClassGC_VALUE.klass);
  rb_define_method(SwigClassGC_VALUE.klass, "inspect", VALUEFUNC(_wrap_GC_VALUE_inspect), -1);
  rb_define_method(SwigClassGC_VALUE.klass, "to_s", VALUEFUNC(_wrap_GC_VALUE_to_s), -1);
  SwigClassGC_VALUE.mark = 0;
  SwigClassGC_VALUE.trackObjects = 1;
  
  swig::GC_VALUE::initialize();
  
  
  SwigClassConstIterator.klass = rb_define_class_under(mLibSBML, "ConstIterator", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__ConstIterator, (void *) &SwigClassConstIterator);
  rb_undef_alloc_func(SwigClassConstIterator.klass);
  rb_define_method(SwigClassConstIterator.klass, "value", VALUEFUNC(_wrap_ConstIterator_value), -1);
  rb_define_method(SwigClassConstIterator.klass, "dup", VALUEFUNC(_wrap_ConstIterator_dup), -1);
  rb_define_method(SwigClassConstIterator.klass, "inspect", VALUEFUNC(_wrap_ConstIterator_inspect), -1);
  rb_define_method(SwigClassConstIterator.klass, "to_s", VALUEFUNC(_wrap_ConstIterator_to_s), -1);
  rb_define_method(SwigClassConstIterator.klass, "next", VALUEFUNC(_wrap_ConstIterator_next), -1);
  rb_define_method(SwigClassConstIterator.klass, "previous", VALUEFUNC(_wrap_ConstIterator_previous), -1);
  rb_define_method(SwigClassConstIterator.klass, "==", VALUEFUNC(_wrap_ConstIterator___eq__), -1);
  rb_define_method(SwigClassConstIterator.klass, "+", VALUEFUNC(_wrap_ConstIterator___add__), -1);
  rb_define_method(SwigClassConstIterator.klass, "-", VALUEFUNC(_wrap_ConstIterator___sub__), -1);
  SwigClassConstIterator.mark = 0;
  SwigClassConstIterator.destroy = (void (*)(void *)) free_swig_ConstIterator;
  SwigClassConstIterator.trackObjects = 1;
  
  SwigClassIterator.klass = rb_define_class_under(mLibSBML, "Iterator", ((swig_class *) SWIGTYPE_p_swig__ConstIterator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_swig__Iterator, (void *) &SwigClassIterator);
  rb_undef_alloc_func(SwigClassIterator.klass);
  rb_define_method(SwigClassIterator.klass, "value=", VALUEFUNC(_wrap_Iterator_valuee___), -1);
  rb_define_method(SwigClassIterator.klass, "dup", VALUEFUNC(_wrap_Iterator_dup), -1);
  rb_define_method(SwigClassIterator.klass, "next", VALUEFUNC(_wrap_Iterator_next), -1);
  rb_define_method(SwigClassIterator.klass, "previous", VALUEFUNC(_wrap_Iterator_previous), -1);
  rb_define_method(SwigClassIterator.klass, "inspect", VALUEFUNC(_wrap_Iterator_inspect), -1);
  rb_define_method(SwigClassIterator.klass, "to_s", VALUEFUNC(_wrap_Iterator_to_s), -1);
  rb_define_method(SwigClassIterator.klass, "==", VALUEFUNC(_wrap_Iterator___eq__), -1);
  rb_define_method(SwigClassIterator.klass, "+", VALUEFUNC(_wrap_Iterator___add__), -1);
  rb_define_method(SwigClassIterator.klass, "-", VALUEFUNC(_wrap_Iterator___sub__), -1);
  SwigClassIterator.mark = 0;
  SwigClassIterator.destroy = (void (*)(void *)) free_swig_Iterator;
  SwigClassIterator.trackObjects = 1;
  
  SwigClassString.klass = rb_define_class_under(mLibSBML, "String", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, (void *) &SwigClassString);
  rb_define_alloc_func(SwigClassString.klass, _wrap_string_allocate);
  rb_define_method(SwigClassString.klass, "initialize", VALUEFUNC(_wrap_new_string), -1);
  rb_define_singleton_method(SwigClassString.klass, "npos", VALUEFUNC(_wrap_string_npos_get), 0);
  rb_define_method(SwigClassString.klass, "length", VALUEFUNC(_wrap_string_length), -1);
  rb_define_method(SwigClassString.klass, "max_size", VALUEFUNC(_wrap_string_max_size), -1);
  rb_define_method(SwigClassString.klass, "copy", VALUEFUNC(_wrap_string_copy), -1);
  rb_define_method(SwigClassString.klass, "c_str", VALUEFUNC(_wrap_string_c_str), -1);
  rb_define_method(SwigClassString.klass, "find", VALUEFUNC(_wrap_string_find), -1);
  rb_define_method(SwigClassString.klass, "rfind", VALUEFUNC(_wrap_string_rfind), -1);
  rb_define_method(SwigClassString.klass, "find_first_of", VALUEFUNC(_wrap_string_find_first_of), -1);
  rb_define_method(SwigClassString.klass, "find_last_of", VALUEFUNC(_wrap_string_find_last_of), -1);
  rb_define_method(SwigClassString.klass, "find_first_not_of", VALUEFUNC(_wrap_string_find_first_not_of), -1);
  rb_define_method(SwigClassString.klass, "find_last_not_of", VALUEFUNC(_wrap_string_find_last_not_of), -1);
  rb_define_method(SwigClassString.klass, "substr", VALUEFUNC(_wrap_string_substr), -1);
  rb_define_method(SwigClassString.klass, "empty", VALUEFUNC(_wrap_string_empty), -1);
  rb_define_method(SwigClassString.klass, "size", VALUEFUNC(_wrap_string_size), -1);
  rb_define_method(SwigClassString.klass, "swap", VALUEFUNC(_wrap_string_swap), -1);
  rb_define_method(SwigClassString.klass, "erase", VALUEFUNC(_wrap_string_erase), -1);
  rb_define_method(SwigClassString.klass, "assign", VALUEFUNC(_wrap_string_assign), -1);
  rb_define_method(SwigClassString.klass, "resize", VALUEFUNC(_wrap_string_resize), -1);
  rb_define_method(SwigClassString.klass, "dup", VALUEFUNC(_wrap_string_dup), -1);
  rb_define_method(SwigClassString.klass, "inspect", VALUEFUNC(_wrap_string_inspect), -1);
  rb_define_method(SwigClassString.klass, "to_a", VALUEFUNC(_wrap_string_to_a), -1);
  rb_define_method(SwigClassString.klass, "to_s", VALUEFUNC(_wrap_string_to_s), -1);
  rb_define_method(SwigClassString.klass, "slice", VALUEFUNC(_wrap_string_slice), -1);
  rb_define_method(SwigClassString.klass, "each", VALUEFUNC(_wrap_string_each), -1);
  rb_define_method(SwigClassString.klass, "select", VALUEFUNC(_wrap_string_select), -1);
  rb_define_method(SwigClassString.klass, "reject_bang", VALUEFUNC(_wrap_string_reject_bang), -1);
  rb_define_alias(SwigClassString.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassString.klass, "delete_at", VALUEFUNC(_wrap_string_delete_at), -1);
  rb_define_method(SwigClassString.klass, "__delete2__", VALUEFUNC(_wrap_string___delete2__), -1);
  rb_define_method(SwigClassString.klass, "push", VALUEFUNC(_wrap_string_push), -1);
  rb_define_alias(SwigClassString.klass, "<<", "push");
  rb_define_method(SwigClassString.klass, "reject", VALUEFUNC(_wrap_string_reject), -1);
  rb_define_method(SwigClassString.klass, "at", VALUEFUNC(_wrap_string_at), -1);
  rb_define_method(SwigClassString.klass, "[]", VALUEFUNC(_wrap_string___getitem__), -1);
  rb_define_method(SwigClassString.klass, "[]=", VALUEFUNC(_wrap_string___setitem__), -1);
  rb_define_method(SwigClassString.klass, "insert", VALUEFUNC(_wrap_string_insert), -1);
  rb_define_method(SwigClassString.klass, "replace", VALUEFUNC(_wrap_string_replace), -1);
  rb_define_method(SwigClassString.klass, "+", VALUEFUNC(_wrap_string___add__), -1);
  rb_define_method(SwigClassString.klass, "__radd__", VALUEFUNC(_wrap_string___radd__), -1);
  rb_define_method(SwigClassString.klass, "to_s", VALUEFUNC(_wrap_string___str__), -1);
  rb_define_method(SwigClassString.klass, "__rlshift__", VALUEFUNC(_wrap_string___rlshift__), -1);
  rb_define_method(SwigClassString.klass, "==", VALUEFUNC(_wrap_string___eq__), -1);
  rb_define_method(SwigClassString.klass, ">", VALUEFUNC(_wrap_string___gt__), -1);
  rb_define_method(SwigClassString.klass, "<", VALUEFUNC(_wrap_string___lt__), -1);
  rb_define_method(SwigClassString.klass, ">=", VALUEFUNC(_wrap_string___ge__), -1);
  rb_define_method(SwigClassString.klass, "<=", VALUEFUNC(_wrap_string___le__), -1);
  SwigClassString.mark = 0;
  SwigClassString.destroy = (void (*)(void *)) free_std_basic_string_Sl_char_Sg_;
  SwigClassString.trackObjects = 1;
  
  SwigClassOstream.klass = rb_define_class_under(mLibSBML, "Ostream", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, (void *) &SwigClassOstream);
  rb_define_alloc_func(SwigClassOstream.klass, _wrap_Ostream_allocate);
  rb_define_method(SwigClassOstream.klass, "initialize", VALUEFUNC(_wrap_new_Ostream), -1);
  SwigClassOstream.mark = 0;
  SwigClassOstream.destroy = (void (*)(void *)) free_std_basic_ostream_Sl_char_Sg_;
  SwigClassOstream.trackObjects = 1;
  
  SwigClassOstringstream.klass = rb_define_class_under(mLibSBML, "Ostringstream", ((swig_class *) SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, (void *) &SwigClassOstringstream);
  rb_define_alloc_func(SwigClassOstringstream.klass, _wrap_Ostringstream_allocate);
  rb_define_method(SwigClassOstringstream.klass, "initialize", VALUEFUNC(_wrap_new_Ostringstream), -1);
  rb_define_method(SwigClassOstringstream.klass, "str", VALUEFUNC(_wrap_Ostringstream_str), -1);
  SwigClassOstringstream.mark = 0;
  SwigClassOstringstream.destroy = (void (*)(void *)) free_std_basic_ostringstream_Sl_char_Sg_;
  SwigClassOstringstream.trackObjects = 1;
  rb_define_module_function(mLibSBML, "endl", VALUEFUNC(_wrap_endl), -1);
  rb_define_module_function(mLibSBML, "flush", VALUEFUNC(_wrap_flush), -1);
  rb_define_singleton_method(mLibSBML, "cout", VALUEFUNC(_wrap_cout_get), 0);
  rb_define_singleton_method(mLibSBML, "cerr", VALUEFUNC(_wrap_cerr_get), 0);
  rb_define_singleton_method(mLibSBML, "clog", VALUEFUNC(_wrap_clog_get), 0);
  rb_define_module_function(mLibSBML, "ASTNode_true", VALUEFUNC(_wrap_ASTNode_true), -1);
  rb_define_const(mLibSBML, "LIBSBML_DOTTED_VERSION", SWIG_FromCharPtr("5.0.0"));
  rb_define_const(mLibSBML, "LIBSBML_VERSION", SWIG_From_int(static_cast< int >(50000)));
  rb_define_const(mLibSBML, "LIBSBML_VERSION_STRING", SWIG_FromCharPtr("50000"));
  rb_define_module_function(mLibSBML, "getLibSBMLVersion", VALUEFUNC(_wrap_getLibSBMLVersion), -1);
  rb_define_module_function(mLibSBML, "getLibSBMLDottedVersion", VALUEFUNC(_wrap_getLibSBMLDottedVersion), -1);
  rb_define_module_function(mLibSBML, "getLibSBMLVersionString", VALUEFUNC(_wrap_getLibSBMLVersionString), -1);
  rb_define_const(mLibSBML, "LIBSBML_OPERATION_SUCCESS", SWIG_From_int(static_cast< int >(LIBSBML_OPERATION_SUCCESS)));
  rb_define_const(mLibSBML, "LIBSBML_INDEX_EXCEEDS_SIZE", SWIG_From_int(static_cast< int >(LIBSBML_INDEX_EXCEEDS_SIZE)));
  rb_define_const(mLibSBML, "LIBSBML_UNEXPECTED_ATTRIBUTE", SWIG_From_int(static_cast< int >(LIBSBML_UNEXPECTED_ATTRIBUTE)));
  rb_define_const(mLibSBML, "LIBSBML_OPERATION_FAILED", SWIG_From_int(static_cast< int >(LIBSBML_OPERATION_FAILED)));
  rb_define_const(mLibSBML, "LIBSBML_INVALID_ATTRIBUTE_VALUE", SWIG_From_int(static_cast< int >(LIBSBML_INVALID_ATTRIBUTE_VALUE)));
  rb_define_const(mLibSBML, "LIBSBML_INVALID_OBJECT", SWIG_From_int(static_cast< int >(LIBSBML_INVALID_OBJECT)));
  rb_define_const(mLibSBML, "LIBSBML_DUPLICATE_OBJECT_ID", SWIG_From_int(static_cast< int >(LIBSBML_DUPLICATE_OBJECT_ID)));
  rb_define_const(mLibSBML, "LIBSBML_LEVEL_MISMATCH", SWIG_From_int(static_cast< int >(LIBSBML_LEVEL_MISMATCH)));
  rb_define_const(mLibSBML, "LIBSBML_VERSION_MISMATCH", SWIG_From_int(static_cast< int >(LIBSBML_VERSION_MISMATCH)));
  rb_define_const(mLibSBML, "LIBSBML_INVALID_XML_OPERATION", SWIG_From_int(static_cast< int >(LIBSBML_INVALID_XML_OPERATION)));
  rb_define_const(mLibSBML, "LIBSBML_PKG_VERSION_MISMATCH", SWIG_From_int(static_cast< int >(LIBSBML_PKG_VERSION_MISMATCH)));
  rb_define_const(mLibSBML, "LIBSBML_PKG_UNKNOWN", SWIG_From_int(static_cast< int >(LIBSBML_PKG_UNKNOWN)));
  rb_define_const(mLibSBML, "LIBSBML_PKG_UNKNOWN_VERSION", SWIG_From_int(static_cast< int >(LIBSBML_PKG_UNKNOWN_VERSION)));
  rb_define_const(mLibSBML, "LIBSBML_PKG_DISABLED", SWIG_From_int(static_cast< int >(LIBSBML_PKG_DISABLED)));
  rb_define_const(mLibSBML, "LIBSBML_PKG_CONFLICTED_VERSION", SWIG_From_int(static_cast< int >(LIBSBML_PKG_CONFLICTED_VERSION)));
  rb_define_const(mLibSBML, "LIBSBML_PKG_CONFLICT", SWIG_From_int(static_cast< int >(LIBSBML_PKG_CONFLICT)));
  
  SwigClassSBMLReader.klass = rb_define_class_under(mLibSBML, "SBMLReader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLReader, (void *) &SwigClassSBMLReader);
  rb_define_alloc_func(SwigClassSBMLReader.klass, _wrap_SBMLReader_allocate);
  rb_define_method(SwigClassSBMLReader.klass, "initialize", VALUEFUNC(_wrap_new_SBMLReader), -1);
  rb_define_method(SwigClassSBMLReader.klass, "readSBML", VALUEFUNC(_wrap_SBMLReader_readSBML), -1);
  rb_define_method(SwigClassSBMLReader.klass, "readSBMLFromFile", VALUEFUNC(_wrap_SBMLReader_readSBMLFromFile), -1);
  rb_define_method(SwigClassSBMLReader.klass, "readSBMLFromString", VALUEFUNC(_wrap_SBMLReader_readSBMLFromString), -1);
  rb_define_singleton_method(SwigClassSBMLReader.klass, "hasZlib", VALUEFUNC(_wrap_SBMLReader_hasZlib), -1);
  rb_define_singleton_method(SwigClassSBMLReader.klass, "hasBzip2", VALUEFUNC(_wrap_SBMLReader_hasBzip2), -1);
  SwigClassSBMLReader.mark = 0;
  SwigClassSBMLReader.destroy = (void (*)(void *)) free_SBMLReader;
  SwigClassSBMLReader.trackObjects = 1;
  rb_define_module_function(mLibSBML, "readSBML", VALUEFUNC(_wrap_readSBML), -1);
  rb_define_module_function(mLibSBML, "readSBMLFromFile", VALUEFUNC(_wrap_readSBMLFromFile), -1);
  rb_define_module_function(mLibSBML, "readSBMLFromString", VALUEFUNC(_wrap_readSBMLFromString), -1);
  
  SwigClassSBMLWriter.klass = rb_define_class_under(mLibSBML, "SBMLWriter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLWriter, (void *) &SwigClassSBMLWriter);
  rb_define_alloc_func(SwigClassSBMLWriter.klass, _wrap_SBMLWriter_allocate);
  rb_define_method(SwigClassSBMLWriter.klass, "initialize", VALUEFUNC(_wrap_new_SBMLWriter), -1);
  rb_define_method(SwigClassSBMLWriter.klass, "setProgramName", VALUEFUNC(_wrap_SBMLWriter_setProgramName), -1);
  rb_define_method(SwigClassSBMLWriter.klass, "setProgramVersion", VALUEFUNC(_wrap_SBMLWriter_setProgramVersion), -1);
  rb_define_method(SwigClassSBMLWriter.klass, "writeSBML", VALUEFUNC(_wrap_SBMLWriter_writeSBML), -1);
  rb_define_method(SwigClassSBMLWriter.klass, "writeToString", VALUEFUNC(_wrap_SBMLWriter_writeToString), -1);
  rb_define_method(SwigClassSBMLWriter.klass, "writeSBMLToFile", VALUEFUNC(_wrap_SBMLWriter_writeSBMLToFile), -1);
  rb_define_method(SwigClassSBMLWriter.klass, "writeSBMLToString", VALUEFUNC(_wrap_SBMLWriter_writeSBMLToString), -1);
  rb_define_singleton_method(SwigClassSBMLWriter.klass, "hasZlib", VALUEFUNC(_wrap_SBMLWriter_hasZlib), -1);
  rb_define_singleton_method(SwigClassSBMLWriter.klass, "hasBzip2", VALUEFUNC(_wrap_SBMLWriter_hasBzip2), -1);
  SwigClassSBMLWriter.mark = 0;
  SwigClassSBMLWriter.destroy = (void (*)(void *)) free_SBMLWriter;
  SwigClassSBMLWriter.trackObjects = 1;
  rb_define_module_function(mLibSBML, "writeSBML", VALUEFUNC(_wrap_writeSBML), -1);
  rb_define_module_function(mLibSBML, "writeSBMLToString", VALUEFUNC(_wrap_writeSBMLToString), -1);
  rb_define_module_function(mLibSBML, "writeSBMLToFile", VALUEFUNC(_wrap_writeSBMLToFile), -1);
  rb_define_const(mLibSBML, "SBML_UNKNOWN", SWIG_From_int(static_cast< int >(SBML_UNKNOWN)));
  rb_define_const(mLibSBML, "SBML_COMPARTMENT", SWIG_From_int(static_cast< int >(SBML_COMPARTMENT)));
  rb_define_const(mLibSBML, "SBML_COMPARTMENT_TYPE", SWIG_From_int(static_cast< int >(SBML_COMPARTMENT_TYPE)));
  rb_define_const(mLibSBML, "SBML_CONSTRAINT", SWIG_From_int(static_cast< int >(SBML_CONSTRAINT)));
  rb_define_const(mLibSBML, "SBML_DOCUMENT", SWIG_From_int(static_cast< int >(SBML_DOCUMENT)));
  rb_define_const(mLibSBML, "SBML_EVENT", SWIG_From_int(static_cast< int >(SBML_EVENT)));
  rb_define_const(mLibSBML, "SBML_EVENT_ASSIGNMENT", SWIG_From_int(static_cast< int >(SBML_EVENT_ASSIGNMENT)));
  rb_define_const(mLibSBML, "SBML_FUNCTION_DEFINITION", SWIG_From_int(static_cast< int >(SBML_FUNCTION_DEFINITION)));
  rb_define_const(mLibSBML, "SBML_INITIAL_ASSIGNMENT", SWIG_From_int(static_cast< int >(SBML_INITIAL_ASSIGNMENT)));
  rb_define_const(mLibSBML, "SBML_KINETIC_LAW", SWIG_From_int(static_cast< int >(SBML_KINETIC_LAW)));
  rb_define_const(mLibSBML, "SBML_LIST_OF", SWIG_From_int(static_cast< int >(SBML_LIST_OF)));
  rb_define_const(mLibSBML, "SBML_MODEL", SWIG_From_int(static_cast< int >(SBML_MODEL)));
  rb_define_const(mLibSBML, "SBML_PARAMETER", SWIG_From_int(static_cast< int >(SBML_PARAMETER)));
  rb_define_const(mLibSBML, "SBML_REACTION", SWIG_From_int(static_cast< int >(SBML_REACTION)));
  rb_define_const(mLibSBML, "SBML_RULE", SWIG_From_int(static_cast< int >(SBML_RULE)));
  rb_define_const(mLibSBML, "SBML_SPECIES", SWIG_From_int(static_cast< int >(SBML_SPECIES)));
  rb_define_const(mLibSBML, "SBML_SPECIES_REFERENCE", SWIG_From_int(static_cast< int >(SBML_SPECIES_REFERENCE)));
  rb_define_const(mLibSBML, "SBML_SPECIES_TYPE", SWIG_From_int(static_cast< int >(SBML_SPECIES_TYPE)));
  rb_define_const(mLibSBML, "SBML_MODIFIER_SPECIES_REFERENCE", SWIG_From_int(static_cast< int >(SBML_MODIFIER_SPECIES_REFERENCE)));
  rb_define_const(mLibSBML, "SBML_UNIT_DEFINITION", SWIG_From_int(static_cast< int >(SBML_UNIT_DEFINITION)));
  rb_define_const(mLibSBML, "SBML_UNIT", SWIG_From_int(static_cast< int >(SBML_UNIT)));
  rb_define_const(mLibSBML, "SBML_ALGEBRAIC_RULE", SWIG_From_int(static_cast< int >(SBML_ALGEBRAIC_RULE)));
  rb_define_const(mLibSBML, "SBML_ASSIGNMENT_RULE", SWIG_From_int(static_cast< int >(SBML_ASSIGNMENT_RULE)));
  rb_define_const(mLibSBML, "SBML_RATE_RULE", SWIG_From_int(static_cast< int >(SBML_RATE_RULE)));
  rb_define_const(mLibSBML, "SBML_SPECIES_CONCENTRATION_RULE", SWIG_From_int(static_cast< int >(SBML_SPECIES_CONCENTRATION_RULE)));
  rb_define_const(mLibSBML, "SBML_COMPARTMENT_VOLUME_RULE", SWIG_From_int(static_cast< int >(SBML_COMPARTMENT_VOLUME_RULE)));
  rb_define_const(mLibSBML, "SBML_PARAMETER_RULE", SWIG_From_int(static_cast< int >(SBML_PARAMETER_RULE)));
  rb_define_const(mLibSBML, "SBML_TRIGGER", SWIG_From_int(static_cast< int >(SBML_TRIGGER)));
  rb_define_const(mLibSBML, "SBML_DELAY", SWIG_From_int(static_cast< int >(SBML_DELAY)));
  rb_define_const(mLibSBML, "SBML_STOICHIOMETRY_MATH", SWIG_From_int(static_cast< int >(SBML_STOICHIOMETRY_MATH)));
  rb_define_const(mLibSBML, "SBML_LOCAL_PARAMETER", SWIG_From_int(static_cast< int >(SBML_LOCAL_PARAMETER)));
  rb_define_const(mLibSBML, "SBML_PRIORITY", SWIG_From_int(static_cast< int >(SBML_PRIORITY)));
  rb_define_module_function(mLibSBML, "SBMLTypeCode_toString", VALUEFUNC(_wrap_SBMLTypeCode_toString), -1);
  
  SwigClassSBMLConstructorException.klass = rb_define_class_under(mLibSBML, "SBMLConstructorException", rb_eRuntimeError);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLConstructorException, (void *) &SwigClassSBMLConstructorException);
  rb_define_alloc_func(SwigClassSBMLConstructorException.klass, _wrap_SBMLConstructorException_allocate);
  rb_define_method(SwigClassSBMLConstructorException.klass, "initialize", VALUEFUNC(_wrap_new_SBMLConstructorException), -1);
  rb_define_method(SwigClassSBMLConstructorException.klass, "getSBMLErrMsg", VALUEFUNC(_wrap_SBMLConstructorException_getSBMLErrMsg), -1);
  SwigClassSBMLConstructorException.mark = 0;
  SwigClassSBMLConstructorException.destroy = (void (*)(void *)) free_SBMLConstructorException;
  SwigClassSBMLConstructorException.trackObjects = 1;
  
  SwigClassSBase.klass = rb_define_class_under(mLibSBML, "SBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBase, (void *) &SwigClassSBase);
  rb_undef_alloc_func(SwigClassSBase.klass);
  rb_define_method(SwigClassSBase.klass, "clone", VALUEFUNC(_wrap_SBase_clone), -1);
  rb_define_method(SwigClassSBase.klass, "getMetaId", VALUEFUNC(_wrap_SBase_getMetaId), -1);
  rb_define_method(SwigClassSBase.klass, "getId", VALUEFUNC(_wrap_SBase_getId), -1);
  rb_define_method(SwigClassSBase.klass, "getName", VALUEFUNC(_wrap_SBase_getName), -1);
  rb_define_method(SwigClassSBase.klass, "getNotes", VALUEFUNC(_wrap_SBase_getNotes), -1);
  rb_define_method(SwigClassSBase.klass, "getNotesString", VALUEFUNC(_wrap_SBase_getNotesString), -1);
  rb_define_method(SwigClassSBase.klass, "getAnnotation", VALUEFUNC(_wrap_SBase_getAnnotation), -1);
  rb_define_method(SwigClassSBase.klass, "getAnnotationString", VALUEFUNC(_wrap_SBase_getAnnotationString), -1);
  rb_define_method(SwigClassSBase.klass, "getNamespaces", VALUEFUNC(_wrap_SBase_getNamespaces), -1);
  rb_define_method(SwigClassSBase.klass, "getSBMLDocument", VALUEFUNC(_wrap_SBase_getSBMLDocument), -1);
  rb_define_method(SwigClassSBase.klass, "getParentSBMLObject", VALUEFUNC(_wrap_SBase_getParentSBMLObject), -1);
  rb_define_method(SwigClassSBase.klass, "getAncestorOfType", VALUEFUNC(_wrap_SBase_getAncestorOfType), -1);
  rb_define_method(SwigClassSBase.klass, "getSBOTerm", VALUEFUNC(_wrap_SBase_getSBOTerm), -1);
  rb_define_method(SwigClassSBase.klass, "getSBOTermID", VALUEFUNC(_wrap_SBase_getSBOTermID), -1);
  rb_define_method(SwigClassSBase.klass, "getLine", VALUEFUNC(_wrap_SBase_getLine), -1);
  rb_define_method(SwigClassSBase.klass, "getColumn", VALUEFUNC(_wrap_SBase_getColumn), -1);
  rb_define_method(SwigClassSBase.klass, "getModelHistory", VALUEFUNC(_wrap_SBase_getModelHistory), -1);
  rb_define_method(SwigClassSBase.klass, "isSetMetaId", VALUEFUNC(_wrap_SBase_isSetMetaId), -1);
  rb_define_method(SwigClassSBase.klass, "isSetId", VALUEFUNC(_wrap_SBase_isSetId), -1);
  rb_define_method(SwigClassSBase.klass, "isSetName", VALUEFUNC(_wrap_SBase_isSetName), -1);
  rb_define_method(SwigClassSBase.klass, "isSetNotes", VALUEFUNC(_wrap_SBase_isSetNotes), -1);
  rb_define_method(SwigClassSBase.klass, "isSetAnnotation", VALUEFUNC(_wrap_SBase_isSetAnnotation), -1);
  rb_define_method(SwigClassSBase.klass, "isSetSBOTerm", VALUEFUNC(_wrap_SBase_isSetSBOTerm), -1);
  rb_define_method(SwigClassSBase.klass, "setMetaId", VALUEFUNC(_wrap_SBase_setMetaId), -1);
  rb_define_method(SwigClassSBase.klass, "isSetModelHistory", VALUEFUNC(_wrap_SBase_isSetModelHistory), -1);
  rb_define_method(SwigClassSBase.klass, "setId", VALUEFUNC(_wrap_SBase_setId), -1);
  rb_define_method(SwigClassSBase.klass, "setName", VALUEFUNC(_wrap_SBase_setName), -1);
  rb_define_method(SwigClassSBase.klass, "setAnnotation", VALUEFUNC(_wrap_SBase_setAnnotation), -1);
  rb_define_method(SwigClassSBase.klass, "appendAnnotation", VALUEFUNC(_wrap_SBase_appendAnnotation), -1);
  rb_define_method(SwigClassSBase.klass, "setNotes", VALUEFUNC(_wrap_SBase_setNotes), -1);
  rb_define_method(SwigClassSBase.klass, "appendNotes", VALUEFUNC(_wrap_SBase_appendNotes), -1);
  rb_define_method(SwigClassSBase.klass, "setModelHistory", VALUEFUNC(_wrap_SBase_setModelHistory), -1);
  rb_define_method(SwigClassSBase.klass, "connectToParent", VALUEFUNC(_wrap_SBase_connectToParent), -1);
  rb_define_method(SwigClassSBase.klass, "connectToChild", VALUEFUNC(_wrap_SBase_connectToChild), -1);
  rb_define_method(SwigClassSBase.klass, "setSBOTerm", VALUEFUNC(_wrap_SBase_setSBOTerm), -1);
  rb_define_method(SwigClassSBase.klass, "setNamespaces", VALUEFUNC(_wrap_SBase_setNamespaces), -1);
  rb_define_method(SwigClassSBase.klass, "unsetMetaId", VALUEFUNC(_wrap_SBase_unsetMetaId), -1);
  rb_define_method(SwigClassSBase.klass, "unsetId", VALUEFUNC(_wrap_SBase_unsetId), -1);
  rb_define_method(SwigClassSBase.klass, "unsetName", VALUEFUNC(_wrap_SBase_unsetName), -1);
  rb_define_method(SwigClassSBase.klass, "unsetNotes", VALUEFUNC(_wrap_SBase_unsetNotes), -1);
  rb_define_method(SwigClassSBase.klass, "unsetAnnotation", VALUEFUNC(_wrap_SBase_unsetAnnotation), -1);
  rb_define_method(SwigClassSBase.klass, "unsetSBOTerm", VALUEFUNC(_wrap_SBase_unsetSBOTerm), -1);
  rb_define_method(SwigClassSBase.klass, "addCVTerm", VALUEFUNC(_wrap_SBase_addCVTerm), -1);
  rb_define_method(SwigClassSBase.klass, "getCVTerms", VALUEFUNC(_wrap_SBase_getCVTerms), -1);
  rb_define_method(SwigClassSBase.klass, "getNumCVTerms", VALUEFUNC(_wrap_SBase_getNumCVTerms), -1);
  rb_define_method(SwigClassSBase.klass, "getCVTerm", VALUEFUNC(_wrap_SBase_getCVTerm), -1);
  rb_define_method(SwigClassSBase.klass, "unsetCVTerms", VALUEFUNC(_wrap_SBase_unsetCVTerms), -1);
  rb_define_method(SwigClassSBase.klass, "unsetModelHistory", VALUEFUNC(_wrap_SBase_unsetModelHistory), -1);
  rb_define_method(SwigClassSBase.klass, "getResourceBiologicalQualifier", VALUEFUNC(_wrap_SBase_getResourceBiologicalQualifier), -1);
  rb_define_method(SwigClassSBase.klass, "getResourceModelQualifier", VALUEFUNC(_wrap_SBase_getResourceModelQualifier), -1);
  rb_define_method(SwigClassSBase.klass, "getModel", VALUEFUNC(_wrap_SBase_getModel), -1);
  rb_define_method(SwigClassSBase.klass, "getLevel", VALUEFUNC(_wrap_SBase_getLevel), -1);
  rb_define_method(SwigClassSBase.klass, "getVersion", VALUEFUNC(_wrap_SBase_getVersion), -1);
  rb_define_method(SwigClassSBase.klass, "getPackageVersion", VALUEFUNC(_wrap_SBase_getPackageVersion), -1);
  rb_define_method(SwigClassSBase.klass, "getPackageName", VALUEFUNC(_wrap_SBase_getPackageName), -1);
  rb_define_method(SwigClassSBase.klass, "getTypeCode", VALUEFUNC(_wrap_SBase_getTypeCode), -1);
  rb_define_method(SwigClassSBase.klass, "hasValidLevelVersionNamespaceCombination", VALUEFUNC(_wrap_SBase_hasValidLevelVersionNamespaceCombination), -1);
  rb_define_method(SwigClassSBase.klass, "getElementName", VALUEFUNC(_wrap_SBase_getElementName), -1);
  rb_define_method(SwigClassSBase.klass, "toSBML", VALUEFUNC(_wrap_SBase_toSBML), -1);
  rb_define_method(SwigClassSBase.klass, "getPlugin", VALUEFUNC(_wrap_SBase_getPlugin), -1);
  rb_define_method(SwigClassSBase.klass, "getNumPlugins", VALUEFUNC(_wrap_SBase_getNumPlugins), -1);
  rb_define_method(SwigClassSBase.klass, "enablePackage", VALUEFUNC(_wrap_SBase_enablePackage), -1);
  rb_define_method(SwigClassSBase.klass, "enablePackageInternal", VALUEFUNC(_wrap_SBase_enablePackageInternal), -1);
  rb_define_method(SwigClassSBase.klass, "isPkgURIEnabled", VALUEFUNC(_wrap_SBase_isPkgURIEnabled), -1);
  rb_define_method(SwigClassSBase.klass, "isPkgEnabled", VALUEFUNC(_wrap_SBase_isPkgEnabled), -1);
  rb_define_method(SwigClassSBase.klass, "writeExtensionElements", VALUEFUNC(_wrap_SBase_writeExtensionElements), -1);
  rb_define_method(SwigClassSBase.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_SBase_hasRequiredAttributes), -1);
  rb_define_method(SwigClassSBase.klass, "hasRequiredElements", VALUEFUNC(_wrap_SBase_hasRequiredElements), -1);
  rb_define_method(SwigClassSBase.klass, "setSBMLNamespacesAndOwn", VALUEFUNC(_wrap_SBase_setSBMLNamespacesAndOwn), -1);
  rb_define_method(SwigClassSBase.klass, "getSBMLNamespaces", VALUEFUNC(_wrap_SBase_getSBMLNamespaces), -1);
  rb_define_method(SwigClassSBase.klass, "checkMathMLNamespace", VALUEFUNC(_wrap_SBase_checkMathMLNamespace), -1);
  rb_define_method(SwigClassSBase.klass, "to_s", VALUEFUNC(_wrap_SBase___str__), -1);
  SwigClassSBase.mark = 0;
  SwigClassSBase.destroy = (void (*)(void *)) free_SBase;
  SwigClassSBase.trackObjects = 1;
  
  SwigClassListOf.klass = rb_define_class_under(mLibSBML, "ListOf", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOf, (void *) &SwigClassListOf);
  rb_include_module(SwigClassListOf.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassListOf.klass, _wrap_ListOf_allocate);
  rb_define_method(SwigClassListOf.klass, "initialize", VALUEFUNC(_wrap_new_ListOf), -1);
  rb_define_method(SwigClassListOf.klass, "clone", VALUEFUNC(_wrap_ListOf_clone), -1);
  rb_define_method(SwigClassListOf.klass, "append", VALUEFUNC(_wrap_ListOf_append), -1);
  rb_define_method(SwigClassListOf.klass, "appendAndOwn", VALUEFUNC(_wrap_ListOf_appendAndOwn), -1);
  rb_define_method(SwigClassListOf.klass, "get", VALUEFUNC(_wrap_ListOf_get), -1);
  rb_define_method(SwigClassListOf.klass, "clear", VALUEFUNC(_wrap_ListOf_clear), -1);
  rb_define_method(SwigClassListOf.klass, "remove", VALUEFUNC(_wrap_ListOf_remove), -1);
  rb_define_method(SwigClassListOf.klass, "size", VALUEFUNC(_wrap_ListOf_size), -1);
  rb_define_method(SwigClassListOf.klass, "connectToChild", VALUEFUNC(_wrap_ListOf_connectToChild), -1);
  rb_define_method(SwigClassListOf.klass, "getTypeCode", VALUEFUNC(_wrap_ListOf_getTypeCode), -1);
  rb_define_method(SwigClassListOf.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOf_getItemTypeCode), -1);
  rb_define_method(SwigClassListOf.klass, "getElementName", VALUEFUNC(_wrap_ListOf_getElementName), -1);
  rb_define_method(SwigClassListOf.klass, "enablePackageInternal", VALUEFUNC(_wrap_ListOf_enablePackageInternal), -1);
  rb_define_method(SwigClassListOf.klass, "length", VALUEFUNC(_wrap_ListOf___len__), -1);
  rb_define_method(SwigClassListOf.klass, "[]", VALUEFUNC(_wrap_ListOf___getitem__), -1);
  rb_define_method(SwigClassListOf.klass, "each", VALUEFUNC(_wrap_ListOf_each), -1);
  SwigClassListOf.mark = 0;
  SwigClassListOf.destroy = (void (*)(void *)) free_ListOf;
  SwigClassListOf.trackObjects = 1;
  
  SwigClassModel.klass = rb_define_class_under(mLibSBML, "Model", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Model, (void *) &SwigClassModel);
  rb_define_alloc_func(SwigClassModel.klass, _wrap_Model_allocate);
  rb_define_method(SwigClassModel.klass, "initialize", VALUEFUNC(_wrap_new_Model), -1);
  rb_define_method(SwigClassModel.klass, "clone", VALUEFUNC(_wrap_Model_clone), -1);
  rb_define_method(SwigClassModel.klass, "getId", VALUEFUNC(_wrap_Model_getId), -1);
  rb_define_method(SwigClassModel.klass, "getName", VALUEFUNC(_wrap_Model_getName), -1);
  rb_define_method(SwigClassModel.klass, "getSubstanceUnits", VALUEFUNC(_wrap_Model_getSubstanceUnits), -1);
  rb_define_method(SwigClassModel.klass, "getTimeUnits", VALUEFUNC(_wrap_Model_getTimeUnits), -1);
  rb_define_method(SwigClassModel.klass, "getVolumeUnits", VALUEFUNC(_wrap_Model_getVolumeUnits), -1);
  rb_define_method(SwigClassModel.klass, "getAreaUnits", VALUEFUNC(_wrap_Model_getAreaUnits), -1);
  rb_define_method(SwigClassModel.klass, "getLengthUnits", VALUEFUNC(_wrap_Model_getLengthUnits), -1);
  rb_define_method(SwigClassModel.klass, "getExtentUnits", VALUEFUNC(_wrap_Model_getExtentUnits), -1);
  rb_define_method(SwigClassModel.klass, "getConversionFactor", VALUEFUNC(_wrap_Model_getConversionFactor), -1);
  rb_define_method(SwigClassModel.klass, "isSetId", VALUEFUNC(_wrap_Model_isSetId), -1);
  rb_define_method(SwigClassModel.klass, "isSetName", VALUEFUNC(_wrap_Model_isSetName), -1);
  rb_define_method(SwigClassModel.klass, "isSetSubstanceUnits", VALUEFUNC(_wrap_Model_isSetSubstanceUnits), -1);
  rb_define_method(SwigClassModel.klass, "isSetTimeUnits", VALUEFUNC(_wrap_Model_isSetTimeUnits), -1);
  rb_define_method(SwigClassModel.klass, "isSetVolumeUnits", VALUEFUNC(_wrap_Model_isSetVolumeUnits), -1);
  rb_define_method(SwigClassModel.klass, "isSetAreaUnits", VALUEFUNC(_wrap_Model_isSetAreaUnits), -1);
  rb_define_method(SwigClassModel.klass, "isSetLengthUnits", VALUEFUNC(_wrap_Model_isSetLengthUnits), -1);
  rb_define_method(SwigClassModel.klass, "isSetExtentUnits", VALUEFUNC(_wrap_Model_isSetExtentUnits), -1);
  rb_define_method(SwigClassModel.klass, "isSetConversionFactor", VALUEFUNC(_wrap_Model_isSetConversionFactor), -1);
  rb_define_method(SwigClassModel.klass, "setId", VALUEFUNC(_wrap_Model_setId), -1);
  rb_define_method(SwigClassModel.klass, "setName", VALUEFUNC(_wrap_Model_setName), -1);
  rb_define_method(SwigClassModel.klass, "setSubstanceUnits", VALUEFUNC(_wrap_Model_setSubstanceUnits), -1);
  rb_define_method(SwigClassModel.klass, "setTimeUnits", VALUEFUNC(_wrap_Model_setTimeUnits), -1);
  rb_define_method(SwigClassModel.klass, "setVolumeUnits", VALUEFUNC(_wrap_Model_setVolumeUnits), -1);
  rb_define_method(SwigClassModel.klass, "setAreaUnits", VALUEFUNC(_wrap_Model_setAreaUnits), -1);
  rb_define_method(SwigClassModel.klass, "setLengthUnits", VALUEFUNC(_wrap_Model_setLengthUnits), -1);
  rb_define_method(SwigClassModel.klass, "setExtentUnits", VALUEFUNC(_wrap_Model_setExtentUnits), -1);
  rb_define_method(SwigClassModel.klass, "setConversionFactor", VALUEFUNC(_wrap_Model_setConversionFactor), -1);
  rb_define_method(SwigClassModel.klass, "unsetId", VALUEFUNC(_wrap_Model_unsetId), -1);
  rb_define_method(SwigClassModel.klass, "unsetName", VALUEFUNC(_wrap_Model_unsetName), -1);
  rb_define_method(SwigClassModel.klass, "unsetSubstanceUnits", VALUEFUNC(_wrap_Model_unsetSubstanceUnits), -1);
  rb_define_method(SwigClassModel.klass, "unsetTimeUnits", VALUEFUNC(_wrap_Model_unsetTimeUnits), -1);
  rb_define_method(SwigClassModel.klass, "unsetVolumeUnits", VALUEFUNC(_wrap_Model_unsetVolumeUnits), -1);
  rb_define_method(SwigClassModel.klass, "unsetAreaUnits", VALUEFUNC(_wrap_Model_unsetAreaUnits), -1);
  rb_define_method(SwigClassModel.klass, "unsetLengthUnits", VALUEFUNC(_wrap_Model_unsetLengthUnits), -1);
  rb_define_method(SwigClassModel.klass, "unsetExtentUnits", VALUEFUNC(_wrap_Model_unsetExtentUnits), -1);
  rb_define_method(SwigClassModel.klass, "unsetConversionFactor", VALUEFUNC(_wrap_Model_unsetConversionFactor), -1);
  rb_define_method(SwigClassModel.klass, "addFunctionDefinition", VALUEFUNC(_wrap_Model_addFunctionDefinition), -1);
  rb_define_method(SwigClassModel.klass, "addUnitDefinition", VALUEFUNC(_wrap_Model_addUnitDefinition), -1);
  rb_define_method(SwigClassModel.klass, "addCompartmentType", VALUEFUNC(_wrap_Model_addCompartmentType), -1);
  rb_define_method(SwigClassModel.klass, "addSpeciesType", VALUEFUNC(_wrap_Model_addSpeciesType), -1);
  rb_define_method(SwigClassModel.klass, "addCompartment", VALUEFUNC(_wrap_Model_addCompartment), -1);
  rb_define_method(SwigClassModel.klass, "addSpecies", VALUEFUNC(_wrap_Model_addSpecies), -1);
  rb_define_method(SwigClassModel.klass, "addParameter", VALUEFUNC(_wrap_Model_addParameter), -1);
  rb_define_method(SwigClassModel.klass, "addInitialAssignment", VALUEFUNC(_wrap_Model_addInitialAssignment), -1);
  rb_define_method(SwigClassModel.klass, "addRule", VALUEFUNC(_wrap_Model_addRule), -1);
  rb_define_method(SwigClassModel.klass, "addConstraint", VALUEFUNC(_wrap_Model_addConstraint), -1);
  rb_define_method(SwigClassModel.klass, "addReaction", VALUEFUNC(_wrap_Model_addReaction), -1);
  rb_define_method(SwigClassModel.klass, "addEvent", VALUEFUNC(_wrap_Model_addEvent), -1);
  rb_define_method(SwigClassModel.klass, "createFunctionDefinition", VALUEFUNC(_wrap_Model_createFunctionDefinition), -1);
  rb_define_method(SwigClassModel.klass, "createUnitDefinition", VALUEFUNC(_wrap_Model_createUnitDefinition), -1);
  rb_define_method(SwigClassModel.klass, "createUnit", VALUEFUNC(_wrap_Model_createUnit), -1);
  rb_define_method(SwigClassModel.klass, "createCompartmentType", VALUEFUNC(_wrap_Model_createCompartmentType), -1);
  rb_define_method(SwigClassModel.klass, "createSpeciesType", VALUEFUNC(_wrap_Model_createSpeciesType), -1);
  rb_define_method(SwigClassModel.klass, "createCompartment", VALUEFUNC(_wrap_Model_createCompartment), -1);
  rb_define_method(SwigClassModel.klass, "createSpecies", VALUEFUNC(_wrap_Model_createSpecies), -1);
  rb_define_method(SwigClassModel.klass, "createParameter", VALUEFUNC(_wrap_Model_createParameter), -1);
  rb_define_method(SwigClassModel.klass, "createInitialAssignment", VALUEFUNC(_wrap_Model_createInitialAssignment), -1);
  rb_define_method(SwigClassModel.klass, "createAlgebraicRule", VALUEFUNC(_wrap_Model_createAlgebraicRule), -1);
  rb_define_method(SwigClassModel.klass, "createAssignmentRule", VALUEFUNC(_wrap_Model_createAssignmentRule), -1);
  rb_define_method(SwigClassModel.klass, "createRateRule", VALUEFUNC(_wrap_Model_createRateRule), -1);
  rb_define_method(SwigClassModel.klass, "createConstraint", VALUEFUNC(_wrap_Model_createConstraint), -1);
  rb_define_method(SwigClassModel.klass, "createReaction", VALUEFUNC(_wrap_Model_createReaction), -1);
  rb_define_method(SwigClassModel.klass, "createReactant", VALUEFUNC(_wrap_Model_createReactant), -1);
  rb_define_method(SwigClassModel.klass, "createProduct", VALUEFUNC(_wrap_Model_createProduct), -1);
  rb_define_method(SwigClassModel.klass, "createModifier", VALUEFUNC(_wrap_Model_createModifier), -1);
  rb_define_method(SwigClassModel.klass, "createKineticLaw", VALUEFUNC(_wrap_Model_createKineticLaw), -1);
  rb_define_method(SwigClassModel.klass, "createKineticLawParameter", VALUEFUNC(_wrap_Model_createKineticLawParameter), -1);
  rb_define_method(SwigClassModel.klass, "createKineticLawLocalParameter", VALUEFUNC(_wrap_Model_createKineticLawLocalParameter), -1);
  rb_define_method(SwigClassModel.klass, "createEvent", VALUEFUNC(_wrap_Model_createEvent), -1);
  rb_define_method(SwigClassModel.klass, "createEventAssignment", VALUEFUNC(_wrap_Model_createEventAssignment), -1);
  rb_define_method(SwigClassModel.klass, "createTrigger", VALUEFUNC(_wrap_Model_createTrigger), -1);
  rb_define_method(SwigClassModel.klass, "createDelay", VALUEFUNC(_wrap_Model_createDelay), -1);
  rb_define_method(SwigClassModel.klass, "setAnnotation", VALUEFUNC(_wrap_Model_setAnnotation), -1);
  rb_define_method(SwigClassModel.klass, "appendAnnotation", VALUEFUNC(_wrap_Model_appendAnnotation), -1);
  rb_define_method(SwigClassModel.klass, "getListOfFunctionDefinitions", VALUEFUNC(_wrap_Model_getListOfFunctionDefinitions), -1);
  rb_define_method(SwigClassModel.klass, "getListOfUnitDefinitions", VALUEFUNC(_wrap_Model_getListOfUnitDefinitions), -1);
  rb_define_method(SwigClassModel.klass, "getListOfCompartmentTypes", VALUEFUNC(_wrap_Model_getListOfCompartmentTypes), -1);
  rb_define_method(SwigClassModel.klass, "getListOfSpeciesTypes", VALUEFUNC(_wrap_Model_getListOfSpeciesTypes), -1);
  rb_define_method(SwigClassModel.klass, "getListOfCompartments", VALUEFUNC(_wrap_Model_getListOfCompartments), -1);
  rb_define_method(SwigClassModel.klass, "getListOfSpecies", VALUEFUNC(_wrap_Model_getListOfSpecies), -1);
  rb_define_method(SwigClassModel.klass, "getListOfParameters", VALUEFUNC(_wrap_Model_getListOfParameters), -1);
  rb_define_method(SwigClassModel.klass, "getListOfInitialAssignments", VALUEFUNC(_wrap_Model_getListOfInitialAssignments), -1);
  rb_define_method(SwigClassModel.klass, "getListOfRules", VALUEFUNC(_wrap_Model_getListOfRules), -1);
  rb_define_method(SwigClassModel.klass, "getListOfConstraints", VALUEFUNC(_wrap_Model_getListOfConstraints), -1);
  rb_define_method(SwigClassModel.klass, "getListOfReactions", VALUEFUNC(_wrap_Model_getListOfReactions), -1);
  rb_define_method(SwigClassModel.klass, "getListOfEvents", VALUEFUNC(_wrap_Model_getListOfEvents), -1);
  rb_define_method(SwigClassModel.klass, "getFunctionDefinition", VALUEFUNC(_wrap_Model_getFunctionDefinition), -1);
  rb_define_method(SwigClassModel.klass, "getUnitDefinition", VALUEFUNC(_wrap_Model_getUnitDefinition), -1);
  rb_define_method(SwigClassModel.klass, "getCompartmentType", VALUEFUNC(_wrap_Model_getCompartmentType), -1);
  rb_define_method(SwigClassModel.klass, "getSpeciesType", VALUEFUNC(_wrap_Model_getSpeciesType), -1);
  rb_define_method(SwigClassModel.klass, "getCompartment", VALUEFUNC(_wrap_Model_getCompartment), -1);
  rb_define_method(SwigClassModel.klass, "getSpecies", VALUEFUNC(_wrap_Model_getSpecies), -1);
  rb_define_method(SwigClassModel.klass, "getParameter", VALUEFUNC(_wrap_Model_getParameter), -1);
  rb_define_method(SwigClassModel.klass, "getInitialAssignment", VALUEFUNC(_wrap_Model_getInitialAssignment), -1);
  rb_define_method(SwigClassModel.klass, "getRule", VALUEFUNC(_wrap_Model_getRule), -1);
  rb_define_method(SwigClassModel.klass, "getConstraint", VALUEFUNC(_wrap_Model_getConstraint), -1);
  rb_define_method(SwigClassModel.klass, "getReaction", VALUEFUNC(_wrap_Model_getReaction), -1);
  rb_define_method(SwigClassModel.klass, "getSpeciesReference", VALUEFUNC(_wrap_Model_getSpeciesReference), -1);
  rb_define_method(SwigClassModel.klass, "getEvent", VALUEFUNC(_wrap_Model_getEvent), -1);
  rb_define_method(SwigClassModel.klass, "getNumFunctionDefinitions", VALUEFUNC(_wrap_Model_getNumFunctionDefinitions), -1);
  rb_define_method(SwigClassModel.klass, "getNumUnitDefinitions", VALUEFUNC(_wrap_Model_getNumUnitDefinitions), -1);
  rb_define_method(SwigClassModel.klass, "getNumCompartmentTypes", VALUEFUNC(_wrap_Model_getNumCompartmentTypes), -1);
  rb_define_method(SwigClassModel.klass, "getNumSpeciesTypes", VALUEFUNC(_wrap_Model_getNumSpeciesTypes), -1);
  rb_define_method(SwigClassModel.klass, "getNumCompartments", VALUEFUNC(_wrap_Model_getNumCompartments), -1);
  rb_define_method(SwigClassModel.klass, "getNumSpecies", VALUEFUNC(_wrap_Model_getNumSpecies), -1);
  rb_define_method(SwigClassModel.klass, "getNumSpeciesWithBoundaryCondition", VALUEFUNC(_wrap_Model_getNumSpeciesWithBoundaryCondition), -1);
  rb_define_method(SwigClassModel.klass, "getNumParameters", VALUEFUNC(_wrap_Model_getNumParameters), -1);
  rb_define_method(SwigClassModel.klass, "getNumInitialAssignments", VALUEFUNC(_wrap_Model_getNumInitialAssignments), -1);
  rb_define_method(SwigClassModel.klass, "getNumRules", VALUEFUNC(_wrap_Model_getNumRules), -1);
  rb_define_method(SwigClassModel.klass, "getNumConstraints", VALUEFUNC(_wrap_Model_getNumConstraints), -1);
  rb_define_method(SwigClassModel.klass, "getNumReactions", VALUEFUNC(_wrap_Model_getNumReactions), -1);
  rb_define_method(SwigClassModel.klass, "getNumEvents", VALUEFUNC(_wrap_Model_getNumEvents), -1);
  rb_define_method(SwigClassModel.klass, "convertL1ToL2", VALUEFUNC(_wrap_Model_convertL1ToL2), -1);
  rb_define_method(SwigClassModel.klass, "convertL1ToL3", VALUEFUNC(_wrap_Model_convertL1ToL3), -1);
  rb_define_method(SwigClassModel.klass, "convertL2ToL3", VALUEFUNC(_wrap_Model_convertL2ToL3), -1);
  rb_define_method(SwigClassModel.klass, "convertL2ToL1", VALUEFUNC(_wrap_Model_convertL2ToL1), -1);
  rb_define_method(SwigClassModel.klass, "convertL3ToL1", VALUEFUNC(_wrap_Model_convertL3ToL1), -1);
  rb_define_method(SwigClassModel.klass, "convertL3ToL2", VALUEFUNC(_wrap_Model_convertL3ToL2), -1);
  rb_define_method(SwigClassModel.klass, "addModifiers", VALUEFUNC(_wrap_Model_addModifiers), -1);
  rb_define_method(SwigClassModel.klass, "addConstantAttribute", VALUEFUNC(_wrap_Model_addConstantAttribute), -1);
  rb_define_method(SwigClassModel.klass, "setSpatialDimensions", VALUEFUNC(_wrap_Model_setSpatialDimensions), -1);
  rb_define_method(SwigClassModel.klass, "addDefinitionsForDefaultUnits", VALUEFUNC(_wrap_Model_addDefinitionsForDefaultUnits), -1);
  rb_define_method(SwigClassModel.klass, "convertParametersToLocals", VALUEFUNC(_wrap_Model_convertParametersToLocals), -1);
  rb_define_method(SwigClassModel.klass, "setSpeciesReferenceConstantValueAndStoichiometry", VALUEFUNC(_wrap_Model_setSpeciesReferenceConstantValueAndStoichiometry), -1);
  rb_define_method(SwigClassModel.klass, "removeParameterRuleUnits", VALUEFUNC(_wrap_Model_removeParameterRuleUnits), -1);
  rb_define_method(SwigClassModel.klass, "convertStoichiometryMath", VALUEFUNC(_wrap_Model_convertStoichiometryMath), -1);
  rb_define_method(SwigClassModel.klass, "assignRequiredValues", VALUEFUNC(_wrap_Model_assignRequiredValues), -1);
  rb_define_method(SwigClassModel.klass, "dealWithModelUnits", VALUEFUNC(_wrap_Model_dealWithModelUnits), -1);
  rb_define_method(SwigClassModel.klass, "dealWithStoichiometry", VALUEFUNC(_wrap_Model_dealWithStoichiometry), -1);
  rb_define_method(SwigClassModel.klass, "connectToChild", VALUEFUNC(_wrap_Model_connectToChild), -1);
  rb_define_method(SwigClassModel.klass, "getTypeCode", VALUEFUNC(_wrap_Model_getTypeCode), -1);
  rb_define_method(SwigClassModel.klass, "getElementName", VALUEFUNC(_wrap_Model_getElementName), -1);
  rb_define_method(SwigClassModel.klass, "populateListFormulaUnitsData", VALUEFUNC(_wrap_Model_populateListFormulaUnitsData), -1);
  rb_define_method(SwigClassModel.klass, "isPopulatedListFormulaUnitsData", VALUEFUNC(_wrap_Model_isPopulatedListFormulaUnitsData), -1);
  rb_define_method(SwigClassModel.klass, "hasRequiredElements", VALUEFUNC(_wrap_Model_hasRequiredElements), -1);
  rb_define_method(SwigClassModel.klass, "removeFunctionDefinition", VALUEFUNC(_wrap_Model_removeFunctionDefinition), -1);
  rb_define_method(SwigClassModel.klass, "removeUnitDefinition", VALUEFUNC(_wrap_Model_removeUnitDefinition), -1);
  rb_define_method(SwigClassModel.klass, "removeCompartmentType", VALUEFUNC(_wrap_Model_removeCompartmentType), -1);
  rb_define_method(SwigClassModel.klass, "removeSpeciesType", VALUEFUNC(_wrap_Model_removeSpeciesType), -1);
  rb_define_method(SwigClassModel.klass, "removeCompartment", VALUEFUNC(_wrap_Model_removeCompartment), -1);
  rb_define_method(SwigClassModel.klass, "removeSpecies", VALUEFUNC(_wrap_Model_removeSpecies), -1);
  rb_define_method(SwigClassModel.klass, "removeParameter", VALUEFUNC(_wrap_Model_removeParameter), -1);
  rb_define_method(SwigClassModel.klass, "removeInitialAssignment", VALUEFUNC(_wrap_Model_removeInitialAssignment), -1);
  rb_define_method(SwigClassModel.klass, "removeRule", VALUEFUNC(_wrap_Model_removeRule), -1);
  rb_define_method(SwigClassModel.klass, "removeConstraint", VALUEFUNC(_wrap_Model_removeConstraint), -1);
  rb_define_method(SwigClassModel.klass, "removeReaction", VALUEFUNC(_wrap_Model_removeReaction), -1);
  rb_define_method(SwigClassModel.klass, "removeEvent", VALUEFUNC(_wrap_Model_removeEvent), -1);
  rb_define_method(SwigClassModel.klass, "enablePackageInternal", VALUEFUNC(_wrap_Model_enablePackageInternal), -1);
  SwigClassModel.mark = 0;
  SwigClassModel.destroy = (void (*)(void *)) free_Model;
  SwigClassModel.trackObjects = 1;
  rb_define_const(mLibSBML, "IdCheckON", SWIG_From_int(static_cast< int >(0x01)));
  rb_define_const(mLibSBML, "IdCheckOFF", SWIG_From_int(static_cast< int >(0xfe)));
  rb_define_const(mLibSBML, "SBMLCheckON", SWIG_From_int(static_cast< int >(0x02)));
  rb_define_const(mLibSBML, "SBMLCheckOFF", SWIG_From_int(static_cast< int >(0xfd)));
  rb_define_const(mLibSBML, "SBOCheckON", SWIG_From_int(static_cast< int >(0x04)));
  rb_define_const(mLibSBML, "SBOCheckOFF", SWIG_From_int(static_cast< int >(0xfb)));
  rb_define_const(mLibSBML, "MathCheckON", SWIG_From_int(static_cast< int >(0x08)));
  rb_define_const(mLibSBML, "MathCheckOFF", SWIG_From_int(static_cast< int >(0xf7)));
  rb_define_const(mLibSBML, "UnitsCheckON", SWIG_From_int(static_cast< int >(0x10)));
  rb_define_const(mLibSBML, "UnitsCheckOFF", SWIG_From_int(static_cast< int >(0xef)));
  rb_define_const(mLibSBML, "OverdeterCheckON", SWIG_From_int(static_cast< int >(0x20)));
  rb_define_const(mLibSBML, "OverdeterCheckOFF", SWIG_From_int(static_cast< int >(0xdf)));
  rb_define_const(mLibSBML, "PracticeCheckON", SWIG_From_int(static_cast< int >(0x40)));
  rb_define_const(mLibSBML, "PracticeCheckOFF", SWIG_From_int(static_cast< int >(0xbf)));
  rb_define_const(mLibSBML, "AllChecksON", SWIG_From_int(static_cast< int >(0x7f)));
  
  SwigClassSBMLDocument.klass = rb_define_class_under(mLibSBML, "SBMLDocument", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLDocument, (void *) &SwigClassSBMLDocument);
  rb_define_alloc_func(SwigClassSBMLDocument.klass, _wrap_SBMLDocument_allocate);
  rb_define_method(SwigClassSBMLDocument.klass, "initialize", VALUEFUNC(_wrap_new_SBMLDocument), -1);
  rb_define_singleton_method(SwigClassSBMLDocument.klass, "getDefaultLevel", VALUEFUNC(_wrap_SBMLDocument_getDefaultLevel), -1);
  rb_define_singleton_method(SwigClassSBMLDocument.klass, "getDefaultVersion", VALUEFUNC(_wrap_SBMLDocument_getDefaultVersion), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "clone", VALUEFUNC(_wrap_SBMLDocument_clone), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getModel", VALUEFUNC(_wrap_SBMLDocument_getModel), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "expandFunctionDefinitions", VALUEFUNC(_wrap_SBMLDocument_expandFunctionDefinitions), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "expandInitialAssignments", VALUEFUNC(_wrap_SBMLDocument_expandInitialAssignments), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "setLevelAndVersion", VALUEFUNC(_wrap_SBMLDocument_setLevelAndVersion), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "setModel", VALUEFUNC(_wrap_SBMLDocument_setModel), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "createModel", VALUEFUNC(_wrap_SBMLDocument_createModel), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "setConsistencyChecks", VALUEFUNC(_wrap_SBMLDocument_setConsistencyChecks), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "setConsistencyChecksForConversion", VALUEFUNC(_wrap_SBMLDocument_setConsistencyChecksForConversion), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkConsistency", VALUEFUNC(_wrap_SBMLDocument_checkConsistency), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkInternalConsistency", VALUEFUNC(_wrap_SBMLDocument_checkInternalConsistency), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkL1Compatibility", VALUEFUNC(_wrap_SBMLDocument_checkL1Compatibility), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkL2v1Compatibility", VALUEFUNC(_wrap_SBMLDocument_checkL2v1Compatibility), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkL2v2Compatibility", VALUEFUNC(_wrap_SBMLDocument_checkL2v2Compatibility), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkL2v3Compatibility", VALUEFUNC(_wrap_SBMLDocument_checkL2v3Compatibility), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkL2v4Compatibility", VALUEFUNC(_wrap_SBMLDocument_checkL2v4Compatibility), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "checkL3v1Compatibility", VALUEFUNC(_wrap_SBMLDocument_checkL3v1Compatibility), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getError", VALUEFUNC(_wrap_SBMLDocument_getError), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getNumErrors", VALUEFUNC(_wrap_SBMLDocument_getNumErrors), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "printErrors", VALUEFUNC(_wrap_SBMLDocument_printErrors), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "connectToChild", VALUEFUNC(_wrap_SBMLDocument_connectToChild), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "enablePackageInternal", VALUEFUNC(_wrap_SBMLDocument_enablePackageInternal), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getTypeCode", VALUEFUNC(_wrap_SBMLDocument_getTypeCode), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getElementName", VALUEFUNC(_wrap_SBMLDocument_getElementName), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getErrorLog", VALUEFUNC(_wrap_SBMLDocument_getErrorLog), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getNamespaces", VALUEFUNC(_wrap_SBMLDocument_getNamespaces), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "enableDefaultNS", VALUEFUNC(_wrap_SBMLDocument_enableDefaultNS), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "isEnabledDefaultNS", VALUEFUNC(_wrap_SBMLDocument_isEnabledDefaultNS), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "setPkgRequired", VALUEFUNC(_wrap_SBMLDocument_setPkgRequired), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "getPkgRequired", VALUEFUNC(_wrap_SBMLDocument_getPkgRequired), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "isSetPkgRequired", VALUEFUNC(_wrap_SBMLDocument_isSetPkgRequired), -1);
  rb_define_method(SwigClassSBMLDocument.klass, "isIgnoredPkg", VALUEFUNC(_wrap_SBMLDocument_isIgnoredPkg), -1);
  SwigClassSBMLDocument.mark = 0;
  SwigClassSBMLDocument.destroy = (void (*)(void *)) free_SBMLDocument;
  SwigClassSBMLDocument.trackObjects = 1;
  
  SwigClassFunctionDefinition.klass = rb_define_class_under(mLibSBML, "FunctionDefinition", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_FunctionDefinition, (void *) &SwigClassFunctionDefinition);
  rb_define_alloc_func(SwigClassFunctionDefinition.klass, _wrap_FunctionDefinition_allocate);
  rb_define_method(SwigClassFunctionDefinition.klass, "initialize", VALUEFUNC(_wrap_new_FunctionDefinition), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "clone", VALUEFUNC(_wrap_FunctionDefinition_clone), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getId", VALUEFUNC(_wrap_FunctionDefinition_getId), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getName", VALUEFUNC(_wrap_FunctionDefinition_getName), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getMath", VALUEFUNC(_wrap_FunctionDefinition_getMath), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "isSetId", VALUEFUNC(_wrap_FunctionDefinition_isSetId), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "isSetName", VALUEFUNC(_wrap_FunctionDefinition_isSetName), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "isSetMath", VALUEFUNC(_wrap_FunctionDefinition_isSetMath), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "setId", VALUEFUNC(_wrap_FunctionDefinition_setId), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "setName", VALUEFUNC(_wrap_FunctionDefinition_setName), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "setMath", VALUEFUNC(_wrap_FunctionDefinition_setMath), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "unsetName", VALUEFUNC(_wrap_FunctionDefinition_unsetName), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getArgument", VALUEFUNC(_wrap_FunctionDefinition_getArgument), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getBody", VALUEFUNC(_wrap_FunctionDefinition_getBody), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getNumArguments", VALUEFUNC(_wrap_FunctionDefinition_getNumArguments), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getTypeCode", VALUEFUNC(_wrap_FunctionDefinition_getTypeCode), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "getElementName", VALUEFUNC(_wrap_FunctionDefinition_getElementName), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_FunctionDefinition_hasRequiredAttributes), -1);
  rb_define_method(SwigClassFunctionDefinition.klass, "hasRequiredElements", VALUEFUNC(_wrap_FunctionDefinition_hasRequiredElements), -1);
  SwigClassFunctionDefinition.mark = 0;
  SwigClassFunctionDefinition.destroy = (void (*)(void *)) free_FunctionDefinition;
  SwigClassFunctionDefinition.trackObjects = 1;
  
  SwigClassListOfFunctionDefinitions.klass = rb_define_class_under(mLibSBML, "ListOfFunctionDefinitions", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfFunctionDefinitions, (void *) &SwigClassListOfFunctionDefinitions);
  rb_define_alloc_func(SwigClassListOfFunctionDefinitions.klass, _wrap_ListOfFunctionDefinitions_allocate);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "initialize", VALUEFUNC(_wrap_new_ListOfFunctionDefinitions), -1);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "clone", VALUEFUNC(_wrap_ListOfFunctionDefinitions_clone), -1);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfFunctionDefinitions_getTypeCode), -1);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfFunctionDefinitions_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "getElementName", VALUEFUNC(_wrap_ListOfFunctionDefinitions_getElementName), -1);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "get", VALUEFUNC(_wrap_ListOfFunctionDefinitions_get), -1);
  rb_define_method(SwigClassListOfFunctionDefinitions.klass, "remove", VALUEFUNC(_wrap_ListOfFunctionDefinitions_remove), -1);
  SwigClassListOfFunctionDefinitions.mark = 0;
  SwigClassListOfFunctionDefinitions.destroy = (void (*)(void *)) free_ListOfFunctionDefinitions;
  SwigClassListOfFunctionDefinitions.trackObjects = 1;
  rb_define_const(mLibSBML, "UNIT_KIND_AMPERE", SWIG_From_int(static_cast< int >(UNIT_KIND_AMPERE)));
  rb_define_const(mLibSBML, "UNIT_KIND_AVOGADRO", SWIG_From_int(static_cast< int >(UNIT_KIND_AVOGADRO)));
  rb_define_const(mLibSBML, "UNIT_KIND_BECQUEREL", SWIG_From_int(static_cast< int >(UNIT_KIND_BECQUEREL)));
  rb_define_const(mLibSBML, "UNIT_KIND_CANDELA", SWIG_From_int(static_cast< int >(UNIT_KIND_CANDELA)));
  rb_define_const(mLibSBML, "UNIT_KIND_CELSIUS", SWIG_From_int(static_cast< int >(UNIT_KIND_CELSIUS)));
  rb_define_const(mLibSBML, "UNIT_KIND_COULOMB", SWIG_From_int(static_cast< int >(UNIT_KIND_COULOMB)));
  rb_define_const(mLibSBML, "UNIT_KIND_DIMENSIONLESS", SWIG_From_int(static_cast< int >(UNIT_KIND_DIMENSIONLESS)));
  rb_define_const(mLibSBML, "UNIT_KIND_FARAD", SWIG_From_int(static_cast< int >(UNIT_KIND_FARAD)));
  rb_define_const(mLibSBML, "UNIT_KIND_GRAM", SWIG_From_int(static_cast< int >(UNIT_KIND_GRAM)));
  rb_define_const(mLibSBML, "UNIT_KIND_GRAY", SWIG_From_int(static_cast< int >(UNIT_KIND_GRAY)));
  rb_define_const(mLibSBML, "UNIT_KIND_HENRY", SWIG_From_int(static_cast< int >(UNIT_KIND_HENRY)));
  rb_define_const(mLibSBML, "UNIT_KIND_HERTZ", SWIG_From_int(static_cast< int >(UNIT_KIND_HERTZ)));
  rb_define_const(mLibSBML, "UNIT_KIND_ITEM", SWIG_From_int(static_cast< int >(UNIT_KIND_ITEM)));
  rb_define_const(mLibSBML, "UNIT_KIND_JOULE", SWIG_From_int(static_cast< int >(UNIT_KIND_JOULE)));
  rb_define_const(mLibSBML, "UNIT_KIND_KATAL", SWIG_From_int(static_cast< int >(UNIT_KIND_KATAL)));
  rb_define_const(mLibSBML, "UNIT_KIND_KELVIN", SWIG_From_int(static_cast< int >(UNIT_KIND_KELVIN)));
  rb_define_const(mLibSBML, "UNIT_KIND_KILOGRAM", SWIG_From_int(static_cast< int >(UNIT_KIND_KILOGRAM)));
  rb_define_const(mLibSBML, "UNIT_KIND_LITER", SWIG_From_int(static_cast< int >(UNIT_KIND_LITER)));
  rb_define_const(mLibSBML, "UNIT_KIND_LITRE", SWIG_From_int(static_cast< int >(UNIT_KIND_LITRE)));
  rb_define_const(mLibSBML, "UNIT_KIND_LUMEN", SWIG_From_int(static_cast< int >(UNIT_KIND_LUMEN)));
  rb_define_const(mLibSBML, "UNIT_KIND_LUX", SWIG_From_int(static_cast< int >(UNIT_KIND_LUX)));
  rb_define_const(mLibSBML, "UNIT_KIND_METER", SWIG_From_int(static_cast< int >(UNIT_KIND_METER)));
  rb_define_const(mLibSBML, "UNIT_KIND_METRE", SWIG_From_int(static_cast< int >(UNIT_KIND_METRE)));
  rb_define_const(mLibSBML, "UNIT_KIND_MOLE", SWIG_From_int(static_cast< int >(UNIT_KIND_MOLE)));
  rb_define_const(mLibSBML, "UNIT_KIND_NEWTON", SWIG_From_int(static_cast< int >(UNIT_KIND_NEWTON)));
  rb_define_const(mLibSBML, "UNIT_KIND_OHM", SWIG_From_int(static_cast< int >(UNIT_KIND_OHM)));
  rb_define_const(mLibSBML, "UNIT_KIND_PASCAL", SWIG_From_int(static_cast< int >(UNIT_KIND_PASCAL)));
  rb_define_const(mLibSBML, "UNIT_KIND_RADIAN", SWIG_From_int(static_cast< int >(UNIT_KIND_RADIAN)));
  rb_define_const(mLibSBML, "UNIT_KIND_SECOND", SWIG_From_int(static_cast< int >(UNIT_KIND_SECOND)));
  rb_define_const(mLibSBML, "UNIT_KIND_SIEMENS", SWIG_From_int(static_cast< int >(UNIT_KIND_SIEMENS)));
  rb_define_const(mLibSBML, "UNIT_KIND_SIEVERT", SWIG_From_int(static_cast< int >(UNIT_KIND_SIEVERT)));
  rb_define_const(mLibSBML, "UNIT_KIND_STERADIAN", SWIG_From_int(static_cast< int >(UNIT_KIND_STERADIAN)));
  rb_define_const(mLibSBML, "UNIT_KIND_TESLA", SWIG_From_int(static_cast< int >(UNIT_KIND_TESLA)));
  rb_define_const(mLibSBML, "UNIT_KIND_VOLT", SWIG_From_int(static_cast< int >(UNIT_KIND_VOLT)));
  rb_define_const(mLibSBML, "UNIT_KIND_WATT", SWIG_From_int(static_cast< int >(UNIT_KIND_WATT)));
  rb_define_const(mLibSBML, "UNIT_KIND_WEBER", SWIG_From_int(static_cast< int >(UNIT_KIND_WEBER)));
  rb_define_const(mLibSBML, "UNIT_KIND_INVALID", SWIG_From_int(static_cast< int >(UNIT_KIND_INVALID)));
  rb_define_module_function(mLibSBML, "UnitKind_equals", VALUEFUNC(_wrap_UnitKind_equals), -1);
  rb_define_module_function(mLibSBML, "UnitKind_forName", VALUEFUNC(_wrap_UnitKind_forName), -1);
  rb_define_module_function(mLibSBML, "UnitKind_toString", VALUEFUNC(_wrap_UnitKind_toString), -1);
  rb_define_module_function(mLibSBML, "UnitKind_isValidUnitKindString", VALUEFUNC(_wrap_UnitKind_isValidUnitKindString), -1);
  
  SwigClassUnit.klass = rb_define_class_under(mLibSBML, "Unit", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Unit, (void *) &SwigClassUnit);
  rb_define_alloc_func(SwigClassUnit.klass, _wrap_Unit_allocate);
  rb_define_method(SwigClassUnit.klass, "initialize", VALUEFUNC(_wrap_new_Unit), -1);
  rb_define_method(SwigClassUnit.klass, "clone", VALUEFUNC(_wrap_Unit_clone), -1);
  rb_define_method(SwigClassUnit.klass, "initDefaults", VALUEFUNC(_wrap_Unit_initDefaults), -1);
  rb_define_method(SwigClassUnit.klass, "getKind", VALUEFUNC(_wrap_Unit_getKind), -1);
  rb_define_method(SwigClassUnit.klass, "getExponent", VALUEFUNC(_wrap_Unit_getExponent), -1);
  rb_define_method(SwigClassUnit.klass, "getExponentAsDouble", VALUEFUNC(_wrap_Unit_getExponentAsDouble), -1);
  rb_define_method(SwigClassUnit.klass, "getScale", VALUEFUNC(_wrap_Unit_getScale), -1);
  rb_define_method(SwigClassUnit.klass, "getMultiplier", VALUEFUNC(_wrap_Unit_getMultiplier), -1);
  rb_define_method(SwigClassUnit.klass, "getOffset", VALUEFUNC(_wrap_Unit_getOffset), -1);
  rb_define_method(SwigClassUnit.klass, "isAmpere", VALUEFUNC(_wrap_Unit_isAmpere), -1);
  rb_define_method(SwigClassUnit.klass, "isAvogadro", VALUEFUNC(_wrap_Unit_isAvogadro), -1);
  rb_define_method(SwigClassUnit.klass, "isBecquerel", VALUEFUNC(_wrap_Unit_isBecquerel), -1);
  rb_define_method(SwigClassUnit.klass, "isCandela", VALUEFUNC(_wrap_Unit_isCandela), -1);
  rb_define_method(SwigClassUnit.klass, "isCelsius", VALUEFUNC(_wrap_Unit_isCelsius), -1);
  rb_define_method(SwigClassUnit.klass, "isCoulomb", VALUEFUNC(_wrap_Unit_isCoulomb), -1);
  rb_define_method(SwigClassUnit.klass, "isDimensionless", VALUEFUNC(_wrap_Unit_isDimensionless), -1);
  rb_define_method(SwigClassUnit.klass, "isFarad", VALUEFUNC(_wrap_Unit_isFarad), -1);
  rb_define_method(SwigClassUnit.klass, "isGram", VALUEFUNC(_wrap_Unit_isGram), -1);
  rb_define_method(SwigClassUnit.klass, "isGray", VALUEFUNC(_wrap_Unit_isGray), -1);
  rb_define_method(SwigClassUnit.klass, "isHenry", VALUEFUNC(_wrap_Unit_isHenry), -1);
  rb_define_method(SwigClassUnit.klass, "isHertz", VALUEFUNC(_wrap_Unit_isHertz), -1);
  rb_define_method(SwigClassUnit.klass, "isItem", VALUEFUNC(_wrap_Unit_isItem), -1);
  rb_define_method(SwigClassUnit.klass, "isJoule", VALUEFUNC(_wrap_Unit_isJoule), -1);
  rb_define_method(SwigClassUnit.klass, "isKatal", VALUEFUNC(_wrap_Unit_isKatal), -1);
  rb_define_method(SwigClassUnit.klass, "isKelvin", VALUEFUNC(_wrap_Unit_isKelvin), -1);
  rb_define_method(SwigClassUnit.klass, "isKilogram", VALUEFUNC(_wrap_Unit_isKilogram), -1);
  rb_define_method(SwigClassUnit.klass, "isLitre", VALUEFUNC(_wrap_Unit_isLitre), -1);
  rb_define_method(SwigClassUnit.klass, "isLumen", VALUEFUNC(_wrap_Unit_isLumen), -1);
  rb_define_method(SwigClassUnit.klass, "isLux", VALUEFUNC(_wrap_Unit_isLux), -1);
  rb_define_method(SwigClassUnit.klass, "isMetre", VALUEFUNC(_wrap_Unit_isMetre), -1);
  rb_define_method(SwigClassUnit.klass, "isMole", VALUEFUNC(_wrap_Unit_isMole), -1);
  rb_define_method(SwigClassUnit.klass, "isNewton", VALUEFUNC(_wrap_Unit_isNewton), -1);
  rb_define_method(SwigClassUnit.klass, "isOhm", VALUEFUNC(_wrap_Unit_isOhm), -1);
  rb_define_method(SwigClassUnit.klass, "isPascal", VALUEFUNC(_wrap_Unit_isPascal), -1);
  rb_define_method(SwigClassUnit.klass, "isRadian", VALUEFUNC(_wrap_Unit_isRadian), -1);
  rb_define_method(SwigClassUnit.klass, "isSecond", VALUEFUNC(_wrap_Unit_isSecond), -1);
  rb_define_method(SwigClassUnit.klass, "isSiemens", VALUEFUNC(_wrap_Unit_isSiemens), -1);
  rb_define_method(SwigClassUnit.klass, "isSievert", VALUEFUNC(_wrap_Unit_isSievert), -1);
  rb_define_method(SwigClassUnit.klass, "isSteradian", VALUEFUNC(_wrap_Unit_isSteradian), -1);
  rb_define_method(SwigClassUnit.klass, "isTesla", VALUEFUNC(_wrap_Unit_isTesla), -1);
  rb_define_method(SwigClassUnit.klass, "isVolt", VALUEFUNC(_wrap_Unit_isVolt), -1);
  rb_define_method(SwigClassUnit.klass, "isWatt", VALUEFUNC(_wrap_Unit_isWatt), -1);
  rb_define_method(SwigClassUnit.klass, "isWeber", VALUEFUNC(_wrap_Unit_isWeber), -1);
  rb_define_method(SwigClassUnit.klass, "isSetKind", VALUEFUNC(_wrap_Unit_isSetKind), -1);
  rb_define_method(SwigClassUnit.klass, "isSetExponent", VALUEFUNC(_wrap_Unit_isSetExponent), -1);
  rb_define_method(SwigClassUnit.klass, "isSetScale", VALUEFUNC(_wrap_Unit_isSetScale), -1);
  rb_define_method(SwigClassUnit.klass, "isSetMultiplier", VALUEFUNC(_wrap_Unit_isSetMultiplier), -1);
  rb_define_method(SwigClassUnit.klass, "setKind", VALUEFUNC(_wrap_Unit_setKind), -1);
  rb_define_method(SwigClassUnit.klass, "setExponent", VALUEFUNC(_wrap_Unit_setExponent), -1);
  rb_define_method(SwigClassUnit.klass, "setScale", VALUEFUNC(_wrap_Unit_setScale), -1);
  rb_define_method(SwigClassUnit.klass, "setMultiplier", VALUEFUNC(_wrap_Unit_setMultiplier), -1);
  rb_define_method(SwigClassUnit.klass, "setOffset", VALUEFUNC(_wrap_Unit_setOffset), -1);
  rb_define_method(SwigClassUnit.klass, "getTypeCode", VALUEFUNC(_wrap_Unit_getTypeCode), -1);
  rb_define_method(SwigClassUnit.klass, "getElementName", VALUEFUNC(_wrap_Unit_getElementName), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "isBuiltIn", VALUEFUNC(_wrap_Unit_isBuiltIn), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "isUnitKind", VALUEFUNC(_wrap_Unit_isUnitKind), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "areIdentical", VALUEFUNC(_wrap_Unit_areIdentical), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "areEquivalent", VALUEFUNC(_wrap_Unit_areEquivalent), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "removeScale", VALUEFUNC(_wrap_Unit_removeScale), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "merge", VALUEFUNC(_wrap_Unit_merge), -1);
  rb_define_singleton_method(SwigClassUnit.klass, "convertToSI", VALUEFUNC(_wrap_Unit_convertToSI), -1);
  rb_define_method(SwigClassUnit.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Unit_hasRequiredAttributes), -1);
  SwigClassUnit.mark = 0;
  SwigClassUnit.destroy = (void (*)(void *)) free_Unit;
  SwigClassUnit.trackObjects = 1;
  
  SwigClassListOfUnits.klass = rb_define_class_under(mLibSBML, "ListOfUnits", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfUnits, (void *) &SwigClassListOfUnits);
  rb_define_alloc_func(SwigClassListOfUnits.klass, _wrap_ListOfUnits_allocate);
  rb_define_method(SwigClassListOfUnits.klass, "initialize", VALUEFUNC(_wrap_new_ListOfUnits), -1);
  rb_define_method(SwigClassListOfUnits.klass, "clone", VALUEFUNC(_wrap_ListOfUnits_clone), -1);
  rb_define_method(SwigClassListOfUnits.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfUnits_getTypeCode), -1);
  rb_define_method(SwigClassListOfUnits.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfUnits_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfUnits.klass, "getElementName", VALUEFUNC(_wrap_ListOfUnits_getElementName), -1);
  rb_define_method(SwigClassListOfUnits.klass, "get", VALUEFUNC(_wrap_ListOfUnits_get), -1);
  rb_define_method(SwigClassListOfUnits.klass, "remove", VALUEFUNC(_wrap_ListOfUnits_remove), -1);
  SwigClassListOfUnits.mark = 0;
  SwigClassListOfUnits.destroy = (void (*)(void *)) free_ListOfUnits;
  SwigClassListOfUnits.trackObjects = 1;
  
  SwigClassUnitDefinition.klass = rb_define_class_under(mLibSBML, "UnitDefinition", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_UnitDefinition, (void *) &SwigClassUnitDefinition);
  rb_define_alloc_func(SwigClassUnitDefinition.klass, _wrap_UnitDefinition_allocate);
  rb_define_method(SwigClassUnitDefinition.klass, "initialize", VALUEFUNC(_wrap_new_UnitDefinition), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "clone", VALUEFUNC(_wrap_UnitDefinition_clone), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getId", VALUEFUNC(_wrap_UnitDefinition_getId), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getName", VALUEFUNC(_wrap_UnitDefinition_getName), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isSetId", VALUEFUNC(_wrap_UnitDefinition_isSetId), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isSetName", VALUEFUNC(_wrap_UnitDefinition_isSetName), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "setId", VALUEFUNC(_wrap_UnitDefinition_setId), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "setName", VALUEFUNC(_wrap_UnitDefinition_setName), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "unsetName", VALUEFUNC(_wrap_UnitDefinition_unsetName), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfArea", VALUEFUNC(_wrap_UnitDefinition_isVariantOfArea), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfLength", VALUEFUNC(_wrap_UnitDefinition_isVariantOfLength), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfSubstance", VALUEFUNC(_wrap_UnitDefinition_isVariantOfSubstance), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfTime", VALUEFUNC(_wrap_UnitDefinition_isVariantOfTime), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfVolume", VALUEFUNC(_wrap_UnitDefinition_isVariantOfVolume), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfDimensionless", VALUEFUNC(_wrap_UnitDefinition_isVariantOfDimensionless), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfMass", VALUEFUNC(_wrap_UnitDefinition_isVariantOfMass), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "isVariantOfSubstancePerTime", VALUEFUNC(_wrap_UnitDefinition_isVariantOfSubstancePerTime), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "addUnit", VALUEFUNC(_wrap_UnitDefinition_addUnit), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "createUnit", VALUEFUNC(_wrap_UnitDefinition_createUnit), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getListOfUnits", VALUEFUNC(_wrap_UnitDefinition_getListOfUnits), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getUnit", VALUEFUNC(_wrap_UnitDefinition_getUnit), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getNumUnits", VALUEFUNC(_wrap_UnitDefinition_getNumUnits), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "removeUnit", VALUEFUNC(_wrap_UnitDefinition_removeUnit), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "connectToChild", VALUEFUNC(_wrap_UnitDefinition_connectToChild), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "enablePackageInternal", VALUEFUNC(_wrap_UnitDefinition_enablePackageInternal), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getTypeCode", VALUEFUNC(_wrap_UnitDefinition_getTypeCode), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "getElementName", VALUEFUNC(_wrap_UnitDefinition_getElementName), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "simplify", VALUEFUNC(_wrap_UnitDefinition_simplify), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "reorder", VALUEFUNC(_wrap_UnitDefinition_reorder), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "convertToSI", VALUEFUNC(_wrap_UnitDefinition_convertToSI), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "areIdentical", VALUEFUNC(_wrap_UnitDefinition_areIdentical), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "areEquivalent", VALUEFUNC(_wrap_UnitDefinition_areEquivalent), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "combine", VALUEFUNC(_wrap_UnitDefinition_combine), -1);
  rb_define_singleton_method(SwigClassUnitDefinition.klass, "printUnits", VALUEFUNC(_wrap_UnitDefinition_printUnits), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_UnitDefinition_hasRequiredAttributes), -1);
  rb_define_method(SwigClassUnitDefinition.klass, "hasRequiredElements", VALUEFUNC(_wrap_UnitDefinition_hasRequiredElements), -1);
  SwigClassUnitDefinition.mark = 0;
  SwigClassUnitDefinition.destroy = (void (*)(void *)) free_UnitDefinition;
  SwigClassUnitDefinition.trackObjects = 1;
  
  SwigClassListOfUnitDefinitions.klass = rb_define_class_under(mLibSBML, "ListOfUnitDefinitions", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfUnitDefinitions, (void *) &SwigClassListOfUnitDefinitions);
  rb_define_alloc_func(SwigClassListOfUnitDefinitions.klass, _wrap_ListOfUnitDefinitions_allocate);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "initialize", VALUEFUNC(_wrap_new_ListOfUnitDefinitions), -1);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "clone", VALUEFUNC(_wrap_ListOfUnitDefinitions_clone), -1);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfUnitDefinitions_getTypeCode), -1);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfUnitDefinitions_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "getElementName", VALUEFUNC(_wrap_ListOfUnitDefinitions_getElementName), -1);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "get", VALUEFUNC(_wrap_ListOfUnitDefinitions_get), -1);
  rb_define_method(SwigClassListOfUnitDefinitions.klass, "remove", VALUEFUNC(_wrap_ListOfUnitDefinitions_remove), -1);
  SwigClassListOfUnitDefinitions.mark = 0;
  SwigClassListOfUnitDefinitions.destroy = (void (*)(void *)) free_ListOfUnitDefinitions;
  SwigClassListOfUnitDefinitions.trackObjects = 1;
  
  SwigClassCompartmentType.klass = rb_define_class_under(mLibSBML, "CompartmentType", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_CompartmentType, (void *) &SwigClassCompartmentType);
  rb_define_alloc_func(SwigClassCompartmentType.klass, _wrap_CompartmentType_allocate);
  rb_define_method(SwigClassCompartmentType.klass, "initialize", VALUEFUNC(_wrap_new_CompartmentType), -1);
  rb_define_method(SwigClassCompartmentType.klass, "clone", VALUEFUNC(_wrap_CompartmentType_clone), -1);
  rb_define_method(SwigClassCompartmentType.klass, "getId", VALUEFUNC(_wrap_CompartmentType_getId), -1);
  rb_define_method(SwigClassCompartmentType.klass, "getName", VALUEFUNC(_wrap_CompartmentType_getName), -1);
  rb_define_method(SwigClassCompartmentType.klass, "isSetId", VALUEFUNC(_wrap_CompartmentType_isSetId), -1);
  rb_define_method(SwigClassCompartmentType.klass, "isSetName", VALUEFUNC(_wrap_CompartmentType_isSetName), -1);
  rb_define_method(SwigClassCompartmentType.klass, "setId", VALUEFUNC(_wrap_CompartmentType_setId), -1);
  rb_define_method(SwigClassCompartmentType.klass, "setName", VALUEFUNC(_wrap_CompartmentType_setName), -1);
  rb_define_method(SwigClassCompartmentType.klass, "unsetName", VALUEFUNC(_wrap_CompartmentType_unsetName), -1);
  rb_define_method(SwigClassCompartmentType.klass, "getTypeCode", VALUEFUNC(_wrap_CompartmentType_getTypeCode), -1);
  rb_define_method(SwigClassCompartmentType.klass, "getElementName", VALUEFUNC(_wrap_CompartmentType_getElementName), -1);
  rb_define_method(SwigClassCompartmentType.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_CompartmentType_hasRequiredAttributes), -1);
  SwigClassCompartmentType.mark = 0;
  SwigClassCompartmentType.destroy = (void (*)(void *)) free_CompartmentType;
  SwigClassCompartmentType.trackObjects = 1;
  
  SwigClassListOfCompartmentTypes.klass = rb_define_class_under(mLibSBML, "ListOfCompartmentTypes", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfCompartmentTypes, (void *) &SwigClassListOfCompartmentTypes);
  rb_define_alloc_func(SwigClassListOfCompartmentTypes.klass, _wrap_ListOfCompartmentTypes_allocate);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "initialize", VALUEFUNC(_wrap_new_ListOfCompartmentTypes), -1);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "clone", VALUEFUNC(_wrap_ListOfCompartmentTypes_clone), -1);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfCompartmentTypes_getTypeCode), -1);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfCompartmentTypes_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "getElementName", VALUEFUNC(_wrap_ListOfCompartmentTypes_getElementName), -1);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "get", VALUEFUNC(_wrap_ListOfCompartmentTypes_get), -1);
  rb_define_method(SwigClassListOfCompartmentTypes.klass, "remove", VALUEFUNC(_wrap_ListOfCompartmentTypes_remove), -1);
  SwigClassListOfCompartmentTypes.mark = 0;
  SwigClassListOfCompartmentTypes.destroy = (void (*)(void *)) free_ListOfCompartmentTypes;
  SwigClassListOfCompartmentTypes.trackObjects = 1;
  
  SwigClassSpeciesType.klass = rb_define_class_under(mLibSBML, "SpeciesType", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SpeciesType, (void *) &SwigClassSpeciesType);
  rb_define_alloc_func(SwigClassSpeciesType.klass, _wrap_SpeciesType_allocate);
  rb_define_method(SwigClassSpeciesType.klass, "initialize", VALUEFUNC(_wrap_new_SpeciesType), -1);
  rb_define_method(SwigClassSpeciesType.klass, "clone", VALUEFUNC(_wrap_SpeciesType_clone), -1);
  rb_define_method(SwigClassSpeciesType.klass, "getId", VALUEFUNC(_wrap_SpeciesType_getId), -1);
  rb_define_method(SwigClassSpeciesType.klass, "getName", VALUEFUNC(_wrap_SpeciesType_getName), -1);
  rb_define_method(SwigClassSpeciesType.klass, "isSetId", VALUEFUNC(_wrap_SpeciesType_isSetId), -1);
  rb_define_method(SwigClassSpeciesType.klass, "isSetName", VALUEFUNC(_wrap_SpeciesType_isSetName), -1);
  rb_define_method(SwigClassSpeciesType.klass, "setId", VALUEFUNC(_wrap_SpeciesType_setId), -1);
  rb_define_method(SwigClassSpeciesType.klass, "setName", VALUEFUNC(_wrap_SpeciesType_setName), -1);
  rb_define_method(SwigClassSpeciesType.klass, "unsetName", VALUEFUNC(_wrap_SpeciesType_unsetName), -1);
  rb_define_method(SwigClassSpeciesType.klass, "getTypeCode", VALUEFUNC(_wrap_SpeciesType_getTypeCode), -1);
  rb_define_method(SwigClassSpeciesType.klass, "getElementName", VALUEFUNC(_wrap_SpeciesType_getElementName), -1);
  rb_define_method(SwigClassSpeciesType.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_SpeciesType_hasRequiredAttributes), -1);
  SwigClassSpeciesType.mark = 0;
  SwigClassSpeciesType.destroy = (void (*)(void *)) free_SpeciesType;
  SwigClassSpeciesType.trackObjects = 1;
  
  SwigClassListOfSpeciesTypes.klass = rb_define_class_under(mLibSBML, "ListOfSpeciesTypes", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfSpeciesTypes, (void *) &SwigClassListOfSpeciesTypes);
  rb_define_alloc_func(SwigClassListOfSpeciesTypes.klass, _wrap_ListOfSpeciesTypes_allocate);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "initialize", VALUEFUNC(_wrap_new_ListOfSpeciesTypes), -1);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "clone", VALUEFUNC(_wrap_ListOfSpeciesTypes_clone), -1);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfSpeciesTypes_getTypeCode), -1);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfSpeciesTypes_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "getElementName", VALUEFUNC(_wrap_ListOfSpeciesTypes_getElementName), -1);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "get", VALUEFUNC(_wrap_ListOfSpeciesTypes_get), -1);
  rb_define_method(SwigClassListOfSpeciesTypes.klass, "remove", VALUEFUNC(_wrap_ListOfSpeciesTypes_remove), -1);
  SwigClassListOfSpeciesTypes.mark = 0;
  SwigClassListOfSpeciesTypes.destroy = (void (*)(void *)) free_ListOfSpeciesTypes;
  SwigClassListOfSpeciesTypes.trackObjects = 1;
  
  SwigClassCompartment.klass = rb_define_class_under(mLibSBML, "Compartment", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Compartment, (void *) &SwigClassCompartment);
  rb_define_alloc_func(SwigClassCompartment.klass, _wrap_Compartment_allocate);
  rb_define_method(SwigClassCompartment.klass, "initialize", VALUEFUNC(_wrap_new_Compartment), -1);
  rb_define_method(SwigClassCompartment.klass, "clone", VALUEFUNC(_wrap_Compartment_clone), -1);
  rb_define_method(SwigClassCompartment.klass, "initDefaults", VALUEFUNC(_wrap_Compartment_initDefaults), -1);
  rb_define_method(SwigClassCompartment.klass, "getId", VALUEFUNC(_wrap_Compartment_getId), -1);
  rb_define_method(SwigClassCompartment.klass, "getName", VALUEFUNC(_wrap_Compartment_getName), -1);
  rb_define_method(SwigClassCompartment.klass, "getCompartmentType", VALUEFUNC(_wrap_Compartment_getCompartmentType), -1);
  rb_define_method(SwigClassCompartment.klass, "getSpatialDimensions", VALUEFUNC(_wrap_Compartment_getSpatialDimensions), -1);
  rb_define_method(SwigClassCompartment.klass, "getSpatialDimensionsAsDouble", VALUEFUNC(_wrap_Compartment_getSpatialDimensionsAsDouble), -1);
  rb_define_method(SwigClassCompartment.klass, "getSize", VALUEFUNC(_wrap_Compartment_getSize), -1);
  rb_define_method(SwigClassCompartment.klass, "getVolume", VALUEFUNC(_wrap_Compartment_getVolume), -1);
  rb_define_method(SwigClassCompartment.klass, "getUnits", VALUEFUNC(_wrap_Compartment_getUnits), -1);
  rb_define_method(SwigClassCompartment.klass, "getOutside", VALUEFUNC(_wrap_Compartment_getOutside), -1);
  rb_define_method(SwigClassCompartment.klass, "getConstant", VALUEFUNC(_wrap_Compartment_getConstant), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetId", VALUEFUNC(_wrap_Compartment_isSetId), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetName", VALUEFUNC(_wrap_Compartment_isSetName), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetCompartmentType", VALUEFUNC(_wrap_Compartment_isSetCompartmentType), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetSize", VALUEFUNC(_wrap_Compartment_isSetSize), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetVolume", VALUEFUNC(_wrap_Compartment_isSetVolume), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetUnits", VALUEFUNC(_wrap_Compartment_isSetUnits), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetOutside", VALUEFUNC(_wrap_Compartment_isSetOutside), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetSpatialDimensions", VALUEFUNC(_wrap_Compartment_isSetSpatialDimensions), -1);
  rb_define_method(SwigClassCompartment.klass, "isSetConstant", VALUEFUNC(_wrap_Compartment_isSetConstant), -1);
  rb_define_method(SwigClassCompartment.klass, "setId", VALUEFUNC(_wrap_Compartment_setId), -1);
  rb_define_method(SwigClassCompartment.klass, "setName", VALUEFUNC(_wrap_Compartment_setName), -1);
  rb_define_method(SwigClassCompartment.klass, "setCompartmentType", VALUEFUNC(_wrap_Compartment_setCompartmentType), -1);
  rb_define_method(SwigClassCompartment.klass, "setSpatialDimensions", VALUEFUNC(_wrap_Compartment_setSpatialDimensions), -1);
  rb_define_method(SwigClassCompartment.klass, "setSize", VALUEFUNC(_wrap_Compartment_setSize), -1);
  rb_define_method(SwigClassCompartment.klass, "setVolume", VALUEFUNC(_wrap_Compartment_setVolume), -1);
  rb_define_method(SwigClassCompartment.klass, "setUnits", VALUEFUNC(_wrap_Compartment_setUnits), -1);
  rb_define_method(SwigClassCompartment.klass, "setOutside", VALUEFUNC(_wrap_Compartment_setOutside), -1);
  rb_define_method(SwigClassCompartment.klass, "setConstant", VALUEFUNC(_wrap_Compartment_setConstant), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetName", VALUEFUNC(_wrap_Compartment_unsetName), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetCompartmentType", VALUEFUNC(_wrap_Compartment_unsetCompartmentType), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetSize", VALUEFUNC(_wrap_Compartment_unsetSize), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetVolume", VALUEFUNC(_wrap_Compartment_unsetVolume), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetUnits", VALUEFUNC(_wrap_Compartment_unsetUnits), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetOutside", VALUEFUNC(_wrap_Compartment_unsetOutside), -1);
  rb_define_method(SwigClassCompartment.klass, "unsetSpatialDimensions", VALUEFUNC(_wrap_Compartment_unsetSpatialDimensions), -1);
  rb_define_method(SwigClassCompartment.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_Compartment_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassCompartment.klass, "getTypeCode", VALUEFUNC(_wrap_Compartment_getTypeCode), -1);
  rb_define_method(SwigClassCompartment.klass, "getElementName", VALUEFUNC(_wrap_Compartment_getElementName), -1);
  rb_define_method(SwigClassCompartment.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Compartment_hasRequiredAttributes), -1);
  SwigClassCompartment.mark = 0;
  SwigClassCompartment.destroy = (void (*)(void *)) free_Compartment;
  SwigClassCompartment.trackObjects = 1;
  
  SwigClassListOfCompartments.klass = rb_define_class_under(mLibSBML, "ListOfCompartments", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfCompartments, (void *) &SwigClassListOfCompartments);
  rb_define_alloc_func(SwigClassListOfCompartments.klass, _wrap_ListOfCompartments_allocate);
  rb_define_method(SwigClassListOfCompartments.klass, "initialize", VALUEFUNC(_wrap_new_ListOfCompartments), -1);
  rb_define_method(SwigClassListOfCompartments.klass, "clone", VALUEFUNC(_wrap_ListOfCompartments_clone), -1);
  rb_define_method(SwigClassListOfCompartments.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfCompartments_getTypeCode), -1);
  rb_define_method(SwigClassListOfCompartments.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfCompartments_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfCompartments.klass, "getElementName", VALUEFUNC(_wrap_ListOfCompartments_getElementName), -1);
  rb_define_method(SwigClassListOfCompartments.klass, "get", VALUEFUNC(_wrap_ListOfCompartments_get), -1);
  rb_define_method(SwigClassListOfCompartments.klass, "remove", VALUEFUNC(_wrap_ListOfCompartments_remove), -1);
  SwigClassListOfCompartments.mark = 0;
  SwigClassListOfCompartments.destroy = (void (*)(void *)) free_ListOfCompartments;
  SwigClassListOfCompartments.trackObjects = 1;
  
  SwigClassSpecies.klass = rb_define_class_under(mLibSBML, "Species", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Species, (void *) &SwigClassSpecies);
  rb_define_alloc_func(SwigClassSpecies.klass, _wrap_Species_allocate);
  rb_define_method(SwigClassSpecies.klass, "initialize", VALUEFUNC(_wrap_new_Species), -1);
  rb_define_method(SwigClassSpecies.klass, "clone", VALUEFUNC(_wrap_Species_clone), -1);
  rb_define_method(SwigClassSpecies.klass, "initDefaults", VALUEFUNC(_wrap_Species_initDefaults), -1);
  rb_define_method(SwigClassSpecies.klass, "getId", VALUEFUNC(_wrap_Species_getId), -1);
  rb_define_method(SwigClassSpecies.klass, "getName", VALUEFUNC(_wrap_Species_getName), -1);
  rb_define_method(SwigClassSpecies.klass, "getSpeciesType", VALUEFUNC(_wrap_Species_getSpeciesType), -1);
  rb_define_method(SwigClassSpecies.klass, "getCompartment", VALUEFUNC(_wrap_Species_getCompartment), -1);
  rb_define_method(SwigClassSpecies.klass, "getInitialAmount", VALUEFUNC(_wrap_Species_getInitialAmount), -1);
  rb_define_method(SwigClassSpecies.klass, "getInitialConcentration", VALUEFUNC(_wrap_Species_getInitialConcentration), -1);
  rb_define_method(SwigClassSpecies.klass, "getSubstanceUnits", VALUEFUNC(_wrap_Species_getSubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "getSpatialSizeUnits", VALUEFUNC(_wrap_Species_getSpatialSizeUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "getUnits", VALUEFUNC(_wrap_Species_getUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "getHasOnlySubstanceUnits", VALUEFUNC(_wrap_Species_getHasOnlySubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "getBoundaryCondition", VALUEFUNC(_wrap_Species_getBoundaryCondition), -1);
  rb_define_method(SwigClassSpecies.klass, "getCharge", VALUEFUNC(_wrap_Species_getCharge), -1);
  rb_define_method(SwigClassSpecies.klass, "getConstant", VALUEFUNC(_wrap_Species_getConstant), -1);
  rb_define_method(SwigClassSpecies.klass, "getConversionFactor", VALUEFUNC(_wrap_Species_getConversionFactor), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetId", VALUEFUNC(_wrap_Species_isSetId), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetName", VALUEFUNC(_wrap_Species_isSetName), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetSpeciesType", VALUEFUNC(_wrap_Species_isSetSpeciesType), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetCompartment", VALUEFUNC(_wrap_Species_isSetCompartment), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetInitialAmount", VALUEFUNC(_wrap_Species_isSetInitialAmount), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetInitialConcentration", VALUEFUNC(_wrap_Species_isSetInitialConcentration), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetSubstanceUnits", VALUEFUNC(_wrap_Species_isSetSubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetSpatialSizeUnits", VALUEFUNC(_wrap_Species_isSetSpatialSizeUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetUnits", VALUEFUNC(_wrap_Species_isSetUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetCharge", VALUEFUNC(_wrap_Species_isSetCharge), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetConversionFactor", VALUEFUNC(_wrap_Species_isSetConversionFactor), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetBoundaryCondition", VALUEFUNC(_wrap_Species_isSetBoundaryCondition), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetHasOnlySubstanceUnits", VALUEFUNC(_wrap_Species_isSetHasOnlySubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "isSetConstant", VALUEFUNC(_wrap_Species_isSetConstant), -1);
  rb_define_method(SwigClassSpecies.klass, "setId", VALUEFUNC(_wrap_Species_setId), -1);
  rb_define_method(SwigClassSpecies.klass, "setName", VALUEFUNC(_wrap_Species_setName), -1);
  rb_define_method(SwigClassSpecies.klass, "setSpeciesType", VALUEFUNC(_wrap_Species_setSpeciesType), -1);
  rb_define_method(SwigClassSpecies.klass, "setCompartment", VALUEFUNC(_wrap_Species_setCompartment), -1);
  rb_define_method(SwigClassSpecies.klass, "setInitialAmount", VALUEFUNC(_wrap_Species_setInitialAmount), -1);
  rb_define_method(SwigClassSpecies.klass, "setInitialConcentration", VALUEFUNC(_wrap_Species_setInitialConcentration), -1);
  rb_define_method(SwigClassSpecies.klass, "setSubstanceUnits", VALUEFUNC(_wrap_Species_setSubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "setSpatialSizeUnits", VALUEFUNC(_wrap_Species_setSpatialSizeUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "setUnits", VALUEFUNC(_wrap_Species_setUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "setHasOnlySubstanceUnits", VALUEFUNC(_wrap_Species_setHasOnlySubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "setBoundaryCondition", VALUEFUNC(_wrap_Species_setBoundaryCondition), -1);
  rb_define_method(SwigClassSpecies.klass, "setCharge", VALUEFUNC(_wrap_Species_setCharge), -1);
  rb_define_method(SwigClassSpecies.klass, "setConstant", VALUEFUNC(_wrap_Species_setConstant), -1);
  rb_define_method(SwigClassSpecies.klass, "setConversionFactor", VALUEFUNC(_wrap_Species_setConversionFactor), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetName", VALUEFUNC(_wrap_Species_unsetName), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetSpeciesType", VALUEFUNC(_wrap_Species_unsetSpeciesType), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetInitialAmount", VALUEFUNC(_wrap_Species_unsetInitialAmount), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetInitialConcentration", VALUEFUNC(_wrap_Species_unsetInitialConcentration), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetSubstanceUnits", VALUEFUNC(_wrap_Species_unsetSubstanceUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetSpatialSizeUnits", VALUEFUNC(_wrap_Species_unsetSpatialSizeUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetUnits", VALUEFUNC(_wrap_Species_unsetUnits), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetCharge", VALUEFUNC(_wrap_Species_unsetCharge), -1);
  rb_define_method(SwigClassSpecies.klass, "unsetConversionFactor", VALUEFUNC(_wrap_Species_unsetConversionFactor), -1);
  rb_define_method(SwigClassSpecies.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_Species_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassSpecies.klass, "getTypeCode", VALUEFUNC(_wrap_Species_getTypeCode), -1);
  rb_define_method(SwigClassSpecies.klass, "getElementName", VALUEFUNC(_wrap_Species_getElementName), -1);
  rb_define_method(SwigClassSpecies.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Species_hasRequiredAttributes), -1);
  SwigClassSpecies.mark = 0;
  SwigClassSpecies.destroy = (void (*)(void *)) free_Species;
  SwigClassSpecies.trackObjects = 1;
  
  SwigClassListOfSpecies.klass = rb_define_class_under(mLibSBML, "ListOfSpecies", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfSpecies, (void *) &SwigClassListOfSpecies);
  rb_define_alloc_func(SwigClassListOfSpecies.klass, _wrap_ListOfSpecies_allocate);
  rb_define_method(SwigClassListOfSpecies.klass, "initialize", VALUEFUNC(_wrap_new_ListOfSpecies), -1);
  rb_define_method(SwigClassListOfSpecies.klass, "clone", VALUEFUNC(_wrap_ListOfSpecies_clone), -1);
  rb_define_method(SwigClassListOfSpecies.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfSpecies_getTypeCode), -1);
  rb_define_method(SwigClassListOfSpecies.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfSpecies_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfSpecies.klass, "getElementName", VALUEFUNC(_wrap_ListOfSpecies_getElementName), -1);
  rb_define_method(SwigClassListOfSpecies.klass, "get", VALUEFUNC(_wrap_ListOfSpecies_get), -1);
  rb_define_method(SwigClassListOfSpecies.klass, "remove", VALUEFUNC(_wrap_ListOfSpecies_remove), -1);
  SwigClassListOfSpecies.mark = 0;
  SwigClassListOfSpecies.destroy = (void (*)(void *)) free_ListOfSpecies;
  SwigClassListOfSpecies.trackObjects = 1;
  
  SwigClassParameter.klass = rb_define_class_under(mLibSBML, "Parameter", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Parameter, (void *) &SwigClassParameter);
  rb_define_alloc_func(SwigClassParameter.klass, _wrap_Parameter_allocate);
  rb_define_method(SwigClassParameter.klass, "initialize", VALUEFUNC(_wrap_new_Parameter), -1);
  rb_define_method(SwigClassParameter.klass, "clone", VALUEFUNC(_wrap_Parameter_clone), -1);
  rb_define_method(SwigClassParameter.klass, "initDefaults", VALUEFUNC(_wrap_Parameter_initDefaults), -1);
  rb_define_method(SwigClassParameter.klass, "getId", VALUEFUNC(_wrap_Parameter_getId), -1);
  rb_define_method(SwigClassParameter.klass, "getName", VALUEFUNC(_wrap_Parameter_getName), -1);
  rb_define_method(SwigClassParameter.klass, "getValue", VALUEFUNC(_wrap_Parameter_getValue), -1);
  rb_define_method(SwigClassParameter.klass, "getUnits", VALUEFUNC(_wrap_Parameter_getUnits), -1);
  rb_define_method(SwigClassParameter.klass, "getConstant", VALUEFUNC(_wrap_Parameter_getConstant), -1);
  rb_define_method(SwigClassParameter.klass, "isSetId", VALUEFUNC(_wrap_Parameter_isSetId), -1);
  rb_define_method(SwigClassParameter.klass, "isSetName", VALUEFUNC(_wrap_Parameter_isSetName), -1);
  rb_define_method(SwigClassParameter.klass, "isSetValue", VALUEFUNC(_wrap_Parameter_isSetValue), -1);
  rb_define_method(SwigClassParameter.klass, "isSetUnits", VALUEFUNC(_wrap_Parameter_isSetUnits), -1);
  rb_define_method(SwigClassParameter.klass, "isSetConstant", VALUEFUNC(_wrap_Parameter_isSetConstant), -1);
  rb_define_method(SwigClassParameter.klass, "setId", VALUEFUNC(_wrap_Parameter_setId), -1);
  rb_define_method(SwigClassParameter.klass, "setName", VALUEFUNC(_wrap_Parameter_setName), -1);
  rb_define_method(SwigClassParameter.klass, "setValue", VALUEFUNC(_wrap_Parameter_setValue), -1);
  rb_define_method(SwigClassParameter.klass, "setUnits", VALUEFUNC(_wrap_Parameter_setUnits), -1);
  rb_define_method(SwigClassParameter.klass, "setConstant", VALUEFUNC(_wrap_Parameter_setConstant), -1);
  rb_define_method(SwigClassParameter.klass, "unsetName", VALUEFUNC(_wrap_Parameter_unsetName), -1);
  rb_define_method(SwigClassParameter.klass, "unsetValue", VALUEFUNC(_wrap_Parameter_unsetValue), -1);
  rb_define_method(SwigClassParameter.klass, "unsetUnits", VALUEFUNC(_wrap_Parameter_unsetUnits), -1);
  rb_define_method(SwigClassParameter.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_Parameter_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassParameter.klass, "getTypeCode", VALUEFUNC(_wrap_Parameter_getTypeCode), -1);
  rb_define_method(SwigClassParameter.klass, "getElementName", VALUEFUNC(_wrap_Parameter_getElementName), -1);
  rb_define_method(SwigClassParameter.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Parameter_hasRequiredAttributes), -1);
  SwigClassParameter.mark = 0;
  SwigClassParameter.destroy = (void (*)(void *)) free_Parameter;
  SwigClassParameter.trackObjects = 1;
  
  SwigClassListOfParameters.klass = rb_define_class_under(mLibSBML, "ListOfParameters", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfParameters, (void *) &SwigClassListOfParameters);
  rb_define_alloc_func(SwigClassListOfParameters.klass, _wrap_ListOfParameters_allocate);
  rb_define_method(SwigClassListOfParameters.klass, "initialize", VALUEFUNC(_wrap_new_ListOfParameters), -1);
  rb_define_method(SwigClassListOfParameters.klass, "clone", VALUEFUNC(_wrap_ListOfParameters_clone), -1);
  rb_define_method(SwigClassListOfParameters.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfParameters_getTypeCode), -1);
  rb_define_method(SwigClassListOfParameters.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfParameters_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfParameters.klass, "getElementName", VALUEFUNC(_wrap_ListOfParameters_getElementName), -1);
  rb_define_method(SwigClassListOfParameters.klass, "get", VALUEFUNC(_wrap_ListOfParameters_get), -1);
  rb_define_method(SwigClassListOfParameters.klass, "remove", VALUEFUNC(_wrap_ListOfParameters_remove), -1);
  SwigClassListOfParameters.mark = 0;
  SwigClassListOfParameters.destroy = (void (*)(void *)) free_ListOfParameters;
  SwigClassListOfParameters.trackObjects = 1;
  
  SwigClassLocalParameter.klass = rb_define_class_under(mLibSBML, "LocalParameter", ((swig_class *) SWIGTYPE_p_Parameter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_LocalParameter, (void *) &SwigClassLocalParameter);
  rb_define_alloc_func(SwigClassLocalParameter.klass, _wrap_LocalParameter_allocate);
  rb_define_method(SwigClassLocalParameter.klass, "initialize", VALUEFUNC(_wrap_new_LocalParameter), -1);
  rb_define_method(SwigClassLocalParameter.klass, "clone", VALUEFUNC(_wrap_LocalParameter_clone), -1);
  rb_define_method(SwigClassLocalParameter.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_LocalParameter_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassLocalParameter.klass, "getTypeCode", VALUEFUNC(_wrap_LocalParameter_getTypeCode), -1);
  rb_define_method(SwigClassLocalParameter.klass, "getElementName", VALUEFUNC(_wrap_LocalParameter_getElementName), -1);
  rb_define_method(SwigClassLocalParameter.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_LocalParameter_hasRequiredAttributes), -1);
  SwigClassLocalParameter.mark = 0;
  SwigClassLocalParameter.destroy = (void (*)(void *)) free_LocalParameter;
  SwigClassLocalParameter.trackObjects = 1;
  
  SwigClassListOfLocalParameters.klass = rb_define_class_under(mLibSBML, "ListOfLocalParameters", ((swig_class *) SWIGTYPE_p_ListOfParameters->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfLocalParameters, (void *) &SwigClassListOfLocalParameters);
  rb_define_alloc_func(SwigClassListOfLocalParameters.klass, _wrap_ListOfLocalParameters_allocate);
  rb_define_method(SwigClassListOfLocalParameters.klass, "initialize", VALUEFUNC(_wrap_new_ListOfLocalParameters), -1);
  rb_define_method(SwigClassListOfLocalParameters.klass, "clone", VALUEFUNC(_wrap_ListOfLocalParameters_clone), -1);
  rb_define_method(SwigClassListOfLocalParameters.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfLocalParameters_getTypeCode), -1);
  rb_define_method(SwigClassListOfLocalParameters.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfLocalParameters_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfLocalParameters.klass, "getElementName", VALUEFUNC(_wrap_ListOfLocalParameters_getElementName), -1);
  rb_define_method(SwigClassListOfLocalParameters.klass, "get", VALUEFUNC(_wrap_ListOfLocalParameters_get), -1);
  rb_define_method(SwigClassListOfLocalParameters.klass, "remove", VALUEFUNC(_wrap_ListOfLocalParameters_remove), -1);
  SwigClassListOfLocalParameters.mark = 0;
  SwigClassListOfLocalParameters.destroy = (void (*)(void *)) free_ListOfLocalParameters;
  SwigClassListOfLocalParameters.trackObjects = 1;
  
  SwigClassInitialAssignment.klass = rb_define_class_under(mLibSBML, "InitialAssignment", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_InitialAssignment, (void *) &SwigClassInitialAssignment);
  rb_define_alloc_func(SwigClassInitialAssignment.klass, _wrap_InitialAssignment_allocate);
  rb_define_method(SwigClassInitialAssignment.klass, "initialize", VALUEFUNC(_wrap_new_InitialAssignment), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "clone", VALUEFUNC(_wrap_InitialAssignment_clone), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "getSymbol", VALUEFUNC(_wrap_InitialAssignment_getSymbol), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "getMath", VALUEFUNC(_wrap_InitialAssignment_getMath), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "isSetSymbol", VALUEFUNC(_wrap_InitialAssignment_isSetSymbol), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "isSetMath", VALUEFUNC(_wrap_InitialAssignment_isSetMath), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "setSymbol", VALUEFUNC(_wrap_InitialAssignment_setSymbol), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "setMath", VALUEFUNC(_wrap_InitialAssignment_setMath), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_InitialAssignment_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "containsUndeclaredUnits", VALUEFUNC(_wrap_InitialAssignment_containsUndeclaredUnits), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "getTypeCode", VALUEFUNC(_wrap_InitialAssignment_getTypeCode), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "getElementName", VALUEFUNC(_wrap_InitialAssignment_getElementName), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_InitialAssignment_hasRequiredAttributes), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "hasRequiredElements", VALUEFUNC(_wrap_InitialAssignment_hasRequiredElements), -1);
  rb_define_method(SwigClassInitialAssignment.klass, "getId", VALUEFUNC(_wrap_InitialAssignment_getId), -1);
  SwigClassInitialAssignment.mark = 0;
  SwigClassInitialAssignment.destroy = (void (*)(void *)) free_InitialAssignment;
  SwigClassInitialAssignment.trackObjects = 1;
  
  SwigClassListOfInitialAssignments.klass = rb_define_class_under(mLibSBML, "ListOfInitialAssignments", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfInitialAssignments, (void *) &SwigClassListOfInitialAssignments);
  rb_define_alloc_func(SwigClassListOfInitialAssignments.klass, _wrap_ListOfInitialAssignments_allocate);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "initialize", VALUEFUNC(_wrap_new_ListOfInitialAssignments), -1);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "clone", VALUEFUNC(_wrap_ListOfInitialAssignments_clone), -1);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfInitialAssignments_getTypeCode), -1);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfInitialAssignments_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "getElementName", VALUEFUNC(_wrap_ListOfInitialAssignments_getElementName), -1);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "get", VALUEFUNC(_wrap_ListOfInitialAssignments_get), -1);
  rb_define_method(SwigClassListOfInitialAssignments.klass, "remove", VALUEFUNC(_wrap_ListOfInitialAssignments_remove), -1);
  SwigClassListOfInitialAssignments.mark = 0;
  SwigClassListOfInitialAssignments.destroy = (void (*)(void *)) free_ListOfInitialAssignments;
  SwigClassListOfInitialAssignments.trackObjects = 1;
  rb_define_const(mLibSBML, "RULE_TYPE_RATE", SWIG_From_int(static_cast< int >(RULE_TYPE_RATE)));
  rb_define_const(mLibSBML, "RULE_TYPE_SCALAR", SWIG_From_int(static_cast< int >(RULE_TYPE_SCALAR)));
  rb_define_const(mLibSBML, "RULE_TYPE_INVALID", SWIG_From_int(static_cast< int >(RULE_TYPE_INVALID)));
  
  SwigClassRule.klass = rb_define_class_under(mLibSBML, "Rule", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Rule, (void *) &SwigClassRule);
  rb_define_alloc_func(SwigClassRule.klass, _wrap_Rule_allocate);
  rb_define_method(SwigClassRule.klass, "initialize", VALUEFUNC(_wrap_new_Rule), -1);
  rb_define_method(SwigClassRule.klass, "clone", VALUEFUNC(_wrap_Rule_clone), -1);
  rb_define_method(SwigClassRule.klass, "getFormula", VALUEFUNC(_wrap_Rule_getFormula), -1);
  rb_define_method(SwigClassRule.klass, "getMath", VALUEFUNC(_wrap_Rule_getMath), -1);
  rb_define_method(SwigClassRule.klass, "getVariable", VALUEFUNC(_wrap_Rule_getVariable), -1);
  rb_define_method(SwigClassRule.klass, "getUnits", VALUEFUNC(_wrap_Rule_getUnits), -1);
  rb_define_method(SwigClassRule.klass, "isSetFormula", VALUEFUNC(_wrap_Rule_isSetFormula), -1);
  rb_define_method(SwigClassRule.klass, "isSetMath", VALUEFUNC(_wrap_Rule_isSetMath), -1);
  rb_define_method(SwigClassRule.klass, "isSetVariable", VALUEFUNC(_wrap_Rule_isSetVariable), -1);
  rb_define_method(SwigClassRule.klass, "isSetUnits", VALUEFUNC(_wrap_Rule_isSetUnits), -1);
  rb_define_method(SwigClassRule.klass, "setFormula", VALUEFUNC(_wrap_Rule_setFormula), -1);
  rb_define_method(SwigClassRule.klass, "setMath", VALUEFUNC(_wrap_Rule_setMath), -1);
  rb_define_method(SwigClassRule.klass, "setVariable", VALUEFUNC(_wrap_Rule_setVariable), -1);
  rb_define_method(SwigClassRule.klass, "setUnits", VALUEFUNC(_wrap_Rule_setUnits), -1);
  rb_define_method(SwigClassRule.klass, "unsetUnits", VALUEFUNC(_wrap_Rule_unsetUnits), -1);
  rb_define_method(SwigClassRule.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_Rule_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassRule.klass, "containsUndeclaredUnits", VALUEFUNC(_wrap_Rule_containsUndeclaredUnits), -1);
  rb_define_method(SwigClassRule.klass, "getType", VALUEFUNC(_wrap_Rule_getType), -1);
  rb_define_method(SwigClassRule.klass, "isAlgebraic", VALUEFUNC(_wrap_Rule_isAlgebraic), -1);
  rb_define_method(SwigClassRule.klass, "isAssignment", VALUEFUNC(_wrap_Rule_isAssignment), -1);
  rb_define_method(SwigClassRule.klass, "isCompartmentVolume", VALUEFUNC(_wrap_Rule_isCompartmentVolume), -1);
  rb_define_method(SwigClassRule.klass, "isParameter", VALUEFUNC(_wrap_Rule_isParameter), -1);
  rb_define_method(SwigClassRule.klass, "isRate", VALUEFUNC(_wrap_Rule_isRate), -1);
  rb_define_method(SwigClassRule.klass, "isScalar", VALUEFUNC(_wrap_Rule_isScalar), -1);
  rb_define_method(SwigClassRule.klass, "isSpeciesConcentration", VALUEFUNC(_wrap_Rule_isSpeciesConcentration), -1);
  rb_define_method(SwigClassRule.klass, "getTypeCode", VALUEFUNC(_wrap_Rule_getTypeCode), -1);
  rb_define_method(SwigClassRule.klass, "getL1TypeCode", VALUEFUNC(_wrap_Rule_getL1TypeCode), -1);
  rb_define_method(SwigClassRule.klass, "getElementName", VALUEFUNC(_wrap_Rule_getElementName), -1);
  rb_define_method(SwigClassRule.klass, "setL1TypeCode", VALUEFUNC(_wrap_Rule_setL1TypeCode), -1);
  rb_define_method(SwigClassRule.klass, "hasRequiredElements", VALUEFUNC(_wrap_Rule_hasRequiredElements), -1);
  rb_define_method(SwigClassRule.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Rule_hasRequiredAttributes), -1);
  rb_define_method(SwigClassRule.klass, "getId", VALUEFUNC(_wrap_Rule_getId), -1);
  SwigClassRule.mark = 0;
  SwigClassRule.destroy = (void (*)(void *)) free_Rule;
  SwigClassRule.trackObjects = 1;
  
  SwigClassAlgebraicRule.klass = rb_define_class_under(mLibSBML, "AlgebraicRule", ((swig_class *) SWIGTYPE_p_Rule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_AlgebraicRule, (void *) &SwigClassAlgebraicRule);
  rb_define_alloc_func(SwigClassAlgebraicRule.klass, _wrap_AlgebraicRule_allocate);
  rb_define_method(SwigClassAlgebraicRule.klass, "initialize", VALUEFUNC(_wrap_new_AlgebraicRule), -1);
  rb_define_method(SwigClassAlgebraicRule.klass, "clone", VALUEFUNC(_wrap_AlgebraicRule_clone), -1);
  rb_define_method(SwigClassAlgebraicRule.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_AlgebraicRule_hasRequiredAttributes), -1);
  SwigClassAlgebraicRule.mark = 0;
  SwigClassAlgebraicRule.destroy = (void (*)(void *)) free_AlgebraicRule;
  SwigClassAlgebraicRule.trackObjects = 1;
  
  SwigClassAssignmentRule.klass = rb_define_class_under(mLibSBML, "AssignmentRule", ((swig_class *) SWIGTYPE_p_Rule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_AssignmentRule, (void *) &SwigClassAssignmentRule);
  rb_define_alloc_func(SwigClassAssignmentRule.klass, _wrap_AssignmentRule_allocate);
  rb_define_method(SwigClassAssignmentRule.klass, "initialize", VALUEFUNC(_wrap_new_AssignmentRule), -1);
  rb_define_method(SwigClassAssignmentRule.klass, "clone", VALUEFUNC(_wrap_AssignmentRule_clone), -1);
  rb_define_method(SwigClassAssignmentRule.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_AssignmentRule_hasRequiredAttributes), -1);
  SwigClassAssignmentRule.mark = 0;
  SwigClassAssignmentRule.destroy = (void (*)(void *)) free_AssignmentRule;
  SwigClassAssignmentRule.trackObjects = 1;
  
  SwigClassRateRule.klass = rb_define_class_under(mLibSBML, "RateRule", ((swig_class *) SWIGTYPE_p_Rule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_RateRule, (void *) &SwigClassRateRule);
  rb_define_alloc_func(SwigClassRateRule.klass, _wrap_RateRule_allocate);
  rb_define_method(SwigClassRateRule.klass, "initialize", VALUEFUNC(_wrap_new_RateRule), -1);
  rb_define_method(SwigClassRateRule.klass, "clone", VALUEFUNC(_wrap_RateRule_clone), -1);
  rb_define_method(SwigClassRateRule.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_RateRule_hasRequiredAttributes), -1);
  SwigClassRateRule.mark = 0;
  SwigClassRateRule.destroy = (void (*)(void *)) free_RateRule;
  SwigClassRateRule.trackObjects = 1;
  
  SwigClassListOfRules.klass = rb_define_class_under(mLibSBML, "ListOfRules", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfRules, (void *) &SwigClassListOfRules);
  rb_define_alloc_func(SwigClassListOfRules.klass, _wrap_ListOfRules_allocate);
  rb_define_method(SwigClassListOfRules.klass, "initialize", VALUEFUNC(_wrap_new_ListOfRules), -1);
  rb_define_method(SwigClassListOfRules.klass, "clone", VALUEFUNC(_wrap_ListOfRules_clone), -1);
  rb_define_method(SwigClassListOfRules.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfRules_getTypeCode), -1);
  rb_define_method(SwigClassListOfRules.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfRules_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfRules.klass, "getElementName", VALUEFUNC(_wrap_ListOfRules_getElementName), -1);
  rb_define_method(SwigClassListOfRules.klass, "get", VALUEFUNC(_wrap_ListOfRules_get), -1);
  rb_define_method(SwigClassListOfRules.klass, "remove", VALUEFUNC(_wrap_ListOfRules_remove), -1);
  SwigClassListOfRules.mark = 0;
  SwigClassListOfRules.destroy = (void (*)(void *)) free_ListOfRules;
  SwigClassListOfRules.trackObjects = 1;
  
  SwigClassConstraint.klass = rb_define_class_under(mLibSBML, "Constraint", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Constraint, (void *) &SwigClassConstraint);
  rb_define_alloc_func(SwigClassConstraint.klass, _wrap_Constraint_allocate);
  rb_define_method(SwigClassConstraint.klass, "initialize", VALUEFUNC(_wrap_new_Constraint), -1);
  rb_define_method(SwigClassConstraint.klass, "clone", VALUEFUNC(_wrap_Constraint_clone), -1);
  rb_define_method(SwigClassConstraint.klass, "getMessage", VALUEFUNC(_wrap_Constraint_getMessage), -1);
  rb_define_method(SwigClassConstraint.klass, "getMessageString", VALUEFUNC(_wrap_Constraint_getMessageString), -1);
  rb_define_method(SwigClassConstraint.klass, "getMath", VALUEFUNC(_wrap_Constraint_getMath), -1);
  rb_define_method(SwigClassConstraint.klass, "isSetMessage", VALUEFUNC(_wrap_Constraint_isSetMessage), -1);
  rb_define_method(SwigClassConstraint.klass, "isSetMath", VALUEFUNC(_wrap_Constraint_isSetMath), -1);
  rb_define_method(SwigClassConstraint.klass, "setMessage", VALUEFUNC(_wrap_Constraint_setMessage), -1);
  rb_define_method(SwigClassConstraint.klass, "setMath", VALUEFUNC(_wrap_Constraint_setMath), -1);
  rb_define_method(SwigClassConstraint.klass, "unsetMessage", VALUEFUNC(_wrap_Constraint_unsetMessage), -1);
  rb_define_method(SwigClassConstraint.klass, "getTypeCode", VALUEFUNC(_wrap_Constraint_getTypeCode), -1);
  rb_define_method(SwigClassConstraint.klass, "getElementName", VALUEFUNC(_wrap_Constraint_getElementName), -1);
  rb_define_method(SwigClassConstraint.klass, "hasRequiredElements", VALUEFUNC(_wrap_Constraint_hasRequiredElements), -1);
  SwigClassConstraint.mark = 0;
  SwigClassConstraint.destroy = (void (*)(void *)) free_Constraint;
  SwigClassConstraint.trackObjects = 1;
  
  SwigClassListOfConstraints.klass = rb_define_class_under(mLibSBML, "ListOfConstraints", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfConstraints, (void *) &SwigClassListOfConstraints);
  rb_define_alloc_func(SwigClassListOfConstraints.klass, _wrap_ListOfConstraints_allocate);
  rb_define_method(SwigClassListOfConstraints.klass, "initialize", VALUEFUNC(_wrap_new_ListOfConstraints), -1);
  rb_define_method(SwigClassListOfConstraints.klass, "clone", VALUEFUNC(_wrap_ListOfConstraints_clone), -1);
  rb_define_method(SwigClassListOfConstraints.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfConstraints_getTypeCode), -1);
  rb_define_method(SwigClassListOfConstraints.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfConstraints_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfConstraints.klass, "getElementName", VALUEFUNC(_wrap_ListOfConstraints_getElementName), -1);
  rb_define_method(SwigClassListOfConstraints.klass, "get", VALUEFUNC(_wrap_ListOfConstraints_get), -1);
  rb_define_method(SwigClassListOfConstraints.klass, "remove", VALUEFUNC(_wrap_ListOfConstraints_remove), -1);
  SwigClassListOfConstraints.mark = 0;
  SwigClassListOfConstraints.destroy = (void (*)(void *)) free_ListOfConstraints;
  SwigClassListOfConstraints.trackObjects = 1;
  
  SwigClassReaction.klass = rb_define_class_under(mLibSBML, "Reaction", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Reaction, (void *) &SwigClassReaction);
  rb_define_alloc_func(SwigClassReaction.klass, _wrap_Reaction_allocate);
  rb_define_method(SwigClassReaction.klass, "initialize", VALUEFUNC(_wrap_new_Reaction), -1);
  rb_define_method(SwigClassReaction.klass, "clone", VALUEFUNC(_wrap_Reaction_clone), -1);
  rb_define_method(SwigClassReaction.klass, "initDefaults", VALUEFUNC(_wrap_Reaction_initDefaults), -1);
  rb_define_method(SwigClassReaction.klass, "getId", VALUEFUNC(_wrap_Reaction_getId), -1);
  rb_define_method(SwigClassReaction.klass, "getName", VALUEFUNC(_wrap_Reaction_getName), -1);
  rb_define_method(SwigClassReaction.klass, "getKineticLaw", VALUEFUNC(_wrap_Reaction_getKineticLaw), -1);
  rb_define_method(SwigClassReaction.klass, "getReversible", VALUEFUNC(_wrap_Reaction_getReversible), -1);
  rb_define_method(SwigClassReaction.klass, "getFast", VALUEFUNC(_wrap_Reaction_getFast), -1);
  rb_define_method(SwigClassReaction.klass, "getCompartment", VALUEFUNC(_wrap_Reaction_getCompartment), -1);
  rb_define_method(SwigClassReaction.klass, "isSetId", VALUEFUNC(_wrap_Reaction_isSetId), -1);
  rb_define_method(SwigClassReaction.klass, "isSetName", VALUEFUNC(_wrap_Reaction_isSetName), -1);
  rb_define_method(SwigClassReaction.klass, "isSetKineticLaw", VALUEFUNC(_wrap_Reaction_isSetKineticLaw), -1);
  rb_define_method(SwigClassReaction.klass, "isSetFast", VALUEFUNC(_wrap_Reaction_isSetFast), -1);
  rb_define_method(SwigClassReaction.klass, "isSetCompartment", VALUEFUNC(_wrap_Reaction_isSetCompartment), -1);
  rb_define_method(SwigClassReaction.klass, "isSetReversible", VALUEFUNC(_wrap_Reaction_isSetReversible), -1);
  rb_define_method(SwigClassReaction.klass, "setId", VALUEFUNC(_wrap_Reaction_setId), -1);
  rb_define_method(SwigClassReaction.klass, "setName", VALUEFUNC(_wrap_Reaction_setName), -1);
  rb_define_method(SwigClassReaction.klass, "setKineticLaw", VALUEFUNC(_wrap_Reaction_setKineticLaw), -1);
  rb_define_method(SwigClassReaction.klass, "setReversible", VALUEFUNC(_wrap_Reaction_setReversible), -1);
  rb_define_method(SwigClassReaction.klass, "setFast", VALUEFUNC(_wrap_Reaction_setFast), -1);
  rb_define_method(SwigClassReaction.klass, "setCompartment", VALUEFUNC(_wrap_Reaction_setCompartment), -1);
  rb_define_method(SwigClassReaction.klass, "unsetName", VALUEFUNC(_wrap_Reaction_unsetName), -1);
  rb_define_method(SwigClassReaction.klass, "unsetKineticLaw", VALUEFUNC(_wrap_Reaction_unsetKineticLaw), -1);
  rb_define_method(SwigClassReaction.klass, "unsetFast", VALUEFUNC(_wrap_Reaction_unsetFast), -1);
  rb_define_method(SwigClassReaction.klass, "unsetCompartment", VALUEFUNC(_wrap_Reaction_unsetCompartment), -1);
  rb_define_method(SwigClassReaction.klass, "addReactant", VALUEFUNC(_wrap_Reaction_addReactant), -1);
  rb_define_method(SwigClassReaction.klass, "addProduct", VALUEFUNC(_wrap_Reaction_addProduct), -1);
  rb_define_method(SwigClassReaction.klass, "addModifier", VALUEFUNC(_wrap_Reaction_addModifier), -1);
  rb_define_method(SwigClassReaction.klass, "createReactant", VALUEFUNC(_wrap_Reaction_createReactant), -1);
  rb_define_method(SwigClassReaction.klass, "createProduct", VALUEFUNC(_wrap_Reaction_createProduct), -1);
  rb_define_method(SwigClassReaction.klass, "createModifier", VALUEFUNC(_wrap_Reaction_createModifier), -1);
  rb_define_method(SwigClassReaction.klass, "createKineticLaw", VALUEFUNC(_wrap_Reaction_createKineticLaw), -1);
  rb_define_method(SwigClassReaction.klass, "getListOfReactants", VALUEFUNC(_wrap_Reaction_getListOfReactants), -1);
  rb_define_method(SwigClassReaction.klass, "getListOfProducts", VALUEFUNC(_wrap_Reaction_getListOfProducts), -1);
  rb_define_method(SwigClassReaction.klass, "getListOfModifiers", VALUEFUNC(_wrap_Reaction_getListOfModifiers), -1);
  rb_define_method(SwigClassReaction.klass, "getReactant", VALUEFUNC(_wrap_Reaction_getReactant), -1);
  rb_define_method(SwigClassReaction.klass, "getProduct", VALUEFUNC(_wrap_Reaction_getProduct), -1);
  rb_define_method(SwigClassReaction.klass, "getModifier", VALUEFUNC(_wrap_Reaction_getModifier), -1);
  rb_define_method(SwigClassReaction.klass, "getNumReactants", VALUEFUNC(_wrap_Reaction_getNumReactants), -1);
  rb_define_method(SwigClassReaction.klass, "getNumProducts", VALUEFUNC(_wrap_Reaction_getNumProducts), -1);
  rb_define_method(SwigClassReaction.klass, "getNumModifiers", VALUEFUNC(_wrap_Reaction_getNumModifiers), -1);
  rb_define_method(SwigClassReaction.klass, "removeReactant", VALUEFUNC(_wrap_Reaction_removeReactant), -1);
  rb_define_method(SwigClassReaction.klass, "removeProduct", VALUEFUNC(_wrap_Reaction_removeProduct), -1);
  rb_define_method(SwigClassReaction.klass, "removeModifier", VALUEFUNC(_wrap_Reaction_removeModifier), -1);
  rb_define_method(SwigClassReaction.klass, "connectToChild", VALUEFUNC(_wrap_Reaction_connectToChild), -1);
  rb_define_method(SwigClassReaction.klass, "enablePackageInternal", VALUEFUNC(_wrap_Reaction_enablePackageInternal), -1);
  rb_define_method(SwigClassReaction.klass, "getTypeCode", VALUEFUNC(_wrap_Reaction_getTypeCode), -1);
  rb_define_method(SwigClassReaction.klass, "getElementName", VALUEFUNC(_wrap_Reaction_getElementName), -1);
  rb_define_method(SwigClassReaction.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Reaction_hasRequiredAttributes), -1);
  SwigClassReaction.mark = 0;
  SwigClassReaction.destroy = (void (*)(void *)) free_Reaction;
  SwigClassReaction.trackObjects = 1;
  
  SwigClassListOfReactions.klass = rb_define_class_under(mLibSBML, "ListOfReactions", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfReactions, (void *) &SwigClassListOfReactions);
  rb_define_alloc_func(SwigClassListOfReactions.klass, _wrap_ListOfReactions_allocate);
  rb_define_method(SwigClassListOfReactions.klass, "initialize", VALUEFUNC(_wrap_new_ListOfReactions), -1);
  rb_define_method(SwigClassListOfReactions.klass, "clone", VALUEFUNC(_wrap_ListOfReactions_clone), -1);
  rb_define_method(SwigClassListOfReactions.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfReactions_getTypeCode), -1);
  rb_define_method(SwigClassListOfReactions.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfReactions_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfReactions.klass, "getElementName", VALUEFUNC(_wrap_ListOfReactions_getElementName), -1);
  rb_define_method(SwigClassListOfReactions.klass, "get", VALUEFUNC(_wrap_ListOfReactions_get), -1);
  rb_define_method(SwigClassListOfReactions.klass, "remove", VALUEFUNC(_wrap_ListOfReactions_remove), -1);
  SwigClassListOfReactions.mark = 0;
  SwigClassListOfReactions.destroy = (void (*)(void *)) free_ListOfReactions;
  SwigClassListOfReactions.trackObjects = 1;
  
  SwigClassKineticLaw.klass = rb_define_class_under(mLibSBML, "KineticLaw", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_KineticLaw, (void *) &SwigClassKineticLaw);
  rb_define_alloc_func(SwigClassKineticLaw.klass, _wrap_KineticLaw_allocate);
  rb_define_method(SwigClassKineticLaw.klass, "initialize", VALUEFUNC(_wrap_new_KineticLaw), -1);
  rb_define_method(SwigClassKineticLaw.klass, "clone", VALUEFUNC(_wrap_KineticLaw_clone), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getFormula", VALUEFUNC(_wrap_KineticLaw_getFormula), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getMath", VALUEFUNC(_wrap_KineticLaw_getMath), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getTimeUnits", VALUEFUNC(_wrap_KineticLaw_getTimeUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getSubstanceUnits", VALUEFUNC(_wrap_KineticLaw_getSubstanceUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "isSetFormula", VALUEFUNC(_wrap_KineticLaw_isSetFormula), -1);
  rb_define_method(SwigClassKineticLaw.klass, "isSetMath", VALUEFUNC(_wrap_KineticLaw_isSetMath), -1);
  rb_define_method(SwigClassKineticLaw.klass, "isSetTimeUnits", VALUEFUNC(_wrap_KineticLaw_isSetTimeUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "isSetSubstanceUnits", VALUEFUNC(_wrap_KineticLaw_isSetSubstanceUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "setFormula", VALUEFUNC(_wrap_KineticLaw_setFormula), -1);
  rb_define_method(SwigClassKineticLaw.klass, "setMath", VALUEFUNC(_wrap_KineticLaw_setMath), -1);
  rb_define_method(SwigClassKineticLaw.klass, "setTimeUnits", VALUEFUNC(_wrap_KineticLaw_setTimeUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "setSubstanceUnits", VALUEFUNC(_wrap_KineticLaw_setSubstanceUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "unsetTimeUnits", VALUEFUNC(_wrap_KineticLaw_unsetTimeUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "unsetSubstanceUnits", VALUEFUNC(_wrap_KineticLaw_unsetSubstanceUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "addParameter", VALUEFUNC(_wrap_KineticLaw_addParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "addLocalParameter", VALUEFUNC(_wrap_KineticLaw_addLocalParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "createParameter", VALUEFUNC(_wrap_KineticLaw_createParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "createLocalParameter", VALUEFUNC(_wrap_KineticLaw_createLocalParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getListOfParameters", VALUEFUNC(_wrap_KineticLaw_getListOfParameters), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getListOfLocalParameters", VALUEFUNC(_wrap_KineticLaw_getListOfLocalParameters), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getParameter", VALUEFUNC(_wrap_KineticLaw_getParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getLocalParameter", VALUEFUNC(_wrap_KineticLaw_getLocalParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getNumParameters", VALUEFUNC(_wrap_KineticLaw_getNumParameters), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getNumLocalParameters", VALUEFUNC(_wrap_KineticLaw_getNumLocalParameters), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_KineticLaw_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassKineticLaw.klass, "containsUndeclaredUnits", VALUEFUNC(_wrap_KineticLaw_containsUndeclaredUnits), -1);
  rb_define_method(SwigClassKineticLaw.klass, "removeParameter", VALUEFUNC(_wrap_KineticLaw_removeParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "removeLocalParameter", VALUEFUNC(_wrap_KineticLaw_removeLocalParameter), -1);
  rb_define_method(SwigClassKineticLaw.klass, "connectToChild", VALUEFUNC(_wrap_KineticLaw_connectToChild), -1);
  rb_define_method(SwigClassKineticLaw.klass, "enablePackageInternal", VALUEFUNC(_wrap_KineticLaw_enablePackageInternal), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getTypeCode", VALUEFUNC(_wrap_KineticLaw_getTypeCode), -1);
  rb_define_method(SwigClassKineticLaw.klass, "getElementName", VALUEFUNC(_wrap_KineticLaw_getElementName), -1);
  rb_define_method(SwigClassKineticLaw.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_KineticLaw_hasRequiredAttributes), -1);
  rb_define_method(SwigClassKineticLaw.klass, "hasRequiredElements", VALUEFUNC(_wrap_KineticLaw_hasRequiredElements), -1);
  SwigClassKineticLaw.mark = 0;
  SwigClassKineticLaw.destroy = (void (*)(void *)) free_KineticLaw;
  SwigClassKineticLaw.trackObjects = 1;
  
  SwigClassSimpleSpeciesReference.klass = rb_define_class_under(mLibSBML, "SimpleSpeciesReference", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SimpleSpeciesReference, (void *) &SwigClassSimpleSpeciesReference);
  rb_undef_alloc_func(SwigClassSimpleSpeciesReference.klass);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "getId", VALUEFUNC(_wrap_SimpleSpeciesReference_getId), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "getName", VALUEFUNC(_wrap_SimpleSpeciesReference_getName), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "getSpecies", VALUEFUNC(_wrap_SimpleSpeciesReference_getSpecies), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "isSetId", VALUEFUNC(_wrap_SimpleSpeciesReference_isSetId), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "isSetName", VALUEFUNC(_wrap_SimpleSpeciesReference_isSetName), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "isSetSpecies", VALUEFUNC(_wrap_SimpleSpeciesReference_isSetSpecies), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "setSpecies", VALUEFUNC(_wrap_SimpleSpeciesReference_setSpecies), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "setId", VALUEFUNC(_wrap_SimpleSpeciesReference_setId), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "setName", VALUEFUNC(_wrap_SimpleSpeciesReference_setName), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "unsetId", VALUEFUNC(_wrap_SimpleSpeciesReference_unsetId), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "unsetName", VALUEFUNC(_wrap_SimpleSpeciesReference_unsetName), -1);
  rb_define_method(SwigClassSimpleSpeciesReference.klass, "isModifier", VALUEFUNC(_wrap_SimpleSpeciesReference_isModifier), -1);
  SwigClassSimpleSpeciesReference.mark = 0;
  SwigClassSimpleSpeciesReference.destroy = (void (*)(void *)) free_SimpleSpeciesReference;
  SwigClassSimpleSpeciesReference.trackObjects = 1;
  
  SwigClassSpeciesReference.klass = rb_define_class_under(mLibSBML, "SpeciesReference", ((swig_class *) SWIGTYPE_p_SimpleSpeciesReference->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SpeciesReference, (void *) &SwigClassSpeciesReference);
  rb_define_alloc_func(SwigClassSpeciesReference.klass, _wrap_SpeciesReference_allocate);
  rb_define_method(SwigClassSpeciesReference.klass, "initialize", VALUEFUNC(_wrap_new_SpeciesReference), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "clone", VALUEFUNC(_wrap_SpeciesReference_clone), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "initDefaults", VALUEFUNC(_wrap_SpeciesReference_initDefaults), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "getStoichiometry", VALUEFUNC(_wrap_SpeciesReference_getStoichiometry), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "getStoichiometryMath", VALUEFUNC(_wrap_SpeciesReference_getStoichiometryMath), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "getDenominator", VALUEFUNC(_wrap_SpeciesReference_getDenominator), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "getConstant", VALUEFUNC(_wrap_SpeciesReference_getConstant), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "isSetStoichiometryMath", VALUEFUNC(_wrap_SpeciesReference_isSetStoichiometryMath), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "isSetConstant", VALUEFUNC(_wrap_SpeciesReference_isSetConstant), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "isSetStoichiometry", VALUEFUNC(_wrap_SpeciesReference_isSetStoichiometry), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "setStoichiometry", VALUEFUNC(_wrap_SpeciesReference_setStoichiometry), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "setStoichiometryMath", VALUEFUNC(_wrap_SpeciesReference_setStoichiometryMath), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "setDenominator", VALUEFUNC(_wrap_SpeciesReference_setDenominator), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "setConstant", VALUEFUNC(_wrap_SpeciesReference_setConstant), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "unsetStoichiometryMath", VALUEFUNC(_wrap_SpeciesReference_unsetStoichiometryMath), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "unsetStoichiometry", VALUEFUNC(_wrap_SpeciesReference_unsetStoichiometry), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "createStoichiometryMath", VALUEFUNC(_wrap_SpeciesReference_createStoichiometryMath), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "setAnnotation", VALUEFUNC(_wrap_SpeciesReference_setAnnotation), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "appendAnnotation", VALUEFUNC(_wrap_SpeciesReference_appendAnnotation), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "getTypeCode", VALUEFUNC(_wrap_SpeciesReference_getTypeCode), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "getElementName", VALUEFUNC(_wrap_SpeciesReference_getElementName), -1);
  rb_define_method(SwigClassSpeciesReference.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_SpeciesReference_hasRequiredAttributes), -1);
  SwigClassSpeciesReference.mark = 0;
  SwigClassSpeciesReference.destroy = (void (*)(void *)) free_SpeciesReference;
  SwigClassSpeciesReference.trackObjects = 1;
  
  SwigClassModifierSpeciesReference.klass = rb_define_class_under(mLibSBML, "ModifierSpeciesReference", ((swig_class *) SWIGTYPE_p_SimpleSpeciesReference->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ModifierSpeciesReference, (void *) &SwigClassModifierSpeciesReference);
  rb_define_alloc_func(SwigClassModifierSpeciesReference.klass, _wrap_ModifierSpeciesReference_allocate);
  rb_define_method(SwigClassModifierSpeciesReference.klass, "initialize", VALUEFUNC(_wrap_new_ModifierSpeciesReference), -1);
  rb_define_method(SwigClassModifierSpeciesReference.klass, "clone", VALUEFUNC(_wrap_ModifierSpeciesReference_clone), -1);
  rb_define_method(SwigClassModifierSpeciesReference.klass, "getTypeCode", VALUEFUNC(_wrap_ModifierSpeciesReference_getTypeCode), -1);
  rb_define_method(SwigClassModifierSpeciesReference.klass, "getElementName", VALUEFUNC(_wrap_ModifierSpeciesReference_getElementName), -1);
  rb_define_method(SwigClassModifierSpeciesReference.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_ModifierSpeciesReference_hasRequiredAttributes), -1);
  SwigClassModifierSpeciesReference.mark = 0;
  SwigClassModifierSpeciesReference.destroy = (void (*)(void *)) free_ModifierSpeciesReference;
  SwigClassModifierSpeciesReference.trackObjects = 1;
  
  SwigClassListOfSpeciesReferences.klass = rb_define_class_under(mLibSBML, "ListOfSpeciesReferences", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfSpeciesReferences, (void *) &SwigClassListOfSpeciesReferences);
  rb_define_alloc_func(SwigClassListOfSpeciesReferences.klass, _wrap_ListOfSpeciesReferences_allocate);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "initialize", VALUEFUNC(_wrap_new_ListOfSpeciesReferences), -1);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "clone", VALUEFUNC(_wrap_ListOfSpeciesReferences_clone), -1);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfSpeciesReferences_getTypeCode), -1);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfSpeciesReferences_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "getElementName", VALUEFUNC(_wrap_ListOfSpeciesReferences_getElementName), -1);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "get", VALUEFUNC(_wrap_ListOfSpeciesReferences_get), -1);
  rb_define_method(SwigClassListOfSpeciesReferences.klass, "remove", VALUEFUNC(_wrap_ListOfSpeciesReferences_remove), -1);
  SwigClassListOfSpeciesReferences.mark = 0;
  SwigClassListOfSpeciesReferences.destroy = (void (*)(void *)) free_ListOfSpeciesReferences;
  SwigClassListOfSpeciesReferences.trackObjects = 1;
  
  SwigClassEvent.klass = rb_define_class_under(mLibSBML, "Event", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Event, (void *) &SwigClassEvent);
  rb_define_alloc_func(SwigClassEvent.klass, _wrap_Event_allocate);
  rb_define_method(SwigClassEvent.klass, "initialize", VALUEFUNC(_wrap_new_Event), -1);
  rb_define_method(SwigClassEvent.klass, "clone", VALUEFUNC(_wrap_Event_clone), -1);
  rb_define_method(SwigClassEvent.klass, "getId", VALUEFUNC(_wrap_Event_getId), -1);
  rb_define_method(SwigClassEvent.klass, "getName", VALUEFUNC(_wrap_Event_getName), -1);
  rb_define_method(SwigClassEvent.klass, "getTrigger", VALUEFUNC(_wrap_Event_getTrigger), -1);
  rb_define_method(SwigClassEvent.klass, "getDelay", VALUEFUNC(_wrap_Event_getDelay), -1);
  rb_define_method(SwigClassEvent.klass, "getPriority", VALUEFUNC(_wrap_Event_getPriority), -1);
  rb_define_method(SwigClassEvent.klass, "getTimeUnits", VALUEFUNC(_wrap_Event_getTimeUnits), -1);
  rb_define_method(SwigClassEvent.klass, "getUseValuesFromTriggerTime", VALUEFUNC(_wrap_Event_getUseValuesFromTriggerTime), -1);
  rb_define_method(SwigClassEvent.klass, "isSetId", VALUEFUNC(_wrap_Event_isSetId), -1);
  rb_define_method(SwigClassEvent.klass, "isSetName", VALUEFUNC(_wrap_Event_isSetName), -1);
  rb_define_method(SwigClassEvent.klass, "isSetTrigger", VALUEFUNC(_wrap_Event_isSetTrigger), -1);
  rb_define_method(SwigClassEvent.klass, "isSetDelay", VALUEFUNC(_wrap_Event_isSetDelay), -1);
  rb_define_method(SwigClassEvent.klass, "isSetPriority", VALUEFUNC(_wrap_Event_isSetPriority), -1);
  rb_define_method(SwigClassEvent.klass, "isSetTimeUnits", VALUEFUNC(_wrap_Event_isSetTimeUnits), -1);
  rb_define_method(SwigClassEvent.klass, "isSetUseValuesFromTriggerTime", VALUEFUNC(_wrap_Event_isSetUseValuesFromTriggerTime), -1);
  rb_define_method(SwigClassEvent.klass, "setId", VALUEFUNC(_wrap_Event_setId), -1);
  rb_define_method(SwigClassEvent.klass, "setName", VALUEFUNC(_wrap_Event_setName), -1);
  rb_define_method(SwigClassEvent.klass, "setTrigger", VALUEFUNC(_wrap_Event_setTrigger), -1);
  rb_define_method(SwigClassEvent.klass, "setDelay", VALUEFUNC(_wrap_Event_setDelay), -1);
  rb_define_method(SwigClassEvent.klass, "setPriority", VALUEFUNC(_wrap_Event_setPriority), -1);
  rb_define_method(SwigClassEvent.klass, "setTimeUnits", VALUEFUNC(_wrap_Event_setTimeUnits), -1);
  rb_define_method(SwigClassEvent.klass, "setUseValuesFromTriggerTime", VALUEFUNC(_wrap_Event_setUseValuesFromTriggerTime), -1);
  rb_define_method(SwigClassEvent.klass, "unsetId", VALUEFUNC(_wrap_Event_unsetId), -1);
  rb_define_method(SwigClassEvent.klass, "unsetName", VALUEFUNC(_wrap_Event_unsetName), -1);
  rb_define_method(SwigClassEvent.klass, "unsetDelay", VALUEFUNC(_wrap_Event_unsetDelay), -1);
  rb_define_method(SwigClassEvent.klass, "unsetPriority", VALUEFUNC(_wrap_Event_unsetPriority), -1);
  rb_define_method(SwigClassEvent.klass, "unsetTimeUnits", VALUEFUNC(_wrap_Event_unsetTimeUnits), -1);
  rb_define_method(SwigClassEvent.klass, "addEventAssignment", VALUEFUNC(_wrap_Event_addEventAssignment), -1);
  rb_define_method(SwigClassEvent.klass, "createEventAssignment", VALUEFUNC(_wrap_Event_createEventAssignment), -1);
  rb_define_method(SwigClassEvent.klass, "createTrigger", VALUEFUNC(_wrap_Event_createTrigger), -1);
  rb_define_method(SwigClassEvent.klass, "createDelay", VALUEFUNC(_wrap_Event_createDelay), -1);
  rb_define_method(SwigClassEvent.klass, "createPriority", VALUEFUNC(_wrap_Event_createPriority), -1);
  rb_define_method(SwigClassEvent.klass, "getListOfEventAssignments", VALUEFUNC(_wrap_Event_getListOfEventAssignments), -1);
  rb_define_method(SwigClassEvent.klass, "getEventAssignment", VALUEFUNC(_wrap_Event_getEventAssignment), -1);
  rb_define_method(SwigClassEvent.klass, "getNumEventAssignments", VALUEFUNC(_wrap_Event_getNumEventAssignments), -1);
  rb_define_method(SwigClassEvent.klass, "removeEventAssignment", VALUEFUNC(_wrap_Event_removeEventAssignment), -1);
  rb_define_method(SwigClassEvent.klass, "connectToChild", VALUEFUNC(_wrap_Event_connectToChild), -1);
  rb_define_method(SwigClassEvent.klass, "enablePackageInternal", VALUEFUNC(_wrap_Event_enablePackageInternal), -1);
  rb_define_method(SwigClassEvent.klass, "getTypeCode", VALUEFUNC(_wrap_Event_getTypeCode), -1);
  rb_define_method(SwigClassEvent.klass, "getElementName", VALUEFUNC(_wrap_Event_getElementName), -1);
  rb_define_method(SwigClassEvent.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Event_hasRequiredAttributes), -1);
  rb_define_method(SwigClassEvent.klass, "hasRequiredElements", VALUEFUNC(_wrap_Event_hasRequiredElements), -1);
  SwigClassEvent.mark = 0;
  SwigClassEvent.destroy = (void (*)(void *)) free_Event;
  SwigClassEvent.trackObjects = 1;
  
  SwigClassListOfEvents.klass = rb_define_class_under(mLibSBML, "ListOfEvents", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfEvents, (void *) &SwigClassListOfEvents);
  rb_define_alloc_func(SwigClassListOfEvents.klass, _wrap_ListOfEvents_allocate);
  rb_define_method(SwigClassListOfEvents.klass, "initialize", VALUEFUNC(_wrap_new_ListOfEvents), -1);
  rb_define_method(SwigClassListOfEvents.klass, "clone", VALUEFUNC(_wrap_ListOfEvents_clone), -1);
  rb_define_method(SwigClassListOfEvents.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfEvents_getTypeCode), -1);
  rb_define_method(SwigClassListOfEvents.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfEvents_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfEvents.klass, "getElementName", VALUEFUNC(_wrap_ListOfEvents_getElementName), -1);
  rb_define_method(SwigClassListOfEvents.klass, "get", VALUEFUNC(_wrap_ListOfEvents_get), -1);
  rb_define_method(SwigClassListOfEvents.klass, "remove", VALUEFUNC(_wrap_ListOfEvents_remove), -1);
  SwigClassListOfEvents.mark = 0;
  SwigClassListOfEvents.destroy = (void (*)(void *)) free_ListOfEvents;
  SwigClassListOfEvents.trackObjects = 1;
  
  SwigClassEventAssignment.klass = rb_define_class_under(mLibSBML, "EventAssignment", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_EventAssignment, (void *) &SwigClassEventAssignment);
  rb_define_alloc_func(SwigClassEventAssignment.klass, _wrap_EventAssignment_allocate);
  rb_define_method(SwigClassEventAssignment.klass, "initialize", VALUEFUNC(_wrap_new_EventAssignment), -1);
  rb_define_method(SwigClassEventAssignment.klass, "clone", VALUEFUNC(_wrap_EventAssignment_clone), -1);
  rb_define_method(SwigClassEventAssignment.klass, "getVariable", VALUEFUNC(_wrap_EventAssignment_getVariable), -1);
  rb_define_method(SwigClassEventAssignment.klass, "getMath", VALUEFUNC(_wrap_EventAssignment_getMath), -1);
  rb_define_method(SwigClassEventAssignment.klass, "isSetVariable", VALUEFUNC(_wrap_EventAssignment_isSetVariable), -1);
  rb_define_method(SwigClassEventAssignment.klass, "isSetMath", VALUEFUNC(_wrap_EventAssignment_isSetMath), -1);
  rb_define_method(SwigClassEventAssignment.klass, "setVariable", VALUEFUNC(_wrap_EventAssignment_setVariable), -1);
  rb_define_method(SwigClassEventAssignment.klass, "setMath", VALUEFUNC(_wrap_EventAssignment_setMath), -1);
  rb_define_method(SwigClassEventAssignment.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_EventAssignment_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassEventAssignment.klass, "containsUndeclaredUnits", VALUEFUNC(_wrap_EventAssignment_containsUndeclaredUnits), -1);
  rb_define_method(SwigClassEventAssignment.klass, "getTypeCode", VALUEFUNC(_wrap_EventAssignment_getTypeCode), -1);
  rb_define_method(SwigClassEventAssignment.klass, "getElementName", VALUEFUNC(_wrap_EventAssignment_getElementName), -1);
  rb_define_method(SwigClassEventAssignment.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_EventAssignment_hasRequiredAttributes), -1);
  rb_define_method(SwigClassEventAssignment.klass, "hasRequiredElements", VALUEFUNC(_wrap_EventAssignment_hasRequiredElements), -1);
  rb_define_method(SwigClassEventAssignment.klass, "getId", VALUEFUNC(_wrap_EventAssignment_getId), -1);
  SwigClassEventAssignment.mark = 0;
  SwigClassEventAssignment.destroy = (void (*)(void *)) free_EventAssignment;
  SwigClassEventAssignment.trackObjects = 1;
  
  SwigClassListOfEventAssignments.klass = rb_define_class_under(mLibSBML, "ListOfEventAssignments", ((swig_class *) SWIGTYPE_p_ListOf->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ListOfEventAssignments, (void *) &SwigClassListOfEventAssignments);
  rb_define_alloc_func(SwigClassListOfEventAssignments.klass, _wrap_ListOfEventAssignments_allocate);
  rb_define_method(SwigClassListOfEventAssignments.klass, "initialize", VALUEFUNC(_wrap_new_ListOfEventAssignments), -1);
  rb_define_method(SwigClassListOfEventAssignments.klass, "clone", VALUEFUNC(_wrap_ListOfEventAssignments_clone), -1);
  rb_define_method(SwigClassListOfEventAssignments.klass, "getTypeCode", VALUEFUNC(_wrap_ListOfEventAssignments_getTypeCode), -1);
  rb_define_method(SwigClassListOfEventAssignments.klass, "getItemTypeCode", VALUEFUNC(_wrap_ListOfEventAssignments_getItemTypeCode), -1);
  rb_define_method(SwigClassListOfEventAssignments.klass, "getElementName", VALUEFUNC(_wrap_ListOfEventAssignments_getElementName), -1);
  rb_define_method(SwigClassListOfEventAssignments.klass, "get", VALUEFUNC(_wrap_ListOfEventAssignments_get), -1);
  rb_define_method(SwigClassListOfEventAssignments.klass, "remove", VALUEFUNC(_wrap_ListOfEventAssignments_remove), -1);
  SwigClassListOfEventAssignments.mark = 0;
  SwigClassListOfEventAssignments.destroy = (void (*)(void *)) free_ListOfEventAssignments;
  SwigClassListOfEventAssignments.trackObjects = 1;
  
  SwigClassTrigger.klass = rb_define_class_under(mLibSBML, "Trigger", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Trigger, (void *) &SwigClassTrigger);
  rb_define_alloc_func(SwigClassTrigger.klass, _wrap_Trigger_allocate);
  rb_define_method(SwigClassTrigger.klass, "initialize", VALUEFUNC(_wrap_new_Trigger), -1);
  rb_define_method(SwigClassTrigger.klass, "clone", VALUEFUNC(_wrap_Trigger_clone), -1);
  rb_define_method(SwigClassTrigger.klass, "getMath", VALUEFUNC(_wrap_Trigger_getMath), -1);
  rb_define_method(SwigClassTrigger.klass, "getInitialValue", VALUEFUNC(_wrap_Trigger_getInitialValue), -1);
  rb_define_method(SwigClassTrigger.klass, "getPersistent", VALUEFUNC(_wrap_Trigger_getPersistent), -1);
  rb_define_method(SwigClassTrigger.klass, "isSetMath", VALUEFUNC(_wrap_Trigger_isSetMath), -1);
  rb_define_method(SwigClassTrigger.klass, "isSetInitialValue", VALUEFUNC(_wrap_Trigger_isSetInitialValue), -1);
  rb_define_method(SwigClassTrigger.klass, "isSetPersistent", VALUEFUNC(_wrap_Trigger_isSetPersistent), -1);
  rb_define_method(SwigClassTrigger.klass, "setMath", VALUEFUNC(_wrap_Trigger_setMath), -1);
  rb_define_method(SwigClassTrigger.klass, "setInitialValue", VALUEFUNC(_wrap_Trigger_setInitialValue), -1);
  rb_define_method(SwigClassTrigger.klass, "setPersistent", VALUEFUNC(_wrap_Trigger_setPersistent), -1);
  rb_define_method(SwigClassTrigger.klass, "getTypeCode", VALUEFUNC(_wrap_Trigger_getTypeCode), -1);
  rb_define_method(SwigClassTrigger.klass, "getElementName", VALUEFUNC(_wrap_Trigger_getElementName), -1);
  rb_define_method(SwigClassTrigger.klass, "hasRequiredElements", VALUEFUNC(_wrap_Trigger_hasRequiredElements), -1);
  rb_define_method(SwigClassTrigger.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_Trigger_hasRequiredAttributes), -1);
  SwigClassTrigger.mark = 0;
  SwigClassTrigger.destroy = (void (*)(void *)) free_Trigger;
  SwigClassTrigger.trackObjects = 1;
  
  SwigClassDelay.klass = rb_define_class_under(mLibSBML, "Delay", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Delay, (void *) &SwigClassDelay);
  rb_define_alloc_func(SwigClassDelay.klass, _wrap_Delay_allocate);
  rb_define_method(SwigClassDelay.klass, "initialize", VALUEFUNC(_wrap_new_Delay), -1);
  rb_define_method(SwigClassDelay.klass, "clone", VALUEFUNC(_wrap_Delay_clone), -1);
  rb_define_method(SwigClassDelay.klass, "getMath", VALUEFUNC(_wrap_Delay_getMath), -1);
  rb_define_method(SwigClassDelay.klass, "isSetMath", VALUEFUNC(_wrap_Delay_isSetMath), -1);
  rb_define_method(SwigClassDelay.klass, "setMath", VALUEFUNC(_wrap_Delay_setMath), -1);
  rb_define_method(SwigClassDelay.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_Delay_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassDelay.klass, "containsUndeclaredUnits", VALUEFUNC(_wrap_Delay_containsUndeclaredUnits), -1);
  rb_define_method(SwigClassDelay.klass, "getTypeCode", VALUEFUNC(_wrap_Delay_getTypeCode), -1);
  rb_define_method(SwigClassDelay.klass, "getElementName", VALUEFUNC(_wrap_Delay_getElementName), -1);
  rb_define_method(SwigClassDelay.klass, "hasRequiredElements", VALUEFUNC(_wrap_Delay_hasRequiredElements), -1);
  SwigClassDelay.mark = 0;
  SwigClassDelay.destroy = (void (*)(void *)) free_Delay;
  SwigClassDelay.trackObjects = 1;
  
  SwigClassPriority.klass = rb_define_class_under(mLibSBML, "Priority", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_Priority, (void *) &SwigClassPriority);
  rb_define_alloc_func(SwigClassPriority.klass, _wrap_Priority_allocate);
  rb_define_method(SwigClassPriority.klass, "initialize", VALUEFUNC(_wrap_new_Priority), -1);
  rb_define_method(SwigClassPriority.klass, "clone", VALUEFUNC(_wrap_Priority_clone), -1);
  rb_define_method(SwigClassPriority.klass, "getMath", VALUEFUNC(_wrap_Priority_getMath), -1);
  rb_define_method(SwigClassPriority.klass, "isSetMath", VALUEFUNC(_wrap_Priority_isSetMath), -1);
  rb_define_method(SwigClassPriority.klass, "setMath", VALUEFUNC(_wrap_Priority_setMath), -1);
  rb_define_method(SwigClassPriority.klass, "getTypeCode", VALUEFUNC(_wrap_Priority_getTypeCode), -1);
  rb_define_method(SwigClassPriority.klass, "getElementName", VALUEFUNC(_wrap_Priority_getElementName), -1);
  rb_define_method(SwigClassPriority.klass, "hasRequiredElements", VALUEFUNC(_wrap_Priority_hasRequiredElements), -1);
  SwigClassPriority.mark = 0;
  SwigClassPriority.destroy = (void (*)(void *)) free_Priority;
  SwigClassPriority.trackObjects = 1;
  
  SwigClassSBO.klass = rb_define_class_under(mLibSBML, "SBO", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBO, (void *) &SwigClassSBO);
  rb_define_alloc_func(SwigClassSBO.klass, _wrap_SBO_allocate);
  rb_define_method(SwigClassSBO.klass, "initialize", VALUEFUNC(_wrap_new_SBO), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isQuantitativeParameter", VALUEFUNC(_wrap_SBO_isQuantitativeParameter), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isParticipantRole", VALUEFUNC(_wrap_SBO_isParticipantRole), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isModellingFramework", VALUEFUNC(_wrap_SBO_isModellingFramework), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isMathematicalExpression", VALUEFUNC(_wrap_SBO_isMathematicalExpression), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isKineticConstant", VALUEFUNC(_wrap_SBO_isKineticConstant), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isReactant", VALUEFUNC(_wrap_SBO_isReactant), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isProduct", VALUEFUNC(_wrap_SBO_isProduct), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isModifier", VALUEFUNC(_wrap_SBO_isModifier), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isRateLaw", VALUEFUNC(_wrap_SBO_isRateLaw), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isEvent", VALUEFUNC(_wrap_SBO_isEvent), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isPhysicalParticipant", VALUEFUNC(_wrap_SBO_isPhysicalParticipant), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isParticipant", VALUEFUNC(_wrap_SBO_isParticipant), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isInteraction", VALUEFUNC(_wrap_SBO_isInteraction), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isEntity", VALUEFUNC(_wrap_SBO_isEntity), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isFunctionalEntity", VALUEFUNC(_wrap_SBO_isFunctionalEntity), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isMaterialEntity", VALUEFUNC(_wrap_SBO_isMaterialEntity), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isConservationLaw", VALUEFUNC(_wrap_SBO_isConservationLaw), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isSteadyStateExpression", VALUEFUNC(_wrap_SBO_isSteadyStateExpression), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isFunctionalCompartment", VALUEFUNC(_wrap_SBO_isFunctionalCompartment), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isContinuousFramework", VALUEFUNC(_wrap_SBO_isContinuousFramework), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isDiscreteFramework", VALUEFUNC(_wrap_SBO_isDiscreteFramework), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isLogicalFramework", VALUEFUNC(_wrap_SBO_isLogicalFramework), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "isObselete", VALUEFUNC(_wrap_SBO_isObselete), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "intToString", VALUEFUNC(_wrap_SBO_intToString), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "stringToInt", VALUEFUNC(_wrap_SBO_stringToInt), -1);
  rb_define_singleton_method(SwigClassSBO.klass, "checkTerm", VALUEFUNC(_wrap_SBO_checkTerm), -1);
  SwigClassSBO.mark = 0;
  SwigClassSBO.destroy = (void (*)(void *)) free_SBO;
  SwigClassSBO.trackObjects = 1;
  
  SwigClassSyntaxChecker.klass = rb_define_class_under(mLibSBML, "SyntaxChecker", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SyntaxChecker, (void *) &SwigClassSyntaxChecker);
  rb_define_alloc_func(SwigClassSyntaxChecker.klass, _wrap_SyntaxChecker_allocate);
  rb_define_method(SwigClassSyntaxChecker.klass, "initialize", VALUEFUNC(_wrap_new_SyntaxChecker), -1);
  rb_define_singleton_method(SwigClassSyntaxChecker.klass, "isValidSBMLSId", VALUEFUNC(_wrap_SyntaxChecker_isValidSBMLSId), -1);
  rb_define_singleton_method(SwigClassSyntaxChecker.klass, "isValidXMLID", VALUEFUNC(_wrap_SyntaxChecker_isValidXMLID), -1);
  rb_define_singleton_method(SwigClassSyntaxChecker.klass, "isValidUnitSId", VALUEFUNC(_wrap_SyntaxChecker_isValidUnitSId), -1);
  rb_define_singleton_method(SwigClassSyntaxChecker.klass, "hasExpectedXHTMLSyntax", VALUEFUNC(_wrap_SyntaxChecker_hasExpectedXHTMLSyntax), -1);
  rb_define_singleton_method(SwigClassSyntaxChecker.klass, "isValidInternalSId", VALUEFUNC(_wrap_SyntaxChecker_isValidInternalSId), -1);
  rb_define_singleton_method(SwigClassSyntaxChecker.klass, "isValidInternalUnitSId", VALUEFUNC(_wrap_SyntaxChecker_isValidInternalUnitSId), -1);
  SwigClassSyntaxChecker.mark = 0;
  SwigClassSyntaxChecker.destroy = (void (*)(void *)) free_SyntaxChecker;
  SwigClassSyntaxChecker.trackObjects = 1;
  
  SwigClassStoichiometryMath.klass = rb_define_class_under(mLibSBML, "StoichiometryMath", ((swig_class *) SWIGTYPE_p_SBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_StoichiometryMath, (void *) &SwigClassStoichiometryMath);
  rb_define_alloc_func(SwigClassStoichiometryMath.klass, _wrap_StoichiometryMath_allocate);
  rb_define_method(SwigClassStoichiometryMath.klass, "initialize", VALUEFUNC(_wrap_new_StoichiometryMath), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "clone", VALUEFUNC(_wrap_StoichiometryMath_clone), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "getMath", VALUEFUNC(_wrap_StoichiometryMath_getMath), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "isSetMath", VALUEFUNC(_wrap_StoichiometryMath_isSetMath), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "setMath", VALUEFUNC(_wrap_StoichiometryMath_setMath), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "getDerivedUnitDefinition", VALUEFUNC(_wrap_StoichiometryMath_getDerivedUnitDefinition), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "containsUndeclaredUnits", VALUEFUNC(_wrap_StoichiometryMath_containsUndeclaredUnits), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "getTypeCode", VALUEFUNC(_wrap_StoichiometryMath_getTypeCode), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "getElementName", VALUEFUNC(_wrap_StoichiometryMath_getElementName), -1);
  rb_define_method(SwigClassStoichiometryMath.klass, "hasRequiredElements", VALUEFUNC(_wrap_StoichiometryMath_hasRequiredElements), -1);
  SwigClassStoichiometryMath.mark = 0;
  SwigClassStoichiometryMath.destroy = (void (*)(void *)) free_StoichiometryMath;
  SwigClassStoichiometryMath.trackObjects = 1;
  
  SwigClassSBMLNamespaces.klass = rb_define_class_under(mLibSBML, "SBMLNamespaces", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLNamespaces, (void *) &SwigClassSBMLNamespaces);
  rb_define_alloc_func(SwigClassSBMLNamespaces.klass, _wrap_SBMLNamespaces_allocate);
  rb_define_method(SwigClassSBMLNamespaces.klass, "initialize", VALUEFUNC(_wrap_new_SBMLNamespaces), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "clone", VALUEFUNC(_wrap_SBMLNamespaces_clone), -1);
  rb_define_singleton_method(SwigClassSBMLNamespaces.klass, "getSBMLNamespaceURI", VALUEFUNC(_wrap_SBMLNamespaces_getSBMLNamespaceURI), -1);
  rb_define_singleton_method(SwigClassSBMLNamespaces.klass, "getSupportedNamespaces", VALUEFUNC(_wrap_SBMLNamespaces_getSupportedNamespaces), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "getURI", VALUEFUNC(_wrap_SBMLNamespaces_getURI), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "getLevel", VALUEFUNC(_wrap_SBMLNamespaces_getLevel), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "getVersion", VALUEFUNC(_wrap_SBMLNamespaces_getVersion), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "getNamespaces", VALUEFUNC(_wrap_SBMLNamespaces_getNamespaces), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "addNamespaces", VALUEFUNC(_wrap_SBMLNamespaces_addNamespaces), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "addNamespace", VALUEFUNC(_wrap_SBMLNamespaces_addNamespace), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "removeNamespace", VALUEFUNC(_wrap_SBMLNamespaces_removeNamespace), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "addPkgNamespace", VALUEFUNC(_wrap_SBMLNamespaces_addPkgNamespace), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "addPkgNamespaces", VALUEFUNC(_wrap_SBMLNamespaces_addPkgNamespaces), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "removePkgNamespace", VALUEFUNC(_wrap_SBMLNamespaces_removePkgNamespace), -1);
  rb_define_singleton_method(SwigClassSBMLNamespaces.klass, "isSBMLNamespace", VALUEFUNC(_wrap_SBMLNamespaces_isSBMLNamespace), -1);
  rb_define_method(SwigClassSBMLNamespaces.klass, "getPackageName", VALUEFUNC(_wrap_SBMLNamespaces_getPackageName), -1);
  SwigClassSBMLNamespaces.mark = 0;
  SwigClassSBMLNamespaces.destroy = (void (*)(void *)) free_SBMLNamespaces;
  SwigClassSBMLNamespaces.trackObjects = 1;
  
  SwigClassSBMLTransforms.klass = rb_define_class_under(mLibSBML, "SBMLTransforms", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLTransforms, (void *) &SwigClassSBMLTransforms);
  rb_define_alloc_func(SwigClassSBMLTransforms.klass, _wrap_SBMLTransforms_allocate);
  rb_define_method(SwigClassSBMLTransforms.klass, "initialize", VALUEFUNC(_wrap_new_SBMLTransforms), -1);
  SwigClassSBMLTransforms.mark = 0;
  SwigClassSBMLTransforms.destroy = (void (*)(void *)) free_SBMLTransforms;
  SwigClassSBMLTransforms.trackObjects = 1;
  rb_define_module_function(mLibSBML, "readMathMLFromString", VALUEFUNC(_wrap_readMathMLFromString), -1);
  rb_define_module_function(mLibSBML, "writeMathMLToString", VALUEFUNC(_wrap_writeMathMLToString), -1);
  rb_define_const(mLibSBML, "AST_PLUS", SWIG_From_int(static_cast< int >(AST_PLUS)));
  rb_define_const(mLibSBML, "AST_MINUS", SWIG_From_int(static_cast< int >(AST_MINUS)));
  rb_define_const(mLibSBML, "AST_TIMES", SWIG_From_int(static_cast< int >(AST_TIMES)));
  rb_define_const(mLibSBML, "AST_DIVIDE", SWIG_From_int(static_cast< int >(AST_DIVIDE)));
  rb_define_const(mLibSBML, "AST_POWER", SWIG_From_int(static_cast< int >(AST_POWER)));
  rb_define_const(mLibSBML, "AST_INTEGER", SWIG_From_int(static_cast< int >(AST_INTEGER)));
  rb_define_const(mLibSBML, "AST_REAL", SWIG_From_int(static_cast< int >(AST_REAL)));
  rb_define_const(mLibSBML, "AST_REAL_E", SWIG_From_int(static_cast< int >(AST_REAL_E)));
  rb_define_const(mLibSBML, "AST_RATIONAL", SWIG_From_int(static_cast< int >(AST_RATIONAL)));
  rb_define_const(mLibSBML, "AST_NAME", SWIG_From_int(static_cast< int >(AST_NAME)));
  rb_define_const(mLibSBML, "AST_NAME_AVOGADRO", SWIG_From_int(static_cast< int >(AST_NAME_AVOGADRO)));
  rb_define_const(mLibSBML, "AST_NAME_TIME", SWIG_From_int(static_cast< int >(AST_NAME_TIME)));
  rb_define_const(mLibSBML, "AST_CONSTANT_E", SWIG_From_int(static_cast< int >(AST_CONSTANT_E)));
  rb_define_const(mLibSBML, "AST_CONSTANT_FALSE", SWIG_From_int(static_cast< int >(AST_CONSTANT_FALSE)));
  rb_define_const(mLibSBML, "AST_CONSTANT_PI", SWIG_From_int(static_cast< int >(AST_CONSTANT_PI)));
  rb_define_const(mLibSBML, "AST_CONSTANT_TRUE", SWIG_From_int(static_cast< int >(AST_CONSTANT_TRUE)));
  rb_define_const(mLibSBML, "AST_LAMBDA", SWIG_From_int(static_cast< int >(AST_LAMBDA)));
  rb_define_const(mLibSBML, "AST_FUNCTION", SWIG_From_int(static_cast< int >(AST_FUNCTION)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ABS", SWIG_From_int(static_cast< int >(AST_FUNCTION_ABS)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCCOS", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOS)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCCOSH", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOSH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCCOT", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOT)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCCOTH", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOTH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCCSC", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCSC)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCCSCH", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCSCH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCSEC", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSEC)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCSECH", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSECH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCSIN", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSIN)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCSINH", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSINH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCTAN", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCTAN)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ARCTANH", SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCTANH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_CEILING", SWIG_From_int(static_cast< int >(AST_FUNCTION_CEILING)));
  rb_define_const(mLibSBML, "AST_FUNCTION_COS", SWIG_From_int(static_cast< int >(AST_FUNCTION_COS)));
  rb_define_const(mLibSBML, "AST_FUNCTION_COSH", SWIG_From_int(static_cast< int >(AST_FUNCTION_COSH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_COT", SWIG_From_int(static_cast< int >(AST_FUNCTION_COT)));
  rb_define_const(mLibSBML, "AST_FUNCTION_COTH", SWIG_From_int(static_cast< int >(AST_FUNCTION_COTH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_CSC", SWIG_From_int(static_cast< int >(AST_FUNCTION_CSC)));
  rb_define_const(mLibSBML, "AST_FUNCTION_CSCH", SWIG_From_int(static_cast< int >(AST_FUNCTION_CSCH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_DELAY", SWIG_From_int(static_cast< int >(AST_FUNCTION_DELAY)));
  rb_define_const(mLibSBML, "AST_FUNCTION_EXP", SWIG_From_int(static_cast< int >(AST_FUNCTION_EXP)));
  rb_define_const(mLibSBML, "AST_FUNCTION_FACTORIAL", SWIG_From_int(static_cast< int >(AST_FUNCTION_FACTORIAL)));
  rb_define_const(mLibSBML, "AST_FUNCTION_FLOOR", SWIG_From_int(static_cast< int >(AST_FUNCTION_FLOOR)));
  rb_define_const(mLibSBML, "AST_FUNCTION_LN", SWIG_From_int(static_cast< int >(AST_FUNCTION_LN)));
  rb_define_const(mLibSBML, "AST_FUNCTION_LOG", SWIG_From_int(static_cast< int >(AST_FUNCTION_LOG)));
  rb_define_const(mLibSBML, "AST_FUNCTION_PIECEWISE", SWIG_From_int(static_cast< int >(AST_FUNCTION_PIECEWISE)));
  rb_define_const(mLibSBML, "AST_FUNCTION_POWER", SWIG_From_int(static_cast< int >(AST_FUNCTION_POWER)));
  rb_define_const(mLibSBML, "AST_FUNCTION_ROOT", SWIG_From_int(static_cast< int >(AST_FUNCTION_ROOT)));
  rb_define_const(mLibSBML, "AST_FUNCTION_SEC", SWIG_From_int(static_cast< int >(AST_FUNCTION_SEC)));
  rb_define_const(mLibSBML, "AST_FUNCTION_SECH", SWIG_From_int(static_cast< int >(AST_FUNCTION_SECH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_SIN", SWIG_From_int(static_cast< int >(AST_FUNCTION_SIN)));
  rb_define_const(mLibSBML, "AST_FUNCTION_SINH", SWIG_From_int(static_cast< int >(AST_FUNCTION_SINH)));
  rb_define_const(mLibSBML, "AST_FUNCTION_TAN", SWIG_From_int(static_cast< int >(AST_FUNCTION_TAN)));
  rb_define_const(mLibSBML, "AST_FUNCTION_TANH", SWIG_From_int(static_cast< int >(AST_FUNCTION_TANH)));
  rb_define_const(mLibSBML, "AST_LOGICAL_AND", SWIG_From_int(static_cast< int >(AST_LOGICAL_AND)));
  rb_define_const(mLibSBML, "AST_LOGICAL_NOT", SWIG_From_int(static_cast< int >(AST_LOGICAL_NOT)));
  rb_define_const(mLibSBML, "AST_LOGICAL_OR", SWIG_From_int(static_cast< int >(AST_LOGICAL_OR)));
  rb_define_const(mLibSBML, "AST_LOGICAL_XOR", SWIG_From_int(static_cast< int >(AST_LOGICAL_XOR)));
  rb_define_const(mLibSBML, "AST_RELATIONAL_EQ", SWIG_From_int(static_cast< int >(AST_RELATIONAL_EQ)));
  rb_define_const(mLibSBML, "AST_RELATIONAL_GEQ", SWIG_From_int(static_cast< int >(AST_RELATIONAL_GEQ)));
  rb_define_const(mLibSBML, "AST_RELATIONAL_GT", SWIG_From_int(static_cast< int >(AST_RELATIONAL_GT)));
  rb_define_const(mLibSBML, "AST_RELATIONAL_LEQ", SWIG_From_int(static_cast< int >(AST_RELATIONAL_LEQ)));
  rb_define_const(mLibSBML, "AST_RELATIONAL_LT", SWIG_From_int(static_cast< int >(AST_RELATIONAL_LT)));
  rb_define_const(mLibSBML, "AST_RELATIONAL_NEQ", SWIG_From_int(static_cast< int >(AST_RELATIONAL_NEQ)));
  rb_define_const(mLibSBML, "AST_UNKNOWN", SWIG_From_int(static_cast< int >(AST_UNKNOWN)));
  
  SwigClassASTNode.klass = rb_define_class_under(mLibSBML, "ASTNode", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ASTNode, (void *) &SwigClassASTNode);
  rb_define_alloc_func(SwigClassASTNode.klass, _wrap_ASTNode_allocate);
  rb_define_method(SwigClassASTNode.klass, "initialize", VALUEFUNC(_wrap_new_ASTNode), -1);
  rb_define_method(SwigClassASTNode.klass, "freeName", VALUEFUNC(_wrap_ASTNode_freeName), -1);
  rb_define_method(SwigClassASTNode.klass, "canonicalize", VALUEFUNC(_wrap_ASTNode_canonicalize), -1);
  rb_define_method(SwigClassASTNode.klass, "addChild", VALUEFUNC(_wrap_ASTNode_addChild), -1);
  rb_define_method(SwigClassASTNode.klass, "prependChild", VALUEFUNC(_wrap_ASTNode_prependChild), -1);
  rb_define_method(SwigClassASTNode.klass, "removeChild", VALUEFUNC(_wrap_ASTNode_removeChild), -1);
  rb_define_method(SwigClassASTNode.klass, "replaceChild", VALUEFUNC(_wrap_ASTNode_replaceChild), -1);
  rb_define_method(SwigClassASTNode.klass, "insertChild", VALUEFUNC(_wrap_ASTNode_insertChild), -1);
  rb_define_method(SwigClassASTNode.klass, "deepCopy", VALUEFUNC(_wrap_ASTNode_deepCopy), -1);
  rb_define_method(SwigClassASTNode.klass, "getChild", VALUEFUNC(_wrap_ASTNode_getChild), -1);
  rb_define_method(SwigClassASTNode.klass, "getLeftChild", VALUEFUNC(_wrap_ASTNode_getLeftChild), -1);
  rb_define_method(SwigClassASTNode.klass, "getRightChild", VALUEFUNC(_wrap_ASTNode_getRightChild), -1);
  rb_define_method(SwigClassASTNode.klass, "getNumChildren", VALUEFUNC(_wrap_ASTNode_getNumChildren), -1);
  rb_define_method(SwigClassASTNode.klass, "addSemanticsAnnotation", VALUEFUNC(_wrap_ASTNode_addSemanticsAnnotation), -1);
  rb_define_method(SwigClassASTNode.klass, "getNumSemanticsAnnotations", VALUEFUNC(_wrap_ASTNode_getNumSemanticsAnnotations), -1);
  rb_define_method(SwigClassASTNode.klass, "getSemanticsAnnotation", VALUEFUNC(_wrap_ASTNode_getSemanticsAnnotation), -1);
  rb_define_method(SwigClassASTNode.klass, "getCharacter", VALUEFUNC(_wrap_ASTNode_getCharacter), -1);
  rb_define_method(SwigClassASTNode.klass, "getInteger", VALUEFUNC(_wrap_ASTNode_getInteger), -1);
  rb_define_method(SwigClassASTNode.klass, "getName", VALUEFUNC(_wrap_ASTNode_getName), -1);
  rb_define_method(SwigClassASTNode.klass, "getNumerator", VALUEFUNC(_wrap_ASTNode_getNumerator), -1);
  rb_define_method(SwigClassASTNode.klass, "getDenominator", VALUEFUNC(_wrap_ASTNode_getDenominator), -1);
  rb_define_method(SwigClassASTNode.klass, "getReal", VALUEFUNC(_wrap_ASTNode_getReal), -1);
  rb_define_method(SwigClassASTNode.klass, "getMantissa", VALUEFUNC(_wrap_ASTNode_getMantissa), -1);
  rb_define_method(SwigClassASTNode.klass, "getExponent", VALUEFUNC(_wrap_ASTNode_getExponent), -1);
  rb_define_method(SwigClassASTNode.klass, "getPrecedence", VALUEFUNC(_wrap_ASTNode_getPrecedence), -1);
  rb_define_method(SwigClassASTNode.klass, "getType", VALUEFUNC(_wrap_ASTNode_getType), -1);
  rb_define_method(SwigClassASTNode.klass, "getUnits", VALUEFUNC(_wrap_ASTNode_getUnits), -1);
  rb_define_method(SwigClassASTNode.klass, "isBoolean", VALUEFUNC(_wrap_ASTNode_isBoolean), -1);
  rb_define_method(SwigClassASTNode.klass, "isConstant", VALUEFUNC(_wrap_ASTNode_isConstant), -1);
  rb_define_method(SwigClassASTNode.klass, "isFunction", VALUEFUNC(_wrap_ASTNode_isFunction), -1);
  rb_define_method(SwigClassASTNode.klass, "isInfinity", VALUEFUNC(_wrap_ASTNode_isInfinity), -1);
  rb_define_method(SwigClassASTNode.klass, "isInteger", VALUEFUNC(_wrap_ASTNode_isInteger), -1);
  rb_define_method(SwigClassASTNode.klass, "isLambda", VALUEFUNC(_wrap_ASTNode_isLambda), -1);
  rb_define_method(SwigClassASTNode.klass, "isLog10", VALUEFUNC(_wrap_ASTNode_isLog10), -1);
  rb_define_method(SwigClassASTNode.klass, "isLogical", VALUEFUNC(_wrap_ASTNode_isLogical), -1);
  rb_define_method(SwigClassASTNode.klass, "isName", VALUEFUNC(_wrap_ASTNode_isName), -1);
  rb_define_method(SwigClassASTNode.klass, "isNaN", VALUEFUNC(_wrap_ASTNode_isNaN), -1);
  rb_define_method(SwigClassASTNode.klass, "isNegInfinity", VALUEFUNC(_wrap_ASTNode_isNegInfinity), -1);
  rb_define_method(SwigClassASTNode.klass, "isNumber", VALUEFUNC(_wrap_ASTNode_isNumber), -1);
  rb_define_method(SwigClassASTNode.klass, "isOperator", VALUEFUNC(_wrap_ASTNode_isOperator), -1);
  rb_define_method(SwigClassASTNode.klass, "isPiecewise", VALUEFUNC(_wrap_ASTNode_isPiecewise), -1);
  rb_define_method(SwigClassASTNode.klass, "isRational", VALUEFUNC(_wrap_ASTNode_isRational), -1);
  rb_define_method(SwigClassASTNode.klass, "isReal", VALUEFUNC(_wrap_ASTNode_isReal), -1);
  rb_define_method(SwigClassASTNode.klass, "isRelational", VALUEFUNC(_wrap_ASTNode_isRelational), -1);
  rb_define_method(SwigClassASTNode.klass, "isSqrt", VALUEFUNC(_wrap_ASTNode_isSqrt), -1);
  rb_define_method(SwigClassASTNode.klass, "isUMinus", VALUEFUNC(_wrap_ASTNode_isUMinus), -1);
  rb_define_method(SwigClassASTNode.klass, "isUnknown", VALUEFUNC(_wrap_ASTNode_isUnknown), -1);
  rb_define_method(SwigClassASTNode.klass, "isSetUnits", VALUEFUNC(_wrap_ASTNode_isSetUnits), -1);
  rb_define_method(SwigClassASTNode.klass, "hasUnits", VALUEFUNC(_wrap_ASTNode_hasUnits), -1);
  rb_define_method(SwigClassASTNode.klass, "setCharacter", VALUEFUNC(_wrap_ASTNode_setCharacter), -1);
  rb_define_method(SwigClassASTNode.klass, "setName", VALUEFUNC(_wrap_ASTNode_setName), -1);
  rb_define_method(SwigClassASTNode.klass, "setValue", VALUEFUNC(_wrap_ASTNode_setValue), -1);
  rb_define_method(SwigClassASTNode.klass, "setType", VALUEFUNC(_wrap_ASTNode_setType), -1);
  rb_define_method(SwigClassASTNode.klass, "setUnits", VALUEFUNC(_wrap_ASTNode_setUnits), -1);
  rb_define_method(SwigClassASTNode.klass, "swapChildren", VALUEFUNC(_wrap_ASTNode_swapChildren), -1);
  rb_define_method(SwigClassASTNode.klass, "unsetUnits", VALUEFUNC(_wrap_ASTNode_unsetUnits), -1);
  rb_define_method(SwigClassASTNode.klass, "getDefinitionURL", VALUEFUNC(_wrap_ASTNode_getDefinitionURL), -1);
  rb_define_method(SwigClassASTNode.klass, "replaceArgument", VALUEFUNC(_wrap_ASTNode_replaceArgument), -1);
  rb_define_method(SwigClassASTNode.klass, "getParentSBMLObject", VALUEFUNC(_wrap_ASTNode_getParentSBMLObject), -1);
  rb_define_method(SwigClassASTNode.klass, "reduceToBinary", VALUEFUNC(_wrap_ASTNode_reduceToBinary), -1);
  rb_define_method(SwigClassASTNode.klass, "isWellFormedASTNode", VALUEFUNC(_wrap_ASTNode_isWellFormedASTNode), -1);
  rb_define_method(SwigClassASTNode.klass, "hasCorrectNumberArguments", VALUEFUNC(_wrap_ASTNode_hasCorrectNumberArguments), -1);
  rb_define_method(SwigClassASTNode.klass, "isBvar", VALUEFUNC(_wrap_ASTNode_isBvar), -1);
  rb_define_method(SwigClassASTNode.klass, "setBvar", VALUEFUNC(_wrap_ASTNode_setBvar), -1);
  rb_define_method(SwigClassASTNode.klass, "getListOfNodes", VALUEFUNC(_wrap_ASTNode_getListOfNodes), -1);
  SwigClassASTNode.mark = 0;
  SwigClassASTNode.destroy = (void (*)(void *)) free_ASTNode;
  SwigClassASTNode.trackObjects = 1;
  rb_define_module_function(mLibSBML, "parseFormula", VALUEFUNC(_wrap_parseFormula), -1);
  rb_define_module_function(mLibSBML, "formulaToString", VALUEFUNC(_wrap_formulaToString), -1);
  
  SwigClassXMLConstructorException.klass = rb_define_class_under(mLibSBML, "XMLConstructorException", rb_eRuntimeError);
  SWIG_TypeClientData(SWIGTYPE_p_XMLConstructorException, (void *) &SwigClassXMLConstructorException);
  rb_define_alloc_func(SwigClassXMLConstructorException.klass, _wrap_XMLConstructorException_allocate);
  rb_define_method(SwigClassXMLConstructorException.klass, "initialize", VALUEFUNC(_wrap_new_XMLConstructorException), -1);
  SwigClassXMLConstructorException.mark = 0;
  SwigClassXMLConstructorException.destroy = (void (*)(void *)) free_XMLConstructorException;
  SwigClassXMLConstructorException.trackObjects = 1;
  
  SwigClassXMLAttributes.klass = rb_define_class_under(mLibSBML, "XMLAttributes", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLAttributes, (void *) &SwigClassXMLAttributes);
  rb_define_alloc_func(SwigClassXMLAttributes.klass, _wrap_XMLAttributes_allocate);
  rb_define_method(SwigClassXMLAttributes.klass, "initialize", VALUEFUNC(_wrap_new_XMLAttributes), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "clone", VALUEFUNC(_wrap_XMLAttributes_clone), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "add", VALUEFUNC(_wrap_XMLAttributes_add), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "removeResource", VALUEFUNC(_wrap_XMLAttributes_removeResource), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "remove", VALUEFUNC(_wrap_XMLAttributes_remove), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "clear", VALUEFUNC(_wrap_XMLAttributes_clear), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getIndex", VALUEFUNC(_wrap_XMLAttributes_getIndex), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getLength", VALUEFUNC(_wrap_XMLAttributes_getLength), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getNumAttributes", VALUEFUNC(_wrap_XMLAttributes_getNumAttributes), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getName", VALUEFUNC(_wrap_XMLAttributes_getName), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getPrefix", VALUEFUNC(_wrap_XMLAttributes_getPrefix), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getPrefixedName", VALUEFUNC(_wrap_XMLAttributes_getPrefixedName), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getURI", VALUEFUNC(_wrap_XMLAttributes_getURI), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "getValue", VALUEFUNC(_wrap_XMLAttributes_getValue), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "hasAttribute", VALUEFUNC(_wrap_XMLAttributes_hasAttribute), -1);
  rb_define_method(SwigClassXMLAttributes.klass, "isEmpty", VALUEFUNC(_wrap_XMLAttributes_isEmpty), -1);
  SwigClassXMLAttributes.mark = 0;
  SwigClassXMLAttributes.destroy = (void (*)(void *)) free_XMLAttributes;
  SwigClassXMLAttributes.trackObjects = 1;
  
  SwigClassXMLNamespaces.klass = rb_define_class_under(mLibSBML, "XMLNamespaces", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLNamespaces, (void *) &SwigClassXMLNamespaces);
  rb_define_alloc_func(SwigClassXMLNamespaces.klass, _wrap_XMLNamespaces_allocate);
  rb_define_method(SwigClassXMLNamespaces.klass, "initialize", VALUEFUNC(_wrap_new_XMLNamespaces), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "clone", VALUEFUNC(_wrap_XMLNamespaces_clone), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "add", VALUEFUNC(_wrap_XMLNamespaces_add), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "remove", VALUEFUNC(_wrap_XMLNamespaces_remove), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "clear", VALUEFUNC(_wrap_XMLNamespaces_clear), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "getIndex", VALUEFUNC(_wrap_XMLNamespaces_getIndex), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "getIndexByPrefix", VALUEFUNC(_wrap_XMLNamespaces_getIndexByPrefix), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "getLength", VALUEFUNC(_wrap_XMLNamespaces_getLength), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "getNumNamespaces", VALUEFUNC(_wrap_XMLNamespaces_getNumNamespaces), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "getPrefix", VALUEFUNC(_wrap_XMLNamespaces_getPrefix), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "getURI", VALUEFUNC(_wrap_XMLNamespaces_getURI), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "isEmpty", VALUEFUNC(_wrap_XMLNamespaces_isEmpty), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "hasURI", VALUEFUNC(_wrap_XMLNamespaces_hasURI), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "hasPrefix", VALUEFUNC(_wrap_XMLNamespaces_hasPrefix), -1);
  rb_define_method(SwigClassXMLNamespaces.klass, "hasNS", VALUEFUNC(_wrap_XMLNamespaces_hasNS), -1);
  SwigClassXMLNamespaces.mark = 0;
  SwigClassXMLNamespaces.destroy = (void (*)(void *)) free_XMLNamespaces;
  SwigClassXMLNamespaces.trackObjects = 1;
  
  SwigClassXMLToken.klass = rb_define_class_under(mLibSBML, "XMLToken", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLToken, (void *) &SwigClassXMLToken);
  rb_define_alloc_func(SwigClassXMLToken.klass, _wrap_XMLToken_allocate);
  rb_define_method(SwigClassXMLToken.klass, "initialize", VALUEFUNC(_wrap_new_XMLToken), -1);
  rb_define_method(SwigClassXMLToken.klass, "clone", VALUEFUNC(_wrap_XMLToken_clone), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttributes", VALUEFUNC(_wrap_XMLToken_getAttributes), -1);
  rb_define_method(SwigClassXMLToken.klass, "setAttributes", VALUEFUNC(_wrap_XMLToken_setAttributes), -1);
  rb_define_method(SwigClassXMLToken.klass, "addAttr", VALUEFUNC(_wrap_XMLToken_addAttr), -1);
  rb_define_method(SwigClassXMLToken.klass, "removeAttr", VALUEFUNC(_wrap_XMLToken_removeAttr), -1);
  rb_define_method(SwigClassXMLToken.klass, "clearAttributes", VALUEFUNC(_wrap_XMLToken_clearAttributes), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttrIndex", VALUEFUNC(_wrap_XMLToken_getAttrIndex), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttributesLength", VALUEFUNC(_wrap_XMLToken_getAttributesLength), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttrName", VALUEFUNC(_wrap_XMLToken_getAttrName), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttrPrefix", VALUEFUNC(_wrap_XMLToken_getAttrPrefix), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttrPrefixedName", VALUEFUNC(_wrap_XMLToken_getAttrPrefixedName), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttrURI", VALUEFUNC(_wrap_XMLToken_getAttrURI), -1);
  rb_define_method(SwigClassXMLToken.klass, "getAttrValue", VALUEFUNC(_wrap_XMLToken_getAttrValue), -1);
  rb_define_method(SwigClassXMLToken.klass, "hasAttr", VALUEFUNC(_wrap_XMLToken_hasAttr), -1);
  rb_define_method(SwigClassXMLToken.klass, "isAttributesEmpty", VALUEFUNC(_wrap_XMLToken_isAttributesEmpty), -1);
  rb_define_method(SwigClassXMLToken.klass, "getNamespaces", VALUEFUNC(_wrap_XMLToken_getNamespaces), -1);
  rb_define_method(SwigClassXMLToken.klass, "setNamespaces", VALUEFUNC(_wrap_XMLToken_setNamespaces), -1);
  rb_define_method(SwigClassXMLToken.klass, "addNamespace", VALUEFUNC(_wrap_XMLToken_addNamespace), -1);
  rb_define_method(SwigClassXMLToken.klass, "removeNamespace", VALUEFUNC(_wrap_XMLToken_removeNamespace), -1);
  rb_define_method(SwigClassXMLToken.klass, "clearNamespaces", VALUEFUNC(_wrap_XMLToken_clearNamespaces), -1);
  rb_define_method(SwigClassXMLToken.klass, "getNamespaceIndex", VALUEFUNC(_wrap_XMLToken_getNamespaceIndex), -1);
  rb_define_method(SwigClassXMLToken.klass, "getNamespaceIndexByPrefix", VALUEFUNC(_wrap_XMLToken_getNamespaceIndexByPrefix), -1);
  rb_define_method(SwigClassXMLToken.klass, "getNamespacesLength", VALUEFUNC(_wrap_XMLToken_getNamespacesLength), -1);
  rb_define_method(SwigClassXMLToken.klass, "getNamespacePrefix", VALUEFUNC(_wrap_XMLToken_getNamespacePrefix), -1);
  rb_define_method(SwigClassXMLToken.klass, "getNamespaceURI", VALUEFUNC(_wrap_XMLToken_getNamespaceURI), -1);
  rb_define_method(SwigClassXMLToken.klass, "isNamespacesEmpty", VALUEFUNC(_wrap_XMLToken_isNamespacesEmpty), -1);
  rb_define_method(SwigClassXMLToken.klass, "hasNamespaceURI", VALUEFUNC(_wrap_XMLToken_hasNamespaceURI), -1);
  rb_define_method(SwigClassXMLToken.klass, "hasNamespacePrefix", VALUEFUNC(_wrap_XMLToken_hasNamespacePrefix), -1);
  rb_define_method(SwigClassXMLToken.klass, "hasNamespaceNS", VALUEFUNC(_wrap_XMLToken_hasNamespaceNS), -1);
  rb_define_method(SwigClassXMLToken.klass, "setTriple", VALUEFUNC(_wrap_XMLToken_setTriple), -1);
  rb_define_method(SwigClassXMLToken.klass, "getName", VALUEFUNC(_wrap_XMLToken_getName), -1);
  rb_define_method(SwigClassXMLToken.klass, "getPrefix", VALUEFUNC(_wrap_XMLToken_getPrefix), -1);
  rb_define_method(SwigClassXMLToken.klass, "getURI", VALUEFUNC(_wrap_XMLToken_getURI), -1);
  rb_define_method(SwigClassXMLToken.klass, "getCharacters", VALUEFUNC(_wrap_XMLToken_getCharacters), -1);
  rb_define_method(SwigClassXMLToken.klass, "append", VALUEFUNC(_wrap_XMLToken_append), -1);
  rb_define_method(SwigClassXMLToken.klass, "getColumn", VALUEFUNC(_wrap_XMLToken_getColumn), -1);
  rb_define_method(SwigClassXMLToken.klass, "getLine", VALUEFUNC(_wrap_XMLToken_getLine), -1);
  rb_define_method(SwigClassXMLToken.klass, "isElement", VALUEFUNC(_wrap_XMLToken_isElement), -1);
  rb_define_method(SwigClassXMLToken.klass, "isEnd", VALUEFUNC(_wrap_XMLToken_isEnd), -1);
  rb_define_method(SwigClassXMLToken.klass, "isEndFor", VALUEFUNC(_wrap_XMLToken_isEndFor), -1);
  rb_define_method(SwigClassXMLToken.klass, "isEOF", VALUEFUNC(_wrap_XMLToken_isEOF), -1);
  rb_define_method(SwigClassXMLToken.klass, "isStart", VALUEFUNC(_wrap_XMLToken_isStart), -1);
  rb_define_method(SwigClassXMLToken.klass, "isText", VALUEFUNC(_wrap_XMLToken_isText), -1);
  rb_define_method(SwigClassXMLToken.klass, "setEnd", VALUEFUNC(_wrap_XMLToken_setEnd), -1);
  rb_define_method(SwigClassXMLToken.klass, "setEOF", VALUEFUNC(_wrap_XMLToken_setEOF), -1);
  rb_define_method(SwigClassXMLToken.klass, "unsetEnd", VALUEFUNC(_wrap_XMLToken_unsetEnd), -1);
  rb_define_method(SwigClassXMLToken.klass, "toString", VALUEFUNC(_wrap_XMLToken_toString), -1);
  SwigClassXMLToken.mark = 0;
  SwigClassXMLToken.destroy = (void (*)(void *)) free_XMLToken;
  SwigClassXMLToken.trackObjects = 1;
  
  SwigClassXMLNode.klass = rb_define_class_under(mLibSBML, "XMLNode", ((swig_class *) SWIGTYPE_p_XMLToken->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_XMLNode, (void *) &SwigClassXMLNode);
  rb_define_alloc_func(SwigClassXMLNode.klass, _wrap_XMLNode_allocate);
  rb_define_method(SwigClassXMLNode.klass, "initialize", VALUEFUNC(_wrap_new_XMLNode), -1);
  rb_define_method(SwigClassXMLNode.klass, "clone", VALUEFUNC(_wrap_XMLNode_clone), -1);
  rb_define_method(SwigClassXMLNode.klass, "addChild", VALUEFUNC(_wrap_XMLNode_addChild), -1);
  rb_define_method(SwigClassXMLNode.klass, "insertChild", VALUEFUNC(_wrap_XMLNode_insertChild), -1);
  rb_define_method(SwigClassXMLNode.klass, "removeChild", VALUEFUNC(_wrap_XMLNode_removeChild), -1);
  rb_define_method(SwigClassXMLNode.klass, "removeChildren", VALUEFUNC(_wrap_XMLNode_removeChildren), -1);
  rb_define_method(SwigClassXMLNode.klass, "getChild", VALUEFUNC(_wrap_XMLNode_getChild), -1);
  rb_define_method(SwigClassXMLNode.klass, "getIndex", VALUEFUNC(_wrap_XMLNode_getIndex), -1);
  rb_define_method(SwigClassXMLNode.klass, "hasChild", VALUEFUNC(_wrap_XMLNode_hasChild), -1);
  rb_define_method(SwigClassXMLNode.klass, "equals", VALUEFUNC(_wrap_XMLNode_equals), -1);
  rb_define_method(SwigClassXMLNode.klass, "getNumChildren", VALUEFUNC(_wrap_XMLNode_getNumChildren), -1);
  rb_define_method(SwigClassXMLNode.klass, "toXMLString", VALUEFUNC(_wrap_XMLNode_toXMLString), -1);
  rb_define_singleton_method(SwigClassXMLNode.klass, "convertXMLNodeToString", VALUEFUNC(_wrap_XMLNode_convertXMLNodeToString), -1);
  rb_define_singleton_method(SwigClassXMLNode.klass, "convertStringToXMLNode", VALUEFUNC(_wrap_XMLNode_convertStringToXMLNode), -1);
  SwigClassXMLNode.mark = 0;
  SwigClassXMLNode.destroy = (void (*)(void *)) free_XMLNode;
  SwigClassXMLNode.trackObjects = 1;
  
  SwigClassXMLTriple.klass = rb_define_class_under(mLibSBML, "XMLTriple", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLTriple, (void *) &SwigClassXMLTriple);
  rb_define_alloc_func(SwigClassXMLTriple.klass, _wrap_XMLTriple_allocate);
  rb_define_method(SwigClassXMLTriple.klass, "initialize", VALUEFUNC(_wrap_new_XMLTriple), -1);
  rb_define_method(SwigClassXMLTriple.klass, "clone", VALUEFUNC(_wrap_XMLTriple_clone), -1);
  rb_define_method(SwigClassXMLTriple.klass, "getName", VALUEFUNC(_wrap_XMLTriple_getName), -1);
  rb_define_method(SwigClassXMLTriple.klass, "getPrefix", VALUEFUNC(_wrap_XMLTriple_getPrefix), -1);
  rb_define_method(SwigClassXMLTriple.klass, "getURI", VALUEFUNC(_wrap_XMLTriple_getURI), -1);
  rb_define_method(SwigClassXMLTriple.klass, "getPrefixedName", VALUEFUNC(_wrap_XMLTriple_getPrefixedName), -1);
  rb_define_method(SwigClassXMLTriple.klass, "isEmpty", VALUEFUNC(_wrap_XMLTriple_isEmpty), -1);
  SwigClassXMLTriple.mark = 0;
  SwigClassXMLTriple.destroy = (void (*)(void *)) free_XMLTriple;
  SwigClassXMLTriple.trackObjects = 1;
  
  SwigClassXMLOutputStream.klass = rb_define_class_under(mLibSBML, "XMLOutputStream", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLOutputStream, (void *) &SwigClassXMLOutputStream);
  rb_define_alloc_func(SwigClassXMLOutputStream.klass, _wrap_XMLOutputStream_allocate);
  rb_define_method(SwigClassXMLOutputStream.klass, "initialize", VALUEFUNC(_wrap_new_XMLOutputStream), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "endElement", VALUEFUNC(_wrap_XMLOutputStream_endElement), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "setAutoIndent", VALUEFUNC(_wrap_XMLOutputStream_setAutoIndent), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "startElement", VALUEFUNC(_wrap_XMLOutputStream_startElement), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "startEndElement", VALUEFUNC(_wrap_XMLOutputStream_startEndElement), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "writeAttribute", VALUEFUNC(_wrap_XMLOutputStream_writeAttribute), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "writeXMLDecl", VALUEFUNC(_wrap_XMLOutputStream_writeXMLDecl), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "writeComment", VALUEFUNC(_wrap_XMLOutputStream_writeComment), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "downIndent", VALUEFUNC(_wrap_XMLOutputStream_downIndent), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "upIndent", VALUEFUNC(_wrap_XMLOutputStream_upIndent), -1);
  rb_define_method(SwigClassXMLOutputStream.klass, "writeAttributeBool", VALUEFUNC(_wrap_XMLOutputStream_writeAttributeBool), -1);
  SwigClassXMLOutputStream.mark = 0;
  SwigClassXMLOutputStream.destroy = (void (*)(void *)) free_XMLOutputStream;
  SwigClassXMLOutputStream.trackObjects = 1;
  
  SwigClassXMLInputStream.klass = rb_define_class_under(mLibSBML, "XMLInputStream", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLInputStream, (void *) &SwigClassXMLInputStream);
  rb_define_alloc_func(SwigClassXMLInputStream.klass, _wrap_XMLInputStream_allocate);
  rb_define_method(SwigClassXMLInputStream.klass, "initialize", VALUEFUNC(_wrap_new_XMLInputStream), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "getEncoding", VALUEFUNC(_wrap_XMLInputStream_getEncoding), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "getVersion", VALUEFUNC(_wrap_XMLInputStream_getVersion), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "getErrorLog", VALUEFUNC(_wrap_XMLInputStream_getErrorLog), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "isEOF", VALUEFUNC(_wrap_XMLInputStream_isEOF), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "isError", VALUEFUNC(_wrap_XMLInputStream_isError), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "isGood", VALUEFUNC(_wrap_XMLInputStream_isGood), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "next", VALUEFUNC(_wrap_XMLInputStream_next), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "peek", VALUEFUNC(_wrap_XMLInputStream_peek), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "skipPastEnd", VALUEFUNC(_wrap_XMLInputStream_skipPastEnd), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "skipText", VALUEFUNC(_wrap_XMLInputStream_skipText), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "setErrorLog", VALUEFUNC(_wrap_XMLInputStream_setErrorLog), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "toString", VALUEFUNC(_wrap_XMLInputStream_toString), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "getSBMLNamespaces", VALUEFUNC(_wrap_XMLInputStream_getSBMLNamespaces), -1);
  rb_define_method(SwigClassXMLInputStream.klass, "setSBMLNamespaces", VALUEFUNC(_wrap_XMLInputStream_setSBMLNamespaces), -1);
  SwigClassXMLInputStream.mark = 0;
  SwigClassXMLInputStream.destroy = (void (*)(void *)) free_XMLInputStream;
  SwigClassXMLInputStream.trackObjects = 1;
  rb_define_const(mLibSBML, "XMLUnknownError", SWIG_From_int(static_cast< int >(XMLUnknownError)));
  rb_define_const(mLibSBML, "XMLOutOfMemory", SWIG_From_int(static_cast< int >(XMLOutOfMemory)));
  rb_define_const(mLibSBML, "XMLFileUnreadable", SWIG_From_int(static_cast< int >(XMLFileUnreadable)));
  rb_define_const(mLibSBML, "XMLFileUnwritable", SWIG_From_int(static_cast< int >(XMLFileUnwritable)));
  rb_define_const(mLibSBML, "XMLFileOperationError", SWIG_From_int(static_cast< int >(XMLFileOperationError)));
  rb_define_const(mLibSBML, "XMLNetworkAccessError", SWIG_From_int(static_cast< int >(XMLNetworkAccessError)));
  rb_define_const(mLibSBML, "InternalXMLParserError", SWIG_From_int(static_cast< int >(InternalXMLParserError)));
  rb_define_const(mLibSBML, "UnrecognizedXMLParserCode", SWIG_From_int(static_cast< int >(UnrecognizedXMLParserCode)));
  rb_define_const(mLibSBML, "XMLTranscoderError", SWIG_From_int(static_cast< int >(XMLTranscoderError)));
  rb_define_const(mLibSBML, "MissingXMLDecl", SWIG_From_int(static_cast< int >(MissingXMLDecl)));
  rb_define_const(mLibSBML, "MissingXMLEncoding", SWIG_From_int(static_cast< int >(MissingXMLEncoding)));
  rb_define_const(mLibSBML, "BadXMLDecl", SWIG_From_int(static_cast< int >(BadXMLDecl)));
  rb_define_const(mLibSBML, "BadXMLDOCTYPE", SWIG_From_int(static_cast< int >(BadXMLDOCTYPE)));
  rb_define_const(mLibSBML, "InvalidCharInXML", SWIG_From_int(static_cast< int >(InvalidCharInXML)));
  rb_define_const(mLibSBML, "BadlyFormedXML", SWIG_From_int(static_cast< int >(BadlyFormedXML)));
  rb_define_const(mLibSBML, "UnclosedXMLToken", SWIG_From_int(static_cast< int >(UnclosedXMLToken)));
  rb_define_const(mLibSBML, "InvalidXMLConstruct", SWIG_From_int(static_cast< int >(InvalidXMLConstruct)));
  rb_define_const(mLibSBML, "XMLTagMismatch", SWIG_From_int(static_cast< int >(XMLTagMismatch)));
  rb_define_const(mLibSBML, "DuplicateXMLAttribute", SWIG_From_int(static_cast< int >(DuplicateXMLAttribute)));
  rb_define_const(mLibSBML, "UndefinedXMLEntity", SWIG_From_int(static_cast< int >(UndefinedXMLEntity)));
  rb_define_const(mLibSBML, "BadProcessingInstruction", SWIG_From_int(static_cast< int >(BadProcessingInstruction)));
  rb_define_const(mLibSBML, "BadXMLPrefix", SWIG_From_int(static_cast< int >(BadXMLPrefix)));
  rb_define_const(mLibSBML, "BadXMLPrefixValue", SWIG_From_int(static_cast< int >(BadXMLPrefixValue)));
  rb_define_const(mLibSBML, "MissingXMLRequiredAttribute", SWIG_From_int(static_cast< int >(MissingXMLRequiredAttribute)));
  rb_define_const(mLibSBML, "XMLAttributeTypeMismatch", SWIG_From_int(static_cast< int >(XMLAttributeTypeMismatch)));
  rb_define_const(mLibSBML, "XMLBadUTF8Content", SWIG_From_int(static_cast< int >(XMLBadUTF8Content)));
  rb_define_const(mLibSBML, "MissingXMLAttributeValue", SWIG_From_int(static_cast< int >(MissingXMLAttributeValue)));
  rb_define_const(mLibSBML, "BadXMLAttributeValue", SWIG_From_int(static_cast< int >(BadXMLAttributeValue)));
  rb_define_const(mLibSBML, "BadXMLAttribute", SWIG_From_int(static_cast< int >(BadXMLAttribute)));
  rb_define_const(mLibSBML, "UnrecognizedXMLElement", SWIG_From_int(static_cast< int >(UnrecognizedXMLElement)));
  rb_define_const(mLibSBML, "BadXMLComment", SWIG_From_int(static_cast< int >(BadXMLComment)));
  rb_define_const(mLibSBML, "BadXMLDeclLocation", SWIG_From_int(static_cast< int >(BadXMLDeclLocation)));
  rb_define_const(mLibSBML, "XMLUnexpectedEOF", SWIG_From_int(static_cast< int >(XMLUnexpectedEOF)));
  rb_define_const(mLibSBML, "BadXMLIDValue", SWIG_From_int(static_cast< int >(BadXMLIDValue)));
  rb_define_const(mLibSBML, "BadXMLIDRef", SWIG_From_int(static_cast< int >(BadXMLIDRef)));
  rb_define_const(mLibSBML, "UninterpretableXMLContent", SWIG_From_int(static_cast< int >(UninterpretableXMLContent)));
  rb_define_const(mLibSBML, "BadXMLDocumentStructure", SWIG_From_int(static_cast< int >(BadXMLDocumentStructure)));
  rb_define_const(mLibSBML, "InvalidAfterXMLContent", SWIG_From_int(static_cast< int >(InvalidAfterXMLContent)));
  rb_define_const(mLibSBML, "XMLExpectedQuotedString", SWIG_From_int(static_cast< int >(XMLExpectedQuotedString)));
  rb_define_const(mLibSBML, "XMLEmptyValueNotPermitted", SWIG_From_int(static_cast< int >(XMLEmptyValueNotPermitted)));
  rb_define_const(mLibSBML, "XMLBadNumber", SWIG_From_int(static_cast< int >(XMLBadNumber)));
  rb_define_const(mLibSBML, "XMLBadColon", SWIG_From_int(static_cast< int >(XMLBadColon)));
  rb_define_const(mLibSBML, "MissingXMLElements", SWIG_From_int(static_cast< int >(MissingXMLElements)));
  rb_define_const(mLibSBML, "XMLContentEmpty", SWIG_From_int(static_cast< int >(XMLContentEmpty)));
  rb_define_const(mLibSBML, "XMLErrorCodesUpperBound", SWIG_From_int(static_cast< int >(XMLErrorCodesUpperBound)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_INTERNAL", SWIG_From_int(static_cast< int >(LIBSBML_CAT_INTERNAL)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SYSTEM", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SYSTEM)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_XML", SWIG_From_int(static_cast< int >(LIBSBML_CAT_XML)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_INFO", SWIG_From_int(static_cast< int >(LIBSBML_SEV_INFO)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_WARNING", SWIG_From_int(static_cast< int >(LIBSBML_SEV_WARNING)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_ERROR", SWIG_From_int(static_cast< int >(LIBSBML_SEV_ERROR)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_FATAL", SWIG_From_int(static_cast< int >(LIBSBML_SEV_FATAL)));
  
  SwigClassXMLError.klass = rb_define_class_under(mLibSBML, "XMLError", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLError, (void *) &SwigClassXMLError);
  rb_define_alloc_func(SwigClassXMLError.klass, _wrap_XMLError_allocate);
  rb_define_method(SwigClassXMLError.klass, "initialize", VALUEFUNC(_wrap_new_XMLError), -1);
  rb_define_method(SwigClassXMLError.klass, "getErrorId", VALUEFUNC(_wrap_XMLError_getErrorId), -1);
  rb_define_method(SwigClassXMLError.klass, "getMessage", VALUEFUNC(_wrap_XMLError_getMessage), -1);
  rb_define_method(SwigClassXMLError.klass, "getShortMessage", VALUEFUNC(_wrap_XMLError_getShortMessage), -1);
  rb_define_method(SwigClassXMLError.klass, "getLine", VALUEFUNC(_wrap_XMLError_getLine), -1);
  rb_define_method(SwigClassXMLError.klass, "getColumn", VALUEFUNC(_wrap_XMLError_getColumn), -1);
  rb_define_method(SwigClassXMLError.klass, "getSeverity", VALUEFUNC(_wrap_XMLError_getSeverity), -1);
  rb_define_method(SwigClassXMLError.klass, "getSeverityAsString", VALUEFUNC(_wrap_XMLError_getSeverityAsString), -1);
  rb_define_method(SwigClassXMLError.klass, "getCategory", VALUEFUNC(_wrap_XMLError_getCategory), -1);
  rb_define_method(SwigClassXMLError.klass, "getCategoryAsString", VALUEFUNC(_wrap_XMLError_getCategoryAsString), -1);
  rb_define_method(SwigClassXMLError.klass, "isInfo", VALUEFUNC(_wrap_XMLError_isInfo), -1);
  rb_define_method(SwigClassXMLError.klass, "isWarning", VALUEFUNC(_wrap_XMLError_isWarning), -1);
  rb_define_method(SwigClassXMLError.klass, "isError", VALUEFUNC(_wrap_XMLError_isError), -1);
  rb_define_method(SwigClassXMLError.klass, "isFatal", VALUEFUNC(_wrap_XMLError_isFatal), -1);
  rb_define_method(SwigClassXMLError.klass, "isInternal", VALUEFUNC(_wrap_XMLError_isInternal), -1);
  rb_define_method(SwigClassXMLError.klass, "isSystem", VALUEFUNC(_wrap_XMLError_isSystem), -1);
  rb_define_method(SwigClassXMLError.klass, "isXML", VALUEFUNC(_wrap_XMLError_isXML), -1);
  rb_define_method(SwigClassXMLError.klass, "setLine", VALUEFUNC(_wrap_XMLError_setLine), -1);
  rb_define_method(SwigClassXMLError.klass, "setColumn", VALUEFUNC(_wrap_XMLError_setColumn), -1);
  rb_define_singleton_method(SwigClassXMLError.klass, "getStandardMessage", VALUEFUNC(_wrap_XMLError_getStandardMessage), -1);
  SwigClassXMLError.mark = 0;
  SwigClassXMLError.destroy = (void (*)(void *)) free_XMLError;
  SwigClassXMLError.trackObjects = 1;
  
  SwigClassXMLErrorLog.klass = rb_define_class_under(mLibSBML, "XMLErrorLog", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_XMLErrorLog, (void *) &SwigClassXMLErrorLog);
  rb_undef_alloc_func(SwigClassXMLErrorLog.klass);
  rb_define_method(SwigClassXMLErrorLog.klass, "getNumErrors", VALUEFUNC(_wrap_XMLErrorLog_getNumErrors), -1);
  rb_define_method(SwigClassXMLErrorLog.klass, "getError", VALUEFUNC(_wrap_XMLErrorLog_getError), -1);
  rb_define_method(SwigClassXMLErrorLog.klass, "clearLog", VALUEFUNC(_wrap_XMLErrorLog_clearLog), -1);
  SwigClassXMLErrorLog.mark = 0;
  SwigClassXMLErrorLog.destroy = (void (*)(void *)) free_XMLErrorLog;
  SwigClassXMLErrorLog.trackObjects = 1;
  
  SwigClassSBMLErrorLog.klass = rb_define_class_under(mLibSBML, "SBMLErrorLog", ((swig_class *) SWIGTYPE_p_XMLErrorLog->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLErrorLog, (void *) &SwigClassSBMLErrorLog);
  rb_undef_alloc_func(SwigClassSBMLErrorLog.klass);
  rb_define_method(SwigClassSBMLErrorLog.klass, "getError", VALUEFUNC(_wrap_SBMLErrorLog_getError), -1);
  rb_define_method(SwigClassSBMLErrorLog.klass, "getNumFailsWithSeverity", VALUEFUNC(_wrap_SBMLErrorLog_getNumFailsWithSeverity), -1);
  SwigClassSBMLErrorLog.mark = 0;
  SwigClassSBMLErrorLog.destroy = (void (*)(void *)) free_SBMLErrorLog;
  SwigClassSBMLErrorLog.trackObjects = 1;
  rb_define_const(mLibSBML, "UnknownError", SWIG_From_int(static_cast< int >(UnknownError)));
  rb_define_const(mLibSBML, "NotUTF8", SWIG_From_int(static_cast< int >(NotUTF8)));
  rb_define_const(mLibSBML, "UnrecognizedElement", SWIG_From_int(static_cast< int >(UnrecognizedElement)));
  rb_define_const(mLibSBML, "NotSchemaConformant", SWIG_From_int(static_cast< int >(NotSchemaConformant)));
  rb_define_const(mLibSBML, "L3NotSchemaConformant", SWIG_From_int(static_cast< int >(L3NotSchemaConformant)));
  rb_define_const(mLibSBML, "InvalidMathElement", SWIG_From_int(static_cast< int >(InvalidMathElement)));
  rb_define_const(mLibSBML, "DisallowedMathMLSymbol", SWIG_From_int(static_cast< int >(DisallowedMathMLSymbol)));
  rb_define_const(mLibSBML, "DisallowedMathMLEncodingUse", SWIG_From_int(static_cast< int >(DisallowedMathMLEncodingUse)));
  rb_define_const(mLibSBML, "DisallowedDefinitionURLUse", SWIG_From_int(static_cast< int >(DisallowedDefinitionURLUse)));
  rb_define_const(mLibSBML, "BadCsymbolDefinitionURLValue", SWIG_From_int(static_cast< int >(BadCsymbolDefinitionURLValue)));
  rb_define_const(mLibSBML, "DisallowedMathTypeAttributeUse", SWIG_From_int(static_cast< int >(DisallowedMathTypeAttributeUse)));
  rb_define_const(mLibSBML, "DisallowedMathTypeAttributeValue", SWIG_From_int(static_cast< int >(DisallowedMathTypeAttributeValue)));
  rb_define_const(mLibSBML, "LambdaOnlyAllowedInFunctionDef", SWIG_From_int(static_cast< int >(LambdaOnlyAllowedInFunctionDef)));
  rb_define_const(mLibSBML, "BooleanOpsNeedBooleanArgs", SWIG_From_int(static_cast< int >(BooleanOpsNeedBooleanArgs)));
  rb_define_const(mLibSBML, "NumericOpsNeedNumericArgs", SWIG_From_int(static_cast< int >(NumericOpsNeedNumericArgs)));
  rb_define_const(mLibSBML, "ArgsToEqNeedSameType", SWIG_From_int(static_cast< int >(ArgsToEqNeedSameType)));
  rb_define_const(mLibSBML, "PiecewiseNeedsConsistentTypes", SWIG_From_int(static_cast< int >(PiecewiseNeedsConsistentTypes)));
  rb_define_const(mLibSBML, "PieceNeedsBoolean", SWIG_From_int(static_cast< int >(PieceNeedsBoolean)));
  rb_define_const(mLibSBML, "ApplyCiMustBeUserFunction", SWIG_From_int(static_cast< int >(ApplyCiMustBeUserFunction)));
  rb_define_const(mLibSBML, "ApplyCiMustBeModelComponent", SWIG_From_int(static_cast< int >(ApplyCiMustBeModelComponent)));
  rb_define_const(mLibSBML, "KineticLawParametersAreLocalOnly", SWIG_From_int(static_cast< int >(KineticLawParametersAreLocalOnly)));
  rb_define_const(mLibSBML, "MathResultMustBeNumeric", SWIG_From_int(static_cast< int >(MathResultMustBeNumeric)));
  rb_define_const(mLibSBML, "OpsNeedCorrectNumberOfArgs", SWIG_From_int(static_cast< int >(OpsNeedCorrectNumberOfArgs)));
  rb_define_const(mLibSBML, "InvalidNoArgsPassedToFunctionDef", SWIG_From_int(static_cast< int >(InvalidNoArgsPassedToFunctionDef)));
  rb_define_const(mLibSBML, "DisallowedMathUnitsUse", SWIG_From_int(static_cast< int >(DisallowedMathUnitsUse)));
  rb_define_const(mLibSBML, "InvalidUnitsValue", SWIG_From_int(static_cast< int >(InvalidUnitsValue)));
  rb_define_const(mLibSBML, "DuplicateComponentId", SWIG_From_int(static_cast< int >(DuplicateComponentId)));
  rb_define_const(mLibSBML, "DuplicateUnitDefinitionId", SWIG_From_int(static_cast< int >(DuplicateUnitDefinitionId)));
  rb_define_const(mLibSBML, "DuplicateLocalParameterId", SWIG_From_int(static_cast< int >(DuplicateLocalParameterId)));
  rb_define_const(mLibSBML, "MultipleAssignmentOrRateRules", SWIG_From_int(static_cast< int >(MultipleAssignmentOrRateRules)));
  rb_define_const(mLibSBML, "MultipleEventAssignmentsForId", SWIG_From_int(static_cast< int >(MultipleEventAssignmentsForId)));
  rb_define_const(mLibSBML, "EventAndAssignmentRuleForId", SWIG_From_int(static_cast< int >(EventAndAssignmentRuleForId)));
  rb_define_const(mLibSBML, "DuplicateMetaId", SWIG_From_int(static_cast< int >(DuplicateMetaId)));
  rb_define_const(mLibSBML, "InvalidSBOTermSyntax", SWIG_From_int(static_cast< int >(InvalidSBOTermSyntax)));
  rb_define_const(mLibSBML, "InvalidMetaidSyntax", SWIG_From_int(static_cast< int >(InvalidMetaidSyntax)));
  rb_define_const(mLibSBML, "InvalidIdSyntax", SWIG_From_int(static_cast< int >(InvalidIdSyntax)));
  rb_define_const(mLibSBML, "InvalidUnitIdSyntax", SWIG_From_int(static_cast< int >(InvalidUnitIdSyntax)));
  rb_define_const(mLibSBML, "InvalidNameSyntax", SWIG_From_int(static_cast< int >(InvalidNameSyntax)));
  rb_define_const(mLibSBML, "MissingAnnotationNamespace", SWIG_From_int(static_cast< int >(MissingAnnotationNamespace)));
  rb_define_const(mLibSBML, "DuplicateAnnotationNamespaces", SWIG_From_int(static_cast< int >(DuplicateAnnotationNamespaces)));
  rb_define_const(mLibSBML, "SBMLNamespaceInAnnotation", SWIG_From_int(static_cast< int >(SBMLNamespaceInAnnotation)));
  rb_define_const(mLibSBML, "MultipleAnnotations", SWIG_From_int(static_cast< int >(MultipleAnnotations)));
  rb_define_const(mLibSBML, "InconsistentArgUnits", SWIG_From_int(static_cast< int >(InconsistentArgUnits)));
  rb_define_const(mLibSBML, "InconsistentKineticLawUnitsL3", SWIG_From_int(static_cast< int >(InconsistentKineticLawUnitsL3)));
  rb_define_const(mLibSBML, "AssignRuleCompartmentMismatch", SWIG_From_int(static_cast< int >(AssignRuleCompartmentMismatch)));
  rb_define_const(mLibSBML, "AssignRuleSpeciesMismatch", SWIG_From_int(static_cast< int >(AssignRuleSpeciesMismatch)));
  rb_define_const(mLibSBML, "AssignRuleParameterMismatch", SWIG_From_int(static_cast< int >(AssignRuleParameterMismatch)));
  rb_define_const(mLibSBML, "AssignRuleStoichiometryMismatch", SWIG_From_int(static_cast< int >(AssignRuleStoichiometryMismatch)));
  rb_define_const(mLibSBML, "InitAssignCompartmenMismatch", SWIG_From_int(static_cast< int >(InitAssignCompartmenMismatch)));
  rb_define_const(mLibSBML, "InitAssignSpeciesMismatch", SWIG_From_int(static_cast< int >(InitAssignSpeciesMismatch)));
  rb_define_const(mLibSBML, "InitAssignParameterMismatch", SWIG_From_int(static_cast< int >(InitAssignParameterMismatch)));
  rb_define_const(mLibSBML, "InitAssignStoichiometryMismatch", SWIG_From_int(static_cast< int >(InitAssignStoichiometryMismatch)));
  rb_define_const(mLibSBML, "RateRuleCompartmentMismatch", SWIG_From_int(static_cast< int >(RateRuleCompartmentMismatch)));
  rb_define_const(mLibSBML, "RateRuleSpeciesMismatch", SWIG_From_int(static_cast< int >(RateRuleSpeciesMismatch)));
  rb_define_const(mLibSBML, "RateRuleParameterMismatch", SWIG_From_int(static_cast< int >(RateRuleParameterMismatch)));
  rb_define_const(mLibSBML, "RateRuleStoichiometryMismatch", SWIG_From_int(static_cast< int >(RateRuleStoichiometryMismatch)));
  rb_define_const(mLibSBML, "KineticLawNotSubstancePerTime", SWIG_From_int(static_cast< int >(KineticLawNotSubstancePerTime)));
  rb_define_const(mLibSBML, "SpeciesInvalidExtentUnits", SWIG_From_int(static_cast< int >(SpeciesInvalidExtentUnits)));
  rb_define_const(mLibSBML, "DelayUnitsNotTime", SWIG_From_int(static_cast< int >(DelayUnitsNotTime)));
  rb_define_const(mLibSBML, "EventAssignCompartmentMismatch", SWIG_From_int(static_cast< int >(EventAssignCompartmentMismatch)));
  rb_define_const(mLibSBML, "EventAssignSpeciesMismatch", SWIG_From_int(static_cast< int >(EventAssignSpeciesMismatch)));
  rb_define_const(mLibSBML, "EventAssignParameterMismatch", SWIG_From_int(static_cast< int >(EventAssignParameterMismatch)));
  rb_define_const(mLibSBML, "EventAssignStoichiometryMismatch", SWIG_From_int(static_cast< int >(EventAssignStoichiometryMismatch)));
  rb_define_const(mLibSBML, "PriorityUnitsNotDimensionless", SWIG_From_int(static_cast< int >(PriorityUnitsNotDimensionless)));
  rb_define_const(mLibSBML, "OverdeterminedSystem", SWIG_From_int(static_cast< int >(OverdeterminedSystem)));
  rb_define_const(mLibSBML, "InvalidModelSBOTerm", SWIG_From_int(static_cast< int >(InvalidModelSBOTerm)));
  rb_define_const(mLibSBML, "InvalidFunctionDefSBOTerm", SWIG_From_int(static_cast< int >(InvalidFunctionDefSBOTerm)));
  rb_define_const(mLibSBML, "InvalidParameterSBOTerm", SWIG_From_int(static_cast< int >(InvalidParameterSBOTerm)));
  rb_define_const(mLibSBML, "InvalidInitAssignSBOTerm", SWIG_From_int(static_cast< int >(InvalidInitAssignSBOTerm)));
  rb_define_const(mLibSBML, "InvalidRuleSBOTerm", SWIG_From_int(static_cast< int >(InvalidRuleSBOTerm)));
  rb_define_const(mLibSBML, "InvalidConstraintSBOTerm", SWIG_From_int(static_cast< int >(InvalidConstraintSBOTerm)));
  rb_define_const(mLibSBML, "InvalidReactionSBOTerm", SWIG_From_int(static_cast< int >(InvalidReactionSBOTerm)));
  rb_define_const(mLibSBML, "InvalidSpeciesReferenceSBOTerm", SWIG_From_int(static_cast< int >(InvalidSpeciesReferenceSBOTerm)));
  rb_define_const(mLibSBML, "InvalidKineticLawSBOTerm", SWIG_From_int(static_cast< int >(InvalidKineticLawSBOTerm)));
  rb_define_const(mLibSBML, "InvalidEventSBOTerm", SWIG_From_int(static_cast< int >(InvalidEventSBOTerm)));
  rb_define_const(mLibSBML, "InvalidEventAssignmentSBOTerm", SWIG_From_int(static_cast< int >(InvalidEventAssignmentSBOTerm)));
  rb_define_const(mLibSBML, "InvalidCompartmentSBOTerm", SWIG_From_int(static_cast< int >(InvalidCompartmentSBOTerm)));
  rb_define_const(mLibSBML, "InvalidSpeciesSBOTerm", SWIG_From_int(static_cast< int >(InvalidSpeciesSBOTerm)));
  rb_define_const(mLibSBML, "InvalidCompartmentTypeSBOTerm", SWIG_From_int(static_cast< int >(InvalidCompartmentTypeSBOTerm)));
  rb_define_const(mLibSBML, "InvalidSpeciesTypeSBOTerm", SWIG_From_int(static_cast< int >(InvalidSpeciesTypeSBOTerm)));
  rb_define_const(mLibSBML, "InvalidTriggerSBOTerm", SWIG_From_int(static_cast< int >(InvalidTriggerSBOTerm)));
  rb_define_const(mLibSBML, "InvalidDelaySBOTerm", SWIG_From_int(static_cast< int >(InvalidDelaySBOTerm)));
  rb_define_const(mLibSBML, "NotesNotInXHTMLNamespace", SWIG_From_int(static_cast< int >(NotesNotInXHTMLNamespace)));
  rb_define_const(mLibSBML, "NotesContainsXMLDecl", SWIG_From_int(static_cast< int >(NotesContainsXMLDecl)));
  rb_define_const(mLibSBML, "NotesContainsDOCTYPE", SWIG_From_int(static_cast< int >(NotesContainsDOCTYPE)));
  rb_define_const(mLibSBML, "InvalidNotesContent", SWIG_From_int(static_cast< int >(InvalidNotesContent)));
  rb_define_const(mLibSBML, "OnlyOneNotesElementAllowed", SWIG_From_int(static_cast< int >(OnlyOneNotesElementAllowed)));
  rb_define_const(mLibSBML, "InvalidNamespaceOnSBML", SWIG_From_int(static_cast< int >(InvalidNamespaceOnSBML)));
  rb_define_const(mLibSBML, "MissingOrInconsistentLevel", SWIG_From_int(static_cast< int >(MissingOrInconsistentLevel)));
  rb_define_const(mLibSBML, "MissingOrInconsistentVersion", SWIG_From_int(static_cast< int >(MissingOrInconsistentVersion)));
  rb_define_const(mLibSBML, "PackageNSMustMatch", SWIG_From_int(static_cast< int >(PackageNSMustMatch)));
  rb_define_const(mLibSBML, "LevelPositiveInteger", SWIG_From_int(static_cast< int >(LevelPositiveInteger)));
  rb_define_const(mLibSBML, "VersionPositiveInteger", SWIG_From_int(static_cast< int >(VersionPositiveInteger)));
  rb_define_const(mLibSBML, "AllowedAttributesOnSBML", SWIG_From_int(static_cast< int >(AllowedAttributesOnSBML)));
  rb_define_const(mLibSBML, "MissingModel", SWIG_From_int(static_cast< int >(MissingModel)));
  rb_define_const(mLibSBML, "IncorrectOrderInModel", SWIG_From_int(static_cast< int >(IncorrectOrderInModel)));
  rb_define_const(mLibSBML, "EmptyListElement", SWIG_From_int(static_cast< int >(EmptyListElement)));
  rb_define_const(mLibSBML, "NeedCompartmentIfHaveSpecies", SWIG_From_int(static_cast< int >(NeedCompartmentIfHaveSpecies)));
  rb_define_const(mLibSBML, "OneOfEachListOf", SWIG_From_int(static_cast< int >(OneOfEachListOf)));
  rb_define_const(mLibSBML, "OnlyFuncDefsInListOfFuncDefs", SWIG_From_int(static_cast< int >(OnlyFuncDefsInListOfFuncDefs)));
  rb_define_const(mLibSBML, "OnlyUnitDefsInListOfUnitDefs", SWIG_From_int(static_cast< int >(OnlyUnitDefsInListOfUnitDefs)));
  rb_define_const(mLibSBML, "OnlyCompartmentsInListOfCompartments", SWIG_From_int(static_cast< int >(OnlyCompartmentsInListOfCompartments)));
  rb_define_const(mLibSBML, "OnlySpeciesInListOfSpecies", SWIG_From_int(static_cast< int >(OnlySpeciesInListOfSpecies)));
  rb_define_const(mLibSBML, "OnlyParametersInListOfParameters", SWIG_From_int(static_cast< int >(OnlyParametersInListOfParameters)));
  rb_define_const(mLibSBML, "OnlyInitAssignsInListOfInitAssigns", SWIG_From_int(static_cast< int >(OnlyInitAssignsInListOfInitAssigns)));
  rb_define_const(mLibSBML, "OnlyRulesInListOfRules", SWIG_From_int(static_cast< int >(OnlyRulesInListOfRules)));
  rb_define_const(mLibSBML, "OnlyConstraintsInListOfConstraints", SWIG_From_int(static_cast< int >(OnlyConstraintsInListOfConstraints)));
  rb_define_const(mLibSBML, "OnlyReactionsInListOfReactions", SWIG_From_int(static_cast< int >(OnlyReactionsInListOfReactions)));
  rb_define_const(mLibSBML, "OnlyEventsInListOfEvents", SWIG_From_int(static_cast< int >(OnlyEventsInListOfEvents)));
  rb_define_const(mLibSBML, "L3ConversionFactorOnModel", SWIG_From_int(static_cast< int >(L3ConversionFactorOnModel)));
  rb_define_const(mLibSBML, "L3TimeUnitsOnModel", SWIG_From_int(static_cast< int >(L3TimeUnitsOnModel)));
  rb_define_const(mLibSBML, "L3VolumeUnitsOnModel", SWIG_From_int(static_cast< int >(L3VolumeUnitsOnModel)));
  rb_define_const(mLibSBML, "L3AreaUnitsOnModel", SWIG_From_int(static_cast< int >(L3AreaUnitsOnModel)));
  rb_define_const(mLibSBML, "L3LengthUnitsOnModel", SWIG_From_int(static_cast< int >(L3LengthUnitsOnModel)));
  rb_define_const(mLibSBML, "L3ExtentUnitsOnModel", SWIG_From_int(static_cast< int >(L3ExtentUnitsOnModel)));
  rb_define_const(mLibSBML, "AllowedAttributesOnModel", SWIG_From_int(static_cast< int >(AllowedAttributesOnModel)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfFuncs", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfFuncs)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfUnitDefs", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfUnitDefs)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfComps", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfComps)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfSpecies", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfSpecies)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfParams", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfParams)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfInitAssign", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfInitAssign)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfRules", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfRules)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfConstraints", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfConstraints)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfReactions", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfReactions)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfEvents", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfEvents)));
  rb_define_const(mLibSBML, "FunctionDefMathNotLambda", SWIG_From_int(static_cast< int >(FunctionDefMathNotLambda)));
  rb_define_const(mLibSBML, "InvalidApplyCiInLambda", SWIG_From_int(static_cast< int >(InvalidApplyCiInLambda)));
  rb_define_const(mLibSBML, "RecursiveFunctionDefinition", SWIG_From_int(static_cast< int >(RecursiveFunctionDefinition)));
  rb_define_const(mLibSBML, "InvalidCiInLambda", SWIG_From_int(static_cast< int >(InvalidCiInLambda)));
  rb_define_const(mLibSBML, "InvalidFunctionDefReturnType", SWIG_From_int(static_cast< int >(InvalidFunctionDefReturnType)));
  rb_define_const(mLibSBML, "OneMathElementPerFunc", SWIG_From_int(static_cast< int >(OneMathElementPerFunc)));
  rb_define_const(mLibSBML, "AllowedAttributesOnFunc", SWIG_From_int(static_cast< int >(AllowedAttributesOnFunc)));
  rb_define_const(mLibSBML, "InvalidUnitDefId", SWIG_From_int(static_cast< int >(InvalidUnitDefId)));
  rb_define_const(mLibSBML, "InvalidSubstanceRedefinition", SWIG_From_int(static_cast< int >(InvalidSubstanceRedefinition)));
  rb_define_const(mLibSBML, "InvalidLengthRedefinition", SWIG_From_int(static_cast< int >(InvalidLengthRedefinition)));
  rb_define_const(mLibSBML, "InvalidAreaRedefinition", SWIG_From_int(static_cast< int >(InvalidAreaRedefinition)));
  rb_define_const(mLibSBML, "InvalidTimeRedefinition", SWIG_From_int(static_cast< int >(InvalidTimeRedefinition)));
  rb_define_const(mLibSBML, "InvalidVolumeRedefinition", SWIG_From_int(static_cast< int >(InvalidVolumeRedefinition)));
  rb_define_const(mLibSBML, "VolumeLitreDefExponentNotOne", SWIG_From_int(static_cast< int >(VolumeLitreDefExponentNotOne)));
  rb_define_const(mLibSBML, "VolumeMetreDefExponentNot3", SWIG_From_int(static_cast< int >(VolumeMetreDefExponentNot3)));
  rb_define_const(mLibSBML, "EmptyListOfUnits", SWIG_From_int(static_cast< int >(EmptyListOfUnits)));
  rb_define_const(mLibSBML, "InvalidUnitKind", SWIG_From_int(static_cast< int >(InvalidUnitKind)));
  rb_define_const(mLibSBML, "OffsetNoLongerValid", SWIG_From_int(static_cast< int >(OffsetNoLongerValid)));
  rb_define_const(mLibSBML, "CelsiusNoLongerValid", SWIG_From_int(static_cast< int >(CelsiusNoLongerValid)));
  rb_define_const(mLibSBML, "EmptyUnitListElement", SWIG_From_int(static_cast< int >(EmptyUnitListElement)));
  rb_define_const(mLibSBML, "OneListOfUnitsPerUnitDef", SWIG_From_int(static_cast< int >(OneListOfUnitsPerUnitDef)));
  rb_define_const(mLibSBML, "OnlyUnitsInListOfUnits", SWIG_From_int(static_cast< int >(OnlyUnitsInListOfUnits)));
  rb_define_const(mLibSBML, "AllowedAttributesOnUnitDefinition", SWIG_From_int(static_cast< int >(AllowedAttributesOnUnitDefinition)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfUnits", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfUnits)));
  rb_define_const(mLibSBML, "AllowedAttributesOnUnit", SWIG_From_int(static_cast< int >(AllowedAttributesOnUnit)));
  rb_define_const(mLibSBML, "ZeroDimensionalCompartmentSize", SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentSize)));
  rb_define_const(mLibSBML, "ZeroDimensionalCompartmentUnits", SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentUnits)));
  rb_define_const(mLibSBML, "ZeroDimensionalCompartmentConst", SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentConst)));
  rb_define_const(mLibSBML, "UndefinedOutsideCompartment", SWIG_From_int(static_cast< int >(UndefinedOutsideCompartment)));
  rb_define_const(mLibSBML, "RecursiveCompartmentContainment", SWIG_From_int(static_cast< int >(RecursiveCompartmentContainment)));
  rb_define_const(mLibSBML, "ZeroDCompartmentContainment", SWIG_From_int(static_cast< int >(ZeroDCompartmentContainment)));
  rb_define_const(mLibSBML, "Invalid1DCompartmentUnits", SWIG_From_int(static_cast< int >(Invalid1DCompartmentUnits)));
  rb_define_const(mLibSBML, "Invalid2DCompartmentUnits", SWIG_From_int(static_cast< int >(Invalid2DCompartmentUnits)));
  rb_define_const(mLibSBML, "Invalid3DCompartmentUnits", SWIG_From_int(static_cast< int >(Invalid3DCompartmentUnits)));
  rb_define_const(mLibSBML, "InvalidCompartmentTypeRef", SWIG_From_int(static_cast< int >(InvalidCompartmentTypeRef)));
  rb_define_const(mLibSBML, "OneDimensionalCompartmentUnits", SWIG_From_int(static_cast< int >(OneDimensionalCompartmentUnits)));
  rb_define_const(mLibSBML, "TwoDimensionalCompartmentUnits", SWIG_From_int(static_cast< int >(TwoDimensionalCompartmentUnits)));
  rb_define_const(mLibSBML, "ThreeDimensionalCompartmentUnits", SWIG_From_int(static_cast< int >(ThreeDimensionalCompartmentUnits)));
  rb_define_const(mLibSBML, "AllowedAttributesOnCompartment", SWIG_From_int(static_cast< int >(AllowedAttributesOnCompartment)));
  rb_define_const(mLibSBML, "NoUnitsOnCompartment", SWIG_From_int(static_cast< int >(NoUnitsOnCompartment)));
  rb_define_const(mLibSBML, "InvalidSpeciesCompartmentRef", SWIG_From_int(static_cast< int >(InvalidSpeciesCompartmentRef)));
  rb_define_const(mLibSBML, "HasOnlySubsNoSpatialUnits", SWIG_From_int(static_cast< int >(HasOnlySubsNoSpatialUnits)));
  rb_define_const(mLibSBML, "NoSpatialUnitsInZeroD", SWIG_From_int(static_cast< int >(NoSpatialUnitsInZeroD)));
  rb_define_const(mLibSBML, "NoConcentrationInZeroD", SWIG_From_int(static_cast< int >(NoConcentrationInZeroD)));
  rb_define_const(mLibSBML, "SpatialUnitsInOneD", SWIG_From_int(static_cast< int >(SpatialUnitsInOneD)));
  rb_define_const(mLibSBML, "SpatialUnitsInTwoD", SWIG_From_int(static_cast< int >(SpatialUnitsInTwoD)));
  rb_define_const(mLibSBML, "SpatialUnitsInThreeD", SWIG_From_int(static_cast< int >(SpatialUnitsInThreeD)));
  rb_define_const(mLibSBML, "InvalidSpeciesSusbstanceUnits", SWIG_From_int(static_cast< int >(InvalidSpeciesSusbstanceUnits)));
  rb_define_const(mLibSBML, "BothAmountAndConcentrationSet", SWIG_From_int(static_cast< int >(BothAmountAndConcentrationSet)));
  rb_define_const(mLibSBML, "NonBoundarySpeciesAssignedAndUsed", SWIG_From_int(static_cast< int >(NonBoundarySpeciesAssignedAndUsed)));
  rb_define_const(mLibSBML, "NonConstantSpeciesUsed", SWIG_From_int(static_cast< int >(NonConstantSpeciesUsed)));
  rb_define_const(mLibSBML, "InvalidSpeciesTypeRef", SWIG_From_int(static_cast< int >(InvalidSpeciesTypeRef)));
  rb_define_const(mLibSBML, "MultSpeciesSameTypeInCompartment", SWIG_From_int(static_cast< int >(MultSpeciesSameTypeInCompartment)));
  rb_define_const(mLibSBML, "MissingSpeciesCompartment", SWIG_From_int(static_cast< int >(MissingSpeciesCompartment)));
  rb_define_const(mLibSBML, "SpatialSizeUnitsRemoved", SWIG_From_int(static_cast< int >(SpatialSizeUnitsRemoved)));
  rb_define_const(mLibSBML, "SubstanceUnitsOnSpecies", SWIG_From_int(static_cast< int >(SubstanceUnitsOnSpecies)));
  rb_define_const(mLibSBML, "ConversionFactorOnSpecies", SWIG_From_int(static_cast< int >(ConversionFactorOnSpecies)));
  rb_define_const(mLibSBML, "AllowedAttributesOnSpecies", SWIG_From_int(static_cast< int >(AllowedAttributesOnSpecies)));
  rb_define_const(mLibSBML, "InvalidParameterUnits", SWIG_From_int(static_cast< int >(InvalidParameterUnits)));
  rb_define_const(mLibSBML, "ParameterUnits", SWIG_From_int(static_cast< int >(ParameterUnits)));
  rb_define_const(mLibSBML, "ConversionFactorMustConstant", SWIG_From_int(static_cast< int >(ConversionFactorMustConstant)));
  rb_define_const(mLibSBML, "AllowedAttributesOnParameter", SWIG_From_int(static_cast< int >(AllowedAttributesOnParameter)));
  rb_define_const(mLibSBML, "InvalidInitAssignSymbol", SWIG_From_int(static_cast< int >(InvalidInitAssignSymbol)));
  rb_define_const(mLibSBML, "MultipleInitAssignments", SWIG_From_int(static_cast< int >(MultipleInitAssignments)));
  rb_define_const(mLibSBML, "InitAssignmentAndRuleForSameId", SWIG_From_int(static_cast< int >(InitAssignmentAndRuleForSameId)));
  rb_define_const(mLibSBML, "OneMathElementPerInitialAssign", SWIG_From_int(static_cast< int >(OneMathElementPerInitialAssign)));
  rb_define_const(mLibSBML, "AllowedAttributesOnInitialAssign", SWIG_From_int(static_cast< int >(AllowedAttributesOnInitialAssign)));
  rb_define_const(mLibSBML, "InvalidAssignRuleVariable", SWIG_From_int(static_cast< int >(InvalidAssignRuleVariable)));
  rb_define_const(mLibSBML, "InvalidRateRuleVariable", SWIG_From_int(static_cast< int >(InvalidRateRuleVariable)));
  rb_define_const(mLibSBML, "AssignmentToConstantEntity", SWIG_From_int(static_cast< int >(AssignmentToConstantEntity)));
  rb_define_const(mLibSBML, "RateRuleForConstantEntity", SWIG_From_int(static_cast< int >(RateRuleForConstantEntity)));
  rb_define_const(mLibSBML, "RepeatedRule10304", SWIG_From_int(static_cast< int >(RepeatedRule10304)));
  rb_define_const(mLibSBML, "CircularRuleDependency", SWIG_From_int(static_cast< int >(CircularRuleDependency)));
  rb_define_const(mLibSBML, "OneMathElementPerRule", SWIG_From_int(static_cast< int >(OneMathElementPerRule)));
  rb_define_const(mLibSBML, "AllowedAttributesOnAssignRule", SWIG_From_int(static_cast< int >(AllowedAttributesOnAssignRule)));
  rb_define_const(mLibSBML, "AllowedAttributesOnRateRule", SWIG_From_int(static_cast< int >(AllowedAttributesOnRateRule)));
  rb_define_const(mLibSBML, "AllowedAttributesOnAlgRule", SWIG_From_int(static_cast< int >(AllowedAttributesOnAlgRule)));
  rb_define_const(mLibSBML, "ConstraintMathNotBoolean", SWIG_From_int(static_cast< int >(ConstraintMathNotBoolean)));
  rb_define_const(mLibSBML, "IncorrectOrderInConstraint", SWIG_From_int(static_cast< int >(IncorrectOrderInConstraint)));
  rb_define_const(mLibSBML, "ConstraintNotInXHTMLNamespace", SWIG_From_int(static_cast< int >(ConstraintNotInXHTMLNamespace)));
  rb_define_const(mLibSBML, "ConstraintContainsXMLDecl", SWIG_From_int(static_cast< int >(ConstraintContainsXMLDecl)));
  rb_define_const(mLibSBML, "ConstraintContainsDOCTYPE", SWIG_From_int(static_cast< int >(ConstraintContainsDOCTYPE)));
  rb_define_const(mLibSBML, "InvalidConstraintContent", SWIG_From_int(static_cast< int >(InvalidConstraintContent)));
  rb_define_const(mLibSBML, "OneMathElementPerConstraint", SWIG_From_int(static_cast< int >(OneMathElementPerConstraint)));
  rb_define_const(mLibSBML, "OneMessageElementPerConstraint", SWIG_From_int(static_cast< int >(OneMessageElementPerConstraint)));
  rb_define_const(mLibSBML, "AllowedAttributesOnConstraint", SWIG_From_int(static_cast< int >(AllowedAttributesOnConstraint)));
  rb_define_const(mLibSBML, "NoReactantsOrProducts", SWIG_From_int(static_cast< int >(NoReactantsOrProducts)));
  rb_define_const(mLibSBML, "IncorrectOrderInReaction", SWIG_From_int(static_cast< int >(IncorrectOrderInReaction)));
  rb_define_const(mLibSBML, "EmptyListInReaction", SWIG_From_int(static_cast< int >(EmptyListInReaction)));
  rb_define_const(mLibSBML, "InvalidReactantsProductsList", SWIG_From_int(static_cast< int >(InvalidReactantsProductsList)));
  rb_define_const(mLibSBML, "InvalidModifiersList", SWIG_From_int(static_cast< int >(InvalidModifiersList)));
  rb_define_const(mLibSBML, "OneSubElementPerReaction", SWIG_From_int(static_cast< int >(OneSubElementPerReaction)));
  rb_define_const(mLibSBML, "CompartmentOnReaction", SWIG_From_int(static_cast< int >(CompartmentOnReaction)));
  rb_define_const(mLibSBML, "AllowedAttributesOnReaction", SWIG_From_int(static_cast< int >(AllowedAttributesOnReaction)));
  rb_define_const(mLibSBML, "InvalidSpeciesReference", SWIG_From_int(static_cast< int >(InvalidSpeciesReference)));
  rb_define_const(mLibSBML, "RepeatedRule20611", SWIG_From_int(static_cast< int >(RepeatedRule20611)));
  rb_define_const(mLibSBML, "BothStoichiometryAndMath", SWIG_From_int(static_cast< int >(BothStoichiometryAndMath)));
  rb_define_const(mLibSBML, "AllowedAttributesOnSpeciesReference", SWIG_From_int(static_cast< int >(AllowedAttributesOnSpeciesReference)));
  rb_define_const(mLibSBML, "AllowedAttributesOnModifier", SWIG_From_int(static_cast< int >(AllowedAttributesOnModifier)));
  rb_define_const(mLibSBML, "UndeclaredSpeciesRef", SWIG_From_int(static_cast< int >(UndeclaredSpeciesRef)));
  rb_define_const(mLibSBML, "IncorrectOrderInKineticLaw", SWIG_From_int(static_cast< int >(IncorrectOrderInKineticLaw)));
  rb_define_const(mLibSBML, "EmptyListInKineticLaw", SWIG_From_int(static_cast< int >(EmptyListInKineticLaw)));
  rb_define_const(mLibSBML, "NonConstantLocalParameter", SWIG_From_int(static_cast< int >(NonConstantLocalParameter)));
  rb_define_const(mLibSBML, "SubsUnitsNoLongerValid", SWIG_From_int(static_cast< int >(SubsUnitsNoLongerValid)));
  rb_define_const(mLibSBML, "TimeUnitsNoLongerValid", SWIG_From_int(static_cast< int >(TimeUnitsNoLongerValid)));
  rb_define_const(mLibSBML, "OneListOfPerKineticLaw", SWIG_From_int(static_cast< int >(OneListOfPerKineticLaw)));
  rb_define_const(mLibSBML, "OnlyLocalParamsInListOfLocalParams", SWIG_From_int(static_cast< int >(OnlyLocalParamsInListOfLocalParams)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfLocalParam", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfLocalParam)));
  rb_define_const(mLibSBML, "OneMathPerKineticLaw", SWIG_From_int(static_cast< int >(OneMathPerKineticLaw)));
  rb_define_const(mLibSBML, "UndeclaredSpeciesInStoichMath", SWIG_From_int(static_cast< int >(UndeclaredSpeciesInStoichMath)));
  rb_define_const(mLibSBML, "AllowedAttributesOnKineticLaw", SWIG_From_int(static_cast< int >(AllowedAttributesOnKineticLaw)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfSpeciesRef", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfSpeciesRef)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfMods", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfMods)));
  rb_define_const(mLibSBML, "AllowedAttributesOnLocalParameter", SWIG_From_int(static_cast< int >(AllowedAttributesOnLocalParameter)));
  rb_define_const(mLibSBML, "MissingTriggerInEvent", SWIG_From_int(static_cast< int >(MissingTriggerInEvent)));
  rb_define_const(mLibSBML, "TriggerMathNotBoolean", SWIG_From_int(static_cast< int >(TriggerMathNotBoolean)));
  rb_define_const(mLibSBML, "MissingEventAssignment", SWIG_From_int(static_cast< int >(MissingEventAssignment)));
  rb_define_const(mLibSBML, "TimeUnitsEvent", SWIG_From_int(static_cast< int >(TimeUnitsEvent)));
  rb_define_const(mLibSBML, "IncorrectOrderInEvent", SWIG_From_int(static_cast< int >(IncorrectOrderInEvent)));
  rb_define_const(mLibSBML, "ValuesFromTriggerTimeNeedDelay", SWIG_From_int(static_cast< int >(ValuesFromTriggerTimeNeedDelay)));
  rb_define_const(mLibSBML, "DelayNeedsValuesFromTriggerTime", SWIG_From_int(static_cast< int >(DelayNeedsValuesFromTriggerTime)));
  rb_define_const(mLibSBML, "OneMathPerTrigger", SWIG_From_int(static_cast< int >(OneMathPerTrigger)));
  rb_define_const(mLibSBML, "OneMathPerDelay", SWIG_From_int(static_cast< int >(OneMathPerDelay)));
  rb_define_const(mLibSBML, "InvalidEventAssignmentVariable", SWIG_From_int(static_cast< int >(InvalidEventAssignmentVariable)));
  rb_define_const(mLibSBML, "EventAssignmentForConstantEntity", SWIG_From_int(static_cast< int >(EventAssignmentForConstantEntity)));
  rb_define_const(mLibSBML, "OneMathPerEventAssignment", SWIG_From_int(static_cast< int >(OneMathPerEventAssignment)));
  rb_define_const(mLibSBML, "AllowedAttributesOnEventAssignment", SWIG_From_int(static_cast< int >(AllowedAttributesOnEventAssignment)));
  rb_define_const(mLibSBML, "OnlyOneDelayPerEvent", SWIG_From_int(static_cast< int >(OnlyOneDelayPerEvent)));
  rb_define_const(mLibSBML, "OneListOfEventAssignmentsPerEvent", SWIG_From_int(static_cast< int >(OneListOfEventAssignmentsPerEvent)));
  rb_define_const(mLibSBML, "OnlyEventAssignInListOfEventAssign", SWIG_From_int(static_cast< int >(OnlyEventAssignInListOfEventAssign)));
  rb_define_const(mLibSBML, "AllowedAttributesOnListOfEventAssign", SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfEventAssign)));
  rb_define_const(mLibSBML, "AllowedAttributesOnEvent", SWIG_From_int(static_cast< int >(AllowedAttributesOnEvent)));
  rb_define_const(mLibSBML, "AllowedAttributesOnTrigger", SWIG_From_int(static_cast< int >(AllowedAttributesOnTrigger)));
  rb_define_const(mLibSBML, "AllowedAttributesOnDelay", SWIG_From_int(static_cast< int >(AllowedAttributesOnDelay)));
  rb_define_const(mLibSBML, "PersistentNotBoolean", SWIG_From_int(static_cast< int >(PersistentNotBoolean)));
  rb_define_const(mLibSBML, "InitialValueNotBoolean", SWIG_From_int(static_cast< int >(InitialValueNotBoolean)));
  rb_define_const(mLibSBML, "OnlyOnePriorityPerEvent", SWIG_From_int(static_cast< int >(OnlyOnePriorityPerEvent)));
  rb_define_const(mLibSBML, "OneMathPerPriority", SWIG_From_int(static_cast< int >(OneMathPerPriority)));
  rb_define_const(mLibSBML, "AllowedAttributesOnPriority", SWIG_From_int(static_cast< int >(AllowedAttributesOnPriority)));
  rb_define_const(mLibSBML, "GeneralWarningNotSpecified", SWIG_From_int(static_cast< int >(GeneralWarningNotSpecified)));
  rb_define_const(mLibSBML, "CompartmentShouldHaveSize", SWIG_From_int(static_cast< int >(CompartmentShouldHaveSize)));
  rb_define_const(mLibSBML, "ParameterShouldHaveUnits", SWIG_From_int(static_cast< int >(ParameterShouldHaveUnits)));
  rb_define_const(mLibSBML, "LocalParameterShadowsId", SWIG_From_int(static_cast< int >(LocalParameterShadowsId)));
  rb_define_const(mLibSBML, "LibSBMLAdditionalCodesLowerBound", SWIG_From_int(static_cast< int >(LibSBMLAdditionalCodesLowerBound)));
  rb_define_const(mLibSBML, "CannotConvertToL1V1", SWIG_From_int(static_cast< int >(CannotConvertToL1V1)));
  rb_define_const(mLibSBML, "NoEventsInL1", SWIG_From_int(static_cast< int >(NoEventsInL1)));
  rb_define_const(mLibSBML, "NoFunctionDefinitionsInL1", SWIG_From_int(static_cast< int >(NoFunctionDefinitionsInL1)));
  rb_define_const(mLibSBML, "NoConstraintsInL1", SWIG_From_int(static_cast< int >(NoConstraintsInL1)));
  rb_define_const(mLibSBML, "NoInitialAssignmentsInL1", SWIG_From_int(static_cast< int >(NoInitialAssignmentsInL1)));
  rb_define_const(mLibSBML, "NoSpeciesTypesInL1", SWIG_From_int(static_cast< int >(NoSpeciesTypesInL1)));
  rb_define_const(mLibSBML, "NoCompartmentTypeInL1", SWIG_From_int(static_cast< int >(NoCompartmentTypeInL1)));
  rb_define_const(mLibSBML, "NoNon3DComparmentsInL1", SWIG_From_int(static_cast< int >(NoNon3DComparmentsInL1)));
  rb_define_const(mLibSBML, "NoFancyStoichiometryMathInL1", SWIG_From_int(static_cast< int >(NoFancyStoichiometryMathInL1)));
  rb_define_const(mLibSBML, "NoNonIntegerStoichiometryInL1", SWIG_From_int(static_cast< int >(NoNonIntegerStoichiometryInL1)));
  rb_define_const(mLibSBML, "NoUnitMultipliersOrOffsetsInL1", SWIG_From_int(static_cast< int >(NoUnitMultipliersOrOffsetsInL1)));
  rb_define_const(mLibSBML, "SpeciesCompartmentRequiredInL1", SWIG_From_int(static_cast< int >(SpeciesCompartmentRequiredInL1)));
  rb_define_const(mLibSBML, "NoSpeciesSpatialSizeUnitsInL1", SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL1)));
  rb_define_const(mLibSBML, "NoSBOTermsInL1", SWIG_From_int(static_cast< int >(NoSBOTermsInL1)));
  rb_define_const(mLibSBML, "StrictUnitsRequiredInL1", SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL1)));
  rb_define_const(mLibSBML, "ConversionFactorNotInL1", SWIG_From_int(static_cast< int >(ConversionFactorNotInL1)));
  rb_define_const(mLibSBML, "CompartmentNotOnL1Reaction", SWIG_From_int(static_cast< int >(CompartmentNotOnL1Reaction)));
  rb_define_const(mLibSBML, "ExtentUnitsNotSubstance", SWIG_From_int(static_cast< int >(ExtentUnitsNotSubstance)));
  rb_define_const(mLibSBML, "NoConstraintsInL2v1", SWIG_From_int(static_cast< int >(NoConstraintsInL2v1)));
  rb_define_const(mLibSBML, "NoInitialAssignmentsInL2v1", SWIG_From_int(static_cast< int >(NoInitialAssignmentsInL2v1)));
  rb_define_const(mLibSBML, "NoSpeciesTypeInL2v1", SWIG_From_int(static_cast< int >(NoSpeciesTypeInL2v1)));
  rb_define_const(mLibSBML, "NoCompartmentTypeInL2v1", SWIG_From_int(static_cast< int >(NoCompartmentTypeInL2v1)));
  rb_define_const(mLibSBML, "NoSBOTermsInL2v1", SWIG_From_int(static_cast< int >(NoSBOTermsInL2v1)));
  rb_define_const(mLibSBML, "NoIdOnSpeciesReferenceInL2v1", SWIG_From_int(static_cast< int >(NoIdOnSpeciesReferenceInL2v1)));
  rb_define_const(mLibSBML, "NoDelayedEventAssignmentInL2v1", SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v1)));
  rb_define_const(mLibSBML, "StrictUnitsRequiredInL2v1", SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v1)));
  rb_define_const(mLibSBML, "IntegerSpatialDimensions", SWIG_From_int(static_cast< int >(IntegerSpatialDimensions)));
  rb_define_const(mLibSBML, "StoichiometryMathNotYetSupported", SWIG_From_int(static_cast< int >(StoichiometryMathNotYetSupported)));
  rb_define_const(mLibSBML, "PrioirtyLostFromL3", SWIG_From_int(static_cast< int >(PrioirtyLostFromL3)));
  rb_define_const(mLibSBML, "NonPersistentNotSupported", SWIG_From_int(static_cast< int >(NonPersistentNotSupported)));
  rb_define_const(mLibSBML, "InitialValueFalseEventNotSupported", SWIG_From_int(static_cast< int >(InitialValueFalseEventNotSupported)));
  rb_define_const(mLibSBML, "SBOTermNotUniversalInL2v2", SWIG_From_int(static_cast< int >(SBOTermNotUniversalInL2v2)));
  rb_define_const(mLibSBML, "NoUnitOffsetInL2v2", SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v2)));
  rb_define_const(mLibSBML, "NoKineticLawTimeUnitsInL2v2", SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v2)));
  rb_define_const(mLibSBML, "NoKineticLawSubstanceUnitsInL2v2", SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v2)));
  rb_define_const(mLibSBML, "NoDelayedEventAssignmentInL2v2", SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v2)));
  rb_define_const(mLibSBML, "ModelSBOBranchChangedBeyondL2v2", SWIG_From_int(static_cast< int >(ModelSBOBranchChangedBeyondL2v2)));
  rb_define_const(mLibSBML, "StrictUnitsRequiredInL2v2", SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v2)));
  rb_define_const(mLibSBML, "StrictSBORequiredInL2v2", SWIG_From_int(static_cast< int >(StrictSBORequiredInL2v2)));
  rb_define_const(mLibSBML, "DuplicateAnnotationInvalidInL2v2", SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v2)));
  rb_define_const(mLibSBML, "NoUnitOffsetInL2v3", SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v3)));
  rb_define_const(mLibSBML, "NoKineticLawTimeUnitsInL2v3", SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v3)));
  rb_define_const(mLibSBML, "NoKineticLawSubstanceUnitsInL2v3", SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v3)));
  rb_define_const(mLibSBML, "NoSpeciesSpatialSizeUnitsInL2v3", SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL2v3)));
  rb_define_const(mLibSBML, "NoEventTimeUnitsInL2v3", SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL2v3)));
  rb_define_const(mLibSBML, "NoDelayedEventAssignmentInL2v3", SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v3)));
  rb_define_const(mLibSBML, "ModelSBOBranchChangedBeyondL2v3", SWIG_From_int(static_cast< int >(ModelSBOBranchChangedBeyondL2v3)));
  rb_define_const(mLibSBML, "StrictUnitsRequiredInL2v3", SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v3)));
  rb_define_const(mLibSBML, "StrictSBORequiredInL2v3", SWIG_From_int(static_cast< int >(StrictSBORequiredInL2v3)));
  rb_define_const(mLibSBML, "DuplicateAnnotationInvalidInL2v3", SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v3)));
  rb_define_const(mLibSBML, "NoUnitOffsetInL2v4", SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v4)));
  rb_define_const(mLibSBML, "NoKineticLawTimeUnitsInL2v4", SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v4)));
  rb_define_const(mLibSBML, "NoKineticLawSubstanceUnitsInL2v4", SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v4)));
  rb_define_const(mLibSBML, "NoSpeciesSpatialSizeUnitsInL2v4", SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL2v4)));
  rb_define_const(mLibSBML, "NoEventTimeUnitsInL2v4", SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL2v4)));
  rb_define_const(mLibSBML, "ModelSBOBranchChangedInL2v4", SWIG_From_int(static_cast< int >(ModelSBOBranchChangedInL2v4)));
  rb_define_const(mLibSBML, "DuplicateAnnotationInvalidInL2v4", SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v4)));
  rb_define_const(mLibSBML, "NoSpeciesTypeInL3v1", SWIG_From_int(static_cast< int >(NoSpeciesTypeInL3v1)));
  rb_define_const(mLibSBML, "NoCompartmentTypeInL3v1", SWIG_From_int(static_cast< int >(NoCompartmentTypeInL3v1)));
  rb_define_const(mLibSBML, "NoUnitOffsetInL3v1", SWIG_From_int(static_cast< int >(NoUnitOffsetInL3v1)));
  rb_define_const(mLibSBML, "NoKineticLawTimeUnitsInL3v1", SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL3v1)));
  rb_define_const(mLibSBML, "NoKineticLawSubstanceUnitsInL3v1", SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL3v1)));
  rb_define_const(mLibSBML, "NoSpeciesSpatialSizeUnitsInL3v1", SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL3v1)));
  rb_define_const(mLibSBML, "NoEventTimeUnitsInL3v1", SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL3v1)));
  rb_define_const(mLibSBML, "ModelSBOBranchChangedInL3v1", SWIG_From_int(static_cast< int >(ModelSBOBranchChangedInL3v1)));
  rb_define_const(mLibSBML, "DuplicateAnnotationInvalidInL3v1", SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL3v1)));
  rb_define_const(mLibSBML, "NoCompartmentOutsideInL3v1", SWIG_From_int(static_cast< int >(NoCompartmentOutsideInL3v1)));
  rb_define_const(mLibSBML, "NoStoichiometryMathInL3v1", SWIG_From_int(static_cast< int >(NoStoichiometryMathInL3v1)));
  rb_define_const(mLibSBML, "InvalidSBMLLevelVersion", SWIG_From_int(static_cast< int >(InvalidSBMLLevelVersion)));
  rb_define_const(mLibSBML, "AnnotationNotesNotAllowedLevel1", SWIG_From_int(static_cast< int >(AnnotationNotesNotAllowedLevel1)));
  rb_define_const(mLibSBML, "InvalidRuleOrdering", SWIG_From_int(static_cast< int >(InvalidRuleOrdering)));
  rb_define_const(mLibSBML, "RequiredPackagePresent", SWIG_From_int(static_cast< int >(RequiredPackagePresent)));
  rb_define_const(mLibSBML, "UnrequiredPackagePresent", SWIG_From_int(static_cast< int >(UnrequiredPackagePresent)));
  rb_define_const(mLibSBML, "SubsUnitsAllowedInKL", SWIG_From_int(static_cast< int >(SubsUnitsAllowedInKL)));
  rb_define_const(mLibSBML, "TimeUnitsAllowedInKL", SWIG_From_int(static_cast< int >(TimeUnitsAllowedInKL)));
  rb_define_const(mLibSBML, "FormulaInLevel1KL", SWIG_From_int(static_cast< int >(FormulaInLevel1KL)));
  rb_define_const(mLibSBML, "TimeUnitsRemoved", SWIG_From_int(static_cast< int >(TimeUnitsRemoved)));
  rb_define_const(mLibSBML, "BadMathML", SWIG_From_int(static_cast< int >(BadMathML)));
  rb_define_const(mLibSBML, "FailedMathMLReadOfDouble", SWIG_From_int(static_cast< int >(FailedMathMLReadOfDouble)));
  rb_define_const(mLibSBML, "FailedMathMLReadOfInteger", SWIG_From_int(static_cast< int >(FailedMathMLReadOfInteger)));
  rb_define_const(mLibSBML, "FailedMathMLReadOfExponential", SWIG_From_int(static_cast< int >(FailedMathMLReadOfExponential)));
  rb_define_const(mLibSBML, "FailedMathMLReadOfRational", SWIG_From_int(static_cast< int >(FailedMathMLReadOfRational)));
  rb_define_const(mLibSBML, "BadMathMLNodeType", SWIG_From_int(static_cast< int >(BadMathMLNodeType)));
  rb_define_const(mLibSBML, "NoTimeSymbolInFunctionDef", SWIG_From_int(static_cast< int >(NoTimeSymbolInFunctionDef)));
  rb_define_const(mLibSBML, "NoBodyInFunctionDef", SWIG_From_int(static_cast< int >(NoBodyInFunctionDef)));
  rb_define_const(mLibSBML, "InconsistentArgUnitsWarnings", SWIG_From_int(static_cast< int >(InconsistentArgUnitsWarnings)));
  rb_define_const(mLibSBML, "InconsistentPowerUnitsWarnings", SWIG_From_int(static_cast< int >(InconsistentPowerUnitsWarnings)));
  rb_define_const(mLibSBML, "InconsistentExponUnitsWarnings", SWIG_From_int(static_cast< int >(InconsistentExponUnitsWarnings)));
  rb_define_const(mLibSBML, "UndeclaredUnits", SWIG_From_int(static_cast< int >(UndeclaredUnits)));
  rb_define_const(mLibSBML, "UnrecognisedSBOTerm", SWIG_From_int(static_cast< int >(UnrecognisedSBOTerm)));
  rb_define_const(mLibSBML, "ObseleteSBOTerm", SWIG_From_int(static_cast< int >(ObseleteSBOTerm)));
  rb_define_const(mLibSBML, "IncorrectCompartmentSpatialDimensions", SWIG_From_int(static_cast< int >(IncorrectCompartmentSpatialDimensions)));
  rb_define_const(mLibSBML, "CompartmentTypeNotValidAttribute", SWIG_From_int(static_cast< int >(CompartmentTypeNotValidAttribute)));
  rb_define_const(mLibSBML, "ConstantNotValidAttribute", SWIG_From_int(static_cast< int >(ConstantNotValidAttribute)));
  rb_define_const(mLibSBML, "MetaIdNotValidAttribute", SWIG_From_int(static_cast< int >(MetaIdNotValidAttribute)));
  rb_define_const(mLibSBML, "SBOTermNotValidAttributeBeforeL2V3", SWIG_From_int(static_cast< int >(SBOTermNotValidAttributeBeforeL2V3)));
  rb_define_const(mLibSBML, "InvalidL1CompartmentUnits", SWIG_From_int(static_cast< int >(InvalidL1CompartmentUnits)));
  rb_define_const(mLibSBML, "L1V1CompartmentVolumeReqd", SWIG_From_int(static_cast< int >(L1V1CompartmentVolumeReqd)));
  rb_define_const(mLibSBML, "CompartmentTypeNotValidComponent", SWIG_From_int(static_cast< int >(CompartmentTypeNotValidComponent)));
  rb_define_const(mLibSBML, "ConstraintNotValidComponent", SWIG_From_int(static_cast< int >(ConstraintNotValidComponent)));
  rb_define_const(mLibSBML, "EventNotValidComponent", SWIG_From_int(static_cast< int >(EventNotValidComponent)));
  rb_define_const(mLibSBML, "SBOTermNotValidAttributeBeforeL2V2", SWIG_From_int(static_cast< int >(SBOTermNotValidAttributeBeforeL2V2)));
  rb_define_const(mLibSBML, "FuncDefNotValidComponent", SWIG_From_int(static_cast< int >(FuncDefNotValidComponent)));
  rb_define_const(mLibSBML, "InitialAssignNotValidComponent", SWIG_From_int(static_cast< int >(InitialAssignNotValidComponent)));
  rb_define_const(mLibSBML, "VariableNotValidAttribute", SWIG_From_int(static_cast< int >(VariableNotValidAttribute)));
  rb_define_const(mLibSBML, "UnitsNotValidAttribute", SWIG_From_int(static_cast< int >(UnitsNotValidAttribute)));
  rb_define_const(mLibSBML, "ConstantSpeciesNotValidAttribute", SWIG_From_int(static_cast< int >(ConstantSpeciesNotValidAttribute)));
  rb_define_const(mLibSBML, "SpatialSizeUnitsNotValidAttribute", SWIG_From_int(static_cast< int >(SpatialSizeUnitsNotValidAttribute)));
  rb_define_const(mLibSBML, "SpeciesTypeNotValidAttribute", SWIG_From_int(static_cast< int >(SpeciesTypeNotValidAttribute)));
  rb_define_const(mLibSBML, "HasOnlySubsUnitsNotValidAttribute", SWIG_From_int(static_cast< int >(HasOnlySubsUnitsNotValidAttribute)));
  rb_define_const(mLibSBML, "IdNotValidAttribute", SWIG_From_int(static_cast< int >(IdNotValidAttribute)));
  rb_define_const(mLibSBML, "NameNotValidAttribute", SWIG_From_int(static_cast< int >(NameNotValidAttribute)));
  rb_define_const(mLibSBML, "SpeciesTypeNotValidComponent", SWIG_From_int(static_cast< int >(SpeciesTypeNotValidComponent)));
  rb_define_const(mLibSBML, "StoichiometryMathNotValidComponent", SWIG_From_int(static_cast< int >(StoichiometryMathNotValidComponent)));
  rb_define_const(mLibSBML, "MultiplierNotValidAttribute", SWIG_From_int(static_cast< int >(MultiplierNotValidAttribute)));
  rb_define_const(mLibSBML, "OffsetNotValidAttribute", SWIG_From_int(static_cast< int >(OffsetNotValidAttribute)));
  rb_define_const(mLibSBML, "L3SpatialDimensionsUnset", SWIG_From_int(static_cast< int >(L3SpatialDimensionsUnset)));
  rb_define_const(mLibSBML, "PackageConversionNotSupported", SWIG_From_int(static_cast< int >(PackageConversionNotSupported)));
  rb_define_const(mLibSBML, "InvalidTargetLevelVersion", SWIG_From_int(static_cast< int >(InvalidTargetLevelVersion)));
  rb_define_const(mLibSBML, "L3NotSupported", SWIG_From_int(static_cast< int >(L3NotSupported)));
  rb_define_const(mLibSBML, "SBMLCodesUpperBound", SWIG_From_int(static_cast< int >(SBMLCodesUpperBound)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML_L1_COMPAT", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L1_COMPAT)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML_L2V1_COMPAT", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V1_COMPAT)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML_L2V2_COMPAT", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V2_COMPAT)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_GENERAL_CONSISTENCY", SWIG_From_int(static_cast< int >(LIBSBML_CAT_GENERAL_CONSISTENCY)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_IDENTIFIER_CONSISTENCY", SWIG_From_int(static_cast< int >(LIBSBML_CAT_IDENTIFIER_CONSISTENCY)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_UNITS_CONSISTENCY", SWIG_From_int(static_cast< int >(LIBSBML_CAT_UNITS_CONSISTENCY)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_MATHML_CONSISTENCY", SWIG_From_int(static_cast< int >(LIBSBML_CAT_MATHML_CONSISTENCY)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBO_CONSISTENCY", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBO_CONSISTENCY)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_OVERDETERMINED_MODEL", SWIG_From_int(static_cast< int >(LIBSBML_CAT_OVERDETERMINED_MODEL)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML_L2V3_COMPAT", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V3_COMPAT)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_MODELING_PRACTICE", SWIG_From_int(static_cast< int >(LIBSBML_CAT_MODELING_PRACTICE)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_INTERNAL_CONSISTENCY", SWIG_From_int(static_cast< int >(LIBSBML_CAT_INTERNAL_CONSISTENCY)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML_L2V4_COMPAT", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V4_COMPAT)));
  rb_define_const(mLibSBML, "LIBSBML_CAT_SBML_L3V1_COMPAT", SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L3V1_COMPAT)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_SCHEMA_ERROR", SWIG_From_int(static_cast< int >(LIBSBML_SEV_SCHEMA_ERROR)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_GENERAL_WARNING", SWIG_From_int(static_cast< int >(LIBSBML_SEV_GENERAL_WARNING)));
  rb_define_const(mLibSBML, "LIBSBML_SEV_NOT_APPLICABLE", SWIG_From_int(static_cast< int >(LIBSBML_SEV_NOT_APPLICABLE)));
  
  SwigClassSBMLError.klass = rb_define_class_under(mLibSBML, "SBMLError", ((swig_class *) SWIGTYPE_p_XMLError->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLError, (void *) &SwigClassSBMLError);
  rb_define_alloc_func(SwigClassSBMLError.klass, _wrap_SBMLError_allocate);
  rb_define_method(SwigClassSBMLError.klass, "initialize", VALUEFUNC(_wrap_new_SBMLError), -1);
  SwigClassSBMLError.mark = 0;
  SwigClassSBMLError.destroy = (void (*)(void *)) free_SBMLError;
  SwigClassSBMLError.trackObjects = 1;
  rb_define_const(mLibSBML, "MODEL_QUALIFIER", SWIG_From_int(static_cast< int >(MODEL_QUALIFIER)));
  rb_define_const(mLibSBML, "BIOLOGICAL_QUALIFIER", SWIG_From_int(static_cast< int >(BIOLOGICAL_QUALIFIER)));
  rb_define_const(mLibSBML, "UNKNOWN_QUALIFIER", SWIG_From_int(static_cast< int >(UNKNOWN_QUALIFIER)));
  rb_define_const(mLibSBML, "BQM_IS", SWIG_From_int(static_cast< int >(BQM_IS)));
  rb_define_const(mLibSBML, "BQM_IS_DESCRIBED_BY", SWIG_From_int(static_cast< int >(BQM_IS_DESCRIBED_BY)));
  rb_define_const(mLibSBML, "BQM_IS_DERIVED_FROM", SWIG_From_int(static_cast< int >(BQM_IS_DERIVED_FROM)));
  rb_define_const(mLibSBML, "BQM_UNKNOWN", SWIG_From_int(static_cast< int >(BQM_UNKNOWN)));
  rb_define_const(mLibSBML, "BQB_IS", SWIG_From_int(static_cast< int >(BQB_IS)));
  rb_define_const(mLibSBML, "BQB_HAS_PART", SWIG_From_int(static_cast< int >(BQB_HAS_PART)));
  rb_define_const(mLibSBML, "BQB_IS_PART_OF", SWIG_From_int(static_cast< int >(BQB_IS_PART_OF)));
  rb_define_const(mLibSBML, "BQB_IS_VERSION_OF", SWIG_From_int(static_cast< int >(BQB_IS_VERSION_OF)));
  rb_define_const(mLibSBML, "BQB_HAS_VERSION", SWIG_From_int(static_cast< int >(BQB_HAS_VERSION)));
  rb_define_const(mLibSBML, "BQB_IS_HOMOLOG_TO", SWIG_From_int(static_cast< int >(BQB_IS_HOMOLOG_TO)));
  rb_define_const(mLibSBML, "BQB_IS_DESCRIBED_BY", SWIG_From_int(static_cast< int >(BQB_IS_DESCRIBED_BY)));
  rb_define_const(mLibSBML, "BQB_IS_ENCODED_BY", SWIG_From_int(static_cast< int >(BQB_IS_ENCODED_BY)));
  rb_define_const(mLibSBML, "BQB_ENCODES", SWIG_From_int(static_cast< int >(BQB_ENCODES)));
  rb_define_const(mLibSBML, "BQB_OCCURS_IN", SWIG_From_int(static_cast< int >(BQB_OCCURS_IN)));
  rb_define_const(mLibSBML, "BQB_HAS_PROPERTY", SWIG_From_int(static_cast< int >(BQB_HAS_PROPERTY)));
  rb_define_const(mLibSBML, "BQB_IS_PROPERTY_OF", SWIG_From_int(static_cast< int >(BQB_IS_PROPERTY_OF)));
  rb_define_const(mLibSBML, "BQB_UNKNOWN", SWIG_From_int(static_cast< int >(BQB_UNKNOWN)));
  
  SwigClassCVTerm.klass = rb_define_class_under(mLibSBML, "CVTerm", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_CVTerm, (void *) &SwigClassCVTerm);
  rb_define_alloc_func(SwigClassCVTerm.klass, _wrap_CVTerm_allocate);
  rb_define_method(SwigClassCVTerm.klass, "initialize", VALUEFUNC(_wrap_new_CVTerm), -1);
  rb_define_method(SwigClassCVTerm.klass, "clone", VALUEFUNC(_wrap_CVTerm_clone), -1);
  rb_define_method(SwigClassCVTerm.klass, "getQualifierType", VALUEFUNC(_wrap_CVTerm_getQualifierType), -1);
  rb_define_method(SwigClassCVTerm.klass, "getModelQualifierType", VALUEFUNC(_wrap_CVTerm_getModelQualifierType), -1);
  rb_define_method(SwigClassCVTerm.klass, "getBiologicalQualifierType", VALUEFUNC(_wrap_CVTerm_getBiologicalQualifierType), -1);
  rb_define_method(SwigClassCVTerm.klass, "getResources", VALUEFUNC(_wrap_CVTerm_getResources), -1);
  rb_define_method(SwigClassCVTerm.klass, "getNumResources", VALUEFUNC(_wrap_CVTerm_getNumResources), -1);
  rb_define_method(SwigClassCVTerm.klass, "getResourceURI", VALUEFUNC(_wrap_CVTerm_getResourceURI), -1);
  rb_define_method(SwigClassCVTerm.klass, "setQualifierType", VALUEFUNC(_wrap_CVTerm_setQualifierType), -1);
  rb_define_method(SwigClassCVTerm.klass, "setModelQualifierType", VALUEFUNC(_wrap_CVTerm_setModelQualifierType), -1);
  rb_define_method(SwigClassCVTerm.klass, "setBiologicalQualifierType", VALUEFUNC(_wrap_CVTerm_setBiologicalQualifierType), -1);
  rb_define_method(SwigClassCVTerm.klass, "addResource", VALUEFUNC(_wrap_CVTerm_addResource), -1);
  rb_define_method(SwigClassCVTerm.klass, "removeResource", VALUEFUNC(_wrap_CVTerm_removeResource), -1);
  rb_define_method(SwigClassCVTerm.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_CVTerm_hasRequiredAttributes), -1);
  SwigClassCVTerm.mark = 0;
  SwigClassCVTerm.destroy = (void (*)(void *)) free_CVTerm;
  SwigClassCVTerm.trackObjects = 1;
  
  SwigClassDate.klass = rb_define_class_under(mLibSBML, "Date", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_Date, (void *) &SwigClassDate);
  rb_define_alloc_func(SwigClassDate.klass, _wrap_Date_allocate);
  rb_define_method(SwigClassDate.klass, "initialize", VALUEFUNC(_wrap_new_Date), -1);
  rb_define_method(SwigClassDate.klass, "clone", VALUEFUNC(_wrap_Date_clone), -1);
  rb_define_method(SwigClassDate.klass, "getYear", VALUEFUNC(_wrap_Date_getYear), -1);
  rb_define_method(SwigClassDate.klass, "getMonth", VALUEFUNC(_wrap_Date_getMonth), -1);
  rb_define_method(SwigClassDate.klass, "getDay", VALUEFUNC(_wrap_Date_getDay), -1);
  rb_define_method(SwigClassDate.klass, "getHour", VALUEFUNC(_wrap_Date_getHour), -1);
  rb_define_method(SwigClassDate.klass, "getMinute", VALUEFUNC(_wrap_Date_getMinute), -1);
  rb_define_method(SwigClassDate.klass, "getSecond", VALUEFUNC(_wrap_Date_getSecond), -1);
  rb_define_method(SwigClassDate.klass, "getSignOffset", VALUEFUNC(_wrap_Date_getSignOffset), -1);
  rb_define_method(SwigClassDate.klass, "getHoursOffset", VALUEFUNC(_wrap_Date_getHoursOffset), -1);
  rb_define_method(SwigClassDate.klass, "getMinutesOffset", VALUEFUNC(_wrap_Date_getMinutesOffset), -1);
  rb_define_method(SwigClassDate.klass, "getDateAsString", VALUEFUNC(_wrap_Date_getDateAsString), -1);
  rb_define_method(SwigClassDate.klass, "setYear", VALUEFUNC(_wrap_Date_setYear), -1);
  rb_define_method(SwigClassDate.klass, "setMonth", VALUEFUNC(_wrap_Date_setMonth), -1);
  rb_define_method(SwigClassDate.klass, "setDay", VALUEFUNC(_wrap_Date_setDay), -1);
  rb_define_method(SwigClassDate.klass, "setHour", VALUEFUNC(_wrap_Date_setHour), -1);
  rb_define_method(SwigClassDate.klass, "setMinute", VALUEFUNC(_wrap_Date_setMinute), -1);
  rb_define_method(SwigClassDate.klass, "setSecond", VALUEFUNC(_wrap_Date_setSecond), -1);
  rb_define_method(SwigClassDate.klass, "setSignOffset", VALUEFUNC(_wrap_Date_setSignOffset), -1);
  rb_define_method(SwigClassDate.klass, "setHoursOffset", VALUEFUNC(_wrap_Date_setHoursOffset), -1);
  rb_define_method(SwigClassDate.klass, "setMinutesOffset", VALUEFUNC(_wrap_Date_setMinutesOffset), -1);
  rb_define_method(SwigClassDate.klass, "setDateAsString", VALUEFUNC(_wrap_Date_setDateAsString), -1);
  rb_define_method(SwigClassDate.klass, "representsValidDate", VALUEFUNC(_wrap_Date_representsValidDate), -1);
  SwigClassDate.mark = 0;
  SwigClassDate.destroy = (void (*)(void *)) free_Date;
  SwigClassDate.trackObjects = 1;
  
  SwigClassModelCreator.klass = rb_define_class_under(mLibSBML, "ModelCreator", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ModelCreator, (void *) &SwigClassModelCreator);
  rb_define_alloc_func(SwigClassModelCreator.klass, _wrap_ModelCreator_allocate);
  rb_define_method(SwigClassModelCreator.klass, "initialize", VALUEFUNC(_wrap_new_ModelCreator), -1);
  rb_define_method(SwigClassModelCreator.klass, "clone", VALUEFUNC(_wrap_ModelCreator_clone), -1);
  rb_define_method(SwigClassModelCreator.klass, "getFamilyName", VALUEFUNC(_wrap_ModelCreator_getFamilyName), -1);
  rb_define_method(SwigClassModelCreator.klass, "getGivenName", VALUEFUNC(_wrap_ModelCreator_getGivenName), -1);
  rb_define_method(SwigClassModelCreator.klass, "getEmail", VALUEFUNC(_wrap_ModelCreator_getEmail), -1);
  rb_define_method(SwigClassModelCreator.klass, "getOrganization", VALUEFUNC(_wrap_ModelCreator_getOrganization), -1);
  rb_define_method(SwigClassModelCreator.klass, "getOrganisation", VALUEFUNC(_wrap_ModelCreator_getOrganisation), -1);
  rb_define_method(SwigClassModelCreator.klass, "isSetFamilyName", VALUEFUNC(_wrap_ModelCreator_isSetFamilyName), -1);
  rb_define_method(SwigClassModelCreator.klass, "isSetGivenName", VALUEFUNC(_wrap_ModelCreator_isSetGivenName), -1);
  rb_define_method(SwigClassModelCreator.klass, "isSetEmail", VALUEFUNC(_wrap_ModelCreator_isSetEmail), -1);
  rb_define_method(SwigClassModelCreator.klass, "isSetOrganization", VALUEFUNC(_wrap_ModelCreator_isSetOrganization), -1);
  rb_define_method(SwigClassModelCreator.klass, "isSetOrganisation", VALUEFUNC(_wrap_ModelCreator_isSetOrganisation), -1);
  rb_define_method(SwigClassModelCreator.klass, "setFamilyName", VALUEFUNC(_wrap_ModelCreator_setFamilyName), -1);
  rb_define_method(SwigClassModelCreator.klass, "setGivenName", VALUEFUNC(_wrap_ModelCreator_setGivenName), -1);
  rb_define_method(SwigClassModelCreator.klass, "setEmail", VALUEFUNC(_wrap_ModelCreator_setEmail), -1);
  rb_define_method(SwigClassModelCreator.klass, "setOrganization", VALUEFUNC(_wrap_ModelCreator_setOrganization), -1);
  rb_define_method(SwigClassModelCreator.klass, "setOrganisation", VALUEFUNC(_wrap_ModelCreator_setOrganisation), -1);
  rb_define_method(SwigClassModelCreator.klass, "unsetFamilyName", VALUEFUNC(_wrap_ModelCreator_unsetFamilyName), -1);
  rb_define_method(SwigClassModelCreator.klass, "unsetGivenName", VALUEFUNC(_wrap_ModelCreator_unsetGivenName), -1);
  rb_define_method(SwigClassModelCreator.klass, "unsetEmail", VALUEFUNC(_wrap_ModelCreator_unsetEmail), -1);
  rb_define_method(SwigClassModelCreator.klass, "unsetOrganization", VALUEFUNC(_wrap_ModelCreator_unsetOrganization), -1);
  rb_define_method(SwigClassModelCreator.klass, "unsetOrganisation", VALUEFUNC(_wrap_ModelCreator_unsetOrganisation), -1);
  rb_define_method(SwigClassModelCreator.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_ModelCreator_hasRequiredAttributes), -1);
  SwigClassModelCreator.mark = 0;
  SwigClassModelCreator.destroy = (void (*)(void *)) free_ModelCreator;
  SwigClassModelCreator.trackObjects = 1;
  
  SwigClassModelHistory.klass = rb_define_class_under(mLibSBML, "ModelHistory", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ModelHistory, (void *) &SwigClassModelHistory);
  rb_define_alloc_func(SwigClassModelHistory.klass, _wrap_ModelHistory_allocate);
  rb_define_method(SwigClassModelHistory.klass, "initialize", VALUEFUNC(_wrap_new_ModelHistory), -1);
  rb_define_method(SwigClassModelHistory.klass, "clone", VALUEFUNC(_wrap_ModelHistory_clone), -1);
  rb_define_method(SwigClassModelHistory.klass, "getCreatedDate", VALUEFUNC(_wrap_ModelHistory_getCreatedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "isSetCreatedDate", VALUEFUNC(_wrap_ModelHistory_isSetCreatedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "isSetModifiedDate", VALUEFUNC(_wrap_ModelHistory_isSetModifiedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "setCreatedDate", VALUEFUNC(_wrap_ModelHistory_setCreatedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "setModifiedDate", VALUEFUNC(_wrap_ModelHistory_setModifiedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "addModifiedDate", VALUEFUNC(_wrap_ModelHistory_addModifiedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "getListModifiedDates", VALUEFUNC(_wrap_ModelHistory_getListModifiedDates), -1);
  rb_define_method(SwigClassModelHistory.klass, "getModifiedDate", VALUEFUNC(_wrap_ModelHistory_getModifiedDate), -1);
  rb_define_method(SwigClassModelHistory.klass, "getNumModifiedDates", VALUEFUNC(_wrap_ModelHistory_getNumModifiedDates), -1);
  rb_define_method(SwigClassModelHistory.klass, "addCreator", VALUEFUNC(_wrap_ModelHistory_addCreator), -1);
  rb_define_method(SwigClassModelHistory.klass, "getListCreators", VALUEFUNC(_wrap_ModelHistory_getListCreators), -1);
  rb_define_method(SwigClassModelHistory.klass, "getCreator", VALUEFUNC(_wrap_ModelHistory_getCreator), -1);
  rb_define_method(SwigClassModelHistory.klass, "getNumCreators", VALUEFUNC(_wrap_ModelHistory_getNumCreators), -1);
  rb_define_method(SwigClassModelHistory.klass, "hasRequiredAttributes", VALUEFUNC(_wrap_ModelHistory_hasRequiredAttributes), -1);
  SwigClassModelHistory.mark = 0;
  SwigClassModelHistory.destroy = (void (*)(void *)) free_ModelHistory;
  SwigClassModelHistory.trackObjects = 1;
  
  SwigClassRDFAnnotationParser.klass = rb_define_class_under(mLibSBML, "RDFAnnotationParser", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_RDFAnnotationParser, (void *) &SwigClassRDFAnnotationParser);
  rb_define_alloc_func(SwigClassRDFAnnotationParser.klass, _wrap_RDFAnnotationParser_allocate);
  rb_define_method(SwigClassRDFAnnotationParser.klass, "initialize", VALUEFUNC(_wrap_new_RDFAnnotationParser), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "createAnnotation", VALUEFUNC(_wrap_RDFAnnotationParser_createAnnotation), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "createRDFAnnotation", VALUEFUNC(_wrap_RDFAnnotationParser_createRDFAnnotation), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "deleteRDFAnnotation", VALUEFUNC(_wrap_RDFAnnotationParser_deleteRDFAnnotation), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "createRDFDescription", VALUEFUNC(_wrap_RDFAnnotationParser_createRDFDescription), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "createCVTerms", VALUEFUNC(_wrap_RDFAnnotationParser_createCVTerms), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "parseCVTerms", VALUEFUNC(_wrap_RDFAnnotationParser_parseCVTerms), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "parseModelHistory", VALUEFUNC(_wrap_RDFAnnotationParser_parseModelHistory), -1);
  rb_define_singleton_method(SwigClassRDFAnnotationParser.klass, "parseRDFAnnotation", VALUEFUNC(_wrap_RDFAnnotationParser_parseRDFAnnotation), -1);
  SwigClassRDFAnnotationParser.mark = 0;
  SwigClassRDFAnnotationParser.destroy = (void (*)(void *)) free_RDFAnnotationParser;
  SwigClassRDFAnnotationParser.trackObjects = 1;
  
  SwigClassISBMLExtensionNamespaces.klass = rb_define_class_under(mLibSBML, "ISBMLExtensionNamespaces", ((swig_class *) SWIGTYPE_p_SBMLNamespaces->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ISBMLExtensionNamespaces, (void *) &SwigClassISBMLExtensionNamespaces);
  rb_undef_alloc_func(SwigClassISBMLExtensionNamespaces.klass);
  rb_define_method(SwigClassISBMLExtensionNamespaces.klass, "getURI", VALUEFUNC(_wrap_ISBMLExtensionNamespaces_getURI), -1);
  rb_define_method(SwigClassISBMLExtensionNamespaces.klass, "getPackageVersion", VALUEFUNC(_wrap_ISBMLExtensionNamespaces_getPackageVersion), -1);
  rb_define_method(SwigClassISBMLExtensionNamespaces.klass, "getPackageName", VALUEFUNC(_wrap_ISBMLExtensionNamespaces_getPackageName), -1);
  rb_define_method(SwigClassISBMLExtensionNamespaces.klass, "setPackageVersion", VALUEFUNC(_wrap_ISBMLExtensionNamespaces_setPackageVersion), -1);
  SwigClassISBMLExtensionNamespaces.mark = 0;
  SwigClassISBMLExtensionNamespaces.destroy = (void (*)(void *)) free_ISBMLExtensionNamespaces;
  SwigClassISBMLExtensionNamespaces.trackObjects = 1;
  
  SwigClassSBaseExtensionPoint.klass = rb_define_class_under(mLibSBML, "SBaseExtensionPoint", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBaseExtensionPoint, (void *) &SwigClassSBaseExtensionPoint);
  rb_define_alloc_func(SwigClassSBaseExtensionPoint.klass, _wrap_SBaseExtensionPoint_allocate);
  rb_define_method(SwigClassSBaseExtensionPoint.klass, "initialize", VALUEFUNC(_wrap_new_SBaseExtensionPoint), -1);
  rb_define_method(SwigClassSBaseExtensionPoint.klass, "clone", VALUEFUNC(_wrap_SBaseExtensionPoint_clone), -1);
  rb_define_method(SwigClassSBaseExtensionPoint.klass, "getPackageName", VALUEFUNC(_wrap_SBaseExtensionPoint_getPackageName), -1);
  rb_define_method(SwigClassSBaseExtensionPoint.klass, "getTypeCode", VALUEFUNC(_wrap_SBaseExtensionPoint_getTypeCode), -1);
  SwigClassSBaseExtensionPoint.mark = 0;
  SwigClassSBaseExtensionPoint.destroy = (void (*)(void *)) free_SBaseExtensionPoint;
  SwigClassSBaseExtensionPoint.trackObjects = 1;
  
  SwigClassSBasePlugin.klass = rb_define_class_under(mLibSBML, "SBasePlugin", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBasePlugin, (void *) &SwigClassSBasePlugin);
  rb_undef_alloc_func(SwigClassSBasePlugin.klass);
  rb_define_method(SwigClassSBasePlugin.klass, "getURI", VALUEFUNC(_wrap_SBasePlugin_getURI), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getPrefix", VALUEFUNC(_wrap_SBasePlugin_getPrefix), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getPackageName", VALUEFUNC(_wrap_SBasePlugin_getPackageName), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "clone", VALUEFUNC(_wrap_SBasePlugin_clone), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "connectToParent", VALUEFUNC(_wrap_SBasePlugin_connectToParent), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "enablePackageInternal", VALUEFUNC(_wrap_SBasePlugin_enablePackageInternal), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getSBMLDocument", VALUEFUNC(_wrap_SBasePlugin_getSBMLDocument), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getParentSBMLObject", VALUEFUNC(_wrap_SBasePlugin_getParentSBMLObject), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getLevel", VALUEFUNC(_wrap_SBasePlugin_getLevel), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getVersion", VALUEFUNC(_wrap_SBasePlugin_getVersion), -1);
  rb_define_method(SwigClassSBasePlugin.klass, "getPackageVersion", VALUEFUNC(_wrap_SBasePlugin_getPackageVersion), -1);
  SwigClassSBasePlugin.mark = 0;
  SwigClassSBasePlugin.destroy = (void (*)(void *)) free_SBasePlugin;
  SwigClassSBasePlugin.trackObjects = 1;
  
  SwigClassSBMLDocumentPlugin.klass = rb_define_class_under(mLibSBML, "SBMLDocumentPlugin", ((swig_class *) SWIGTYPE_p_SBasePlugin->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLDocumentPlugin, (void *) &SwigClassSBMLDocumentPlugin);
  rb_define_alloc_func(SwigClassSBMLDocumentPlugin.klass, _wrap_SBMLDocumentPlugin_allocate);
  rb_define_method(SwigClassSBMLDocumentPlugin.klass, "initialize", VALUEFUNC(_wrap_new_SBMLDocumentPlugin), -1);
  rb_define_method(SwigClassSBMLDocumentPlugin.klass, "clone", VALUEFUNC(_wrap_SBMLDocumentPlugin_clone), -1);
  rb_define_method(SwigClassSBMLDocumentPlugin.klass, "getRequired", VALUEFUNC(_wrap_SBMLDocumentPlugin_getRequired), -1);
  rb_define_method(SwigClassSBMLDocumentPlugin.klass, "setRequired", VALUEFUNC(_wrap_SBMLDocumentPlugin_setRequired), -1);
  SwigClassSBMLDocumentPlugin.mark = 0;
  SwigClassSBMLDocumentPlugin.destroy = (void (*)(void *)) free_SBMLDocumentPlugin;
  SwigClassSBMLDocumentPlugin.trackObjects = 1;
  
  SwigClassSBMLExtension.klass = rb_define_class_under(mLibSBML, "SBMLExtension", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLExtension, (void *) &SwigClassSBMLExtension);
  rb_undef_alloc_func(SwigClassSBMLExtension.klass);
  rb_define_method(SwigClassSBMLExtension.klass, "getNumOfSBasePlugins", VALUEFUNC(_wrap_SBMLExtension_getNumOfSBasePlugins), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getNumOfSupportedPackageURI", VALUEFUNC(_wrap_SBMLExtension_getNumOfSupportedPackageURI), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "isSupported", VALUEFUNC(_wrap_SBMLExtension_isSupported), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getSupportedPackageURI", VALUEFUNC(_wrap_SBMLExtension_getSupportedPackageURI), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "clone", VALUEFUNC(_wrap_SBMLExtension_clone), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getName", VALUEFUNC(_wrap_SBMLExtension_getName), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getURI", VALUEFUNC(_wrap_SBMLExtension_getURI), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getLevel", VALUEFUNC(_wrap_SBMLExtension_getLevel), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getVersion", VALUEFUNC(_wrap_SBMLExtension_getVersion), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getPackageVersion", VALUEFUNC(_wrap_SBMLExtension_getPackageVersion), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getStringFromTypeCode", VALUEFUNC(_wrap_SBMLExtension_getStringFromTypeCode), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "getSBMLExtensionNamespaces", VALUEFUNC(_wrap_SBMLExtension_getSBMLExtensionNamespaces), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "setEnabled", VALUEFUNC(_wrap_SBMLExtension_setEnabled), -1);
  rb_define_method(SwigClassSBMLExtension.klass, "isEnabled", VALUEFUNC(_wrap_SBMLExtension_isEnabled), -1);
  SwigClassSBMLExtension.mark = 0;
  SwigClassSBMLExtension.destroy = (void (*)(void *)) free_SBMLExtension;
  SwigClassSBMLExtension.trackObjects = 1;
  
  SwigClassSBMLExtensionException.klass = rb_define_class_under(mLibSBML, "SBMLExtensionException", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLExtensionException, (void *) &SwigClassSBMLExtensionException);
  rb_define_alloc_func(SwigClassSBMLExtensionException.klass, _wrap_SBMLExtensionException_allocate);
  rb_define_method(SwigClassSBMLExtensionException.klass, "initialize", VALUEFUNC(_wrap_new_SBMLExtensionException), -1);
  SwigClassSBMLExtensionException.mark = 0;
  SwigClassSBMLExtensionException.destroy = (void (*)(void *)) free_SBMLExtensionException;
  SwigClassSBMLExtensionException.trackObjects = 1;
  
  SwigClassSBMLExtensionRegistry.klass = rb_define_class_under(mLibSBML, "SBMLExtensionRegistry", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SBMLExtensionRegistry, (void *) &SwigClassSBMLExtensionRegistry);
  rb_undef_alloc_func(SwigClassSBMLExtensionRegistry.klass);
  rb_define_singleton_method(SwigClassSBMLExtensionRegistry.klass, "getInstance", VALUEFUNC(_wrap_SBMLExtensionRegistry_getInstance), -1);
  rb_define_method(SwigClassSBMLExtensionRegistry.klass, "addExtension", VALUEFUNC(_wrap_SBMLExtensionRegistry_addExtension), -1);
  rb_define_method(SwigClassSBMLExtensionRegistry.klass, "getExtension", VALUEFUNC(_wrap_SBMLExtensionRegistry_getExtension), -1);
  rb_define_method(SwigClassSBMLExtensionRegistry.klass, "getNumExtension", VALUEFUNC(_wrap_SBMLExtensionRegistry_getNumExtension), -1);
  rb_define_method(SwigClassSBMLExtensionRegistry.klass, "setEnabled", VALUEFUNC(_wrap_SBMLExtensionRegistry_setEnabled), -1);
  rb_define_method(SwigClassSBMLExtensionRegistry.klass, "isEnabled", VALUEFUNC(_wrap_SBMLExtensionRegistry_isEnabled), -1);
  rb_define_method(SwigClassSBMLExtensionRegistry.klass, "isRegistered", VALUEFUNC(_wrap_SBMLExtensionRegistry_isRegistered), -1);
  SwigClassSBMLExtensionRegistry.mark = 0;
  SwigClassSBMLExtensionRegistry.destroy = (void (*)(void *)) free_SBMLExtensionRegistry;
  SwigClassSBMLExtensionRegistry.trackObjects = 1;
}

